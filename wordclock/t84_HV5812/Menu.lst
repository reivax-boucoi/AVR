   1               		.file	"Menu.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	MsetEventMode
  12               	MsetEventMode:
  13               	.LFB23:
  14               		.file 1 "Menu.c"
   1:Menu.c        **** #include "Menu.h"
   2:Menu.c        **** 
   3:Menu.c        **** uint8_t mode=1;//0: hour only, 1-2: hour+temp, 3: temp only
   4:Menu.c        **** uint8_t colorMode=0;
   5:Menu.c        **** uint8_t findNextEntry(Menu* m,uint8_t index){
   6:Menu.c        ****     if((index+2)>(m->nb_optn%16))return 0;
   7:Menu.c        ****     return index+1;
   8:Menu.c        **** }
   9:Menu.c        **** 
  10:Menu.c        **** Menu* getSubMenu(Menu* m,uint8_t index){
  11:Menu.c        ****     if(m->sub[index].submenu==0)return 0;//if executed NULL, return blank menu (==exit setup)
  12:Menu.c        ****     return m->sub[index].submenu;
  13:Menu.c        **** }
  14:Menu.c        **** void EEPROM_write(uint8_t addr, uint8_t data){
  15:Menu.c        ****     while(EECR & (1<<EEPE));
  16:Menu.c        ****     EECR = (0<<EEPM1)|(0<<EEPM0);
  17:Menu.c        ****     EEAR = addr;
  18:Menu.c        ****     EEDR = data;
  19:Menu.c        ****     EECR |= (1<<EEMPE);
  20:Menu.c        ****     EECR |= (1<<EEPE);
  21:Menu.c        **** }
  22:Menu.c        **** uint8_t EEPROM_read(uint8_t addr){
  23:Menu.c        ****     while(EECR & (1<<EEPE));
  24:Menu.c        ****     EEAR = addr;
  25:Menu.c        ****     EECR |= (1<<EERE);
  26:Menu.c        ****     return EEDR;
  27:Menu.c        **** }
  28:Menu.c        **** 
  29:Menu.c        **** void Minit(void){
  30:Menu.c        ****     colorMode=EEPROM_read(EE_COLOR);
  31:Menu.c        ****     MsetMode(EEPROM_read(EE_MODE));
  32:Menu.c        **** }
  33:Menu.c        **** const Menu M0main={8,0,{//WHITE
  34:Menu.c        ****     {7,&M1mode},
  35:Menu.c        ****     {8,&M1cmode},
  36:Menu.c        ****     {10,&M1nightmode},
  37:Menu.c        ****     {14,&M1setTime},
  38:Menu.c        ****     {0,&M1eventMode},
  39:Menu.c        ****     {4,&M1reset},
  40:Menu.c        ****     {17,&M1rainbow},
  41:Menu.c        ****     {HEURE,0}//exit      
  42:Menu.c        **** }};
  43:Menu.c        **** const Menu M1mode={5+16,MsetMode,{//CYAN
  44:Menu.c        ****     {7,0},//Hour only
  45:Menu.c        ****     {8,0},//Hour + temp (slow)
  46:Menu.c        ****     {10,0},//Hour + temp (fast)
  47:Menu.c        ****     {14,0},//temp only
  48:Menu.c        ****     {HEURE,&M0main}//return    
  49:Menu.c        **** }};
  50:Menu.c        **** const Menu M1cmode={10+32,MsetColorMode,{//BLUE
  51:Menu.c        ****     {7,0},//fixed WHITE 1
  52:Menu.c        ****     {8,0},//fixed CYAN 2
  53:Menu.c        ****     {10,0},//fixed BLUE 3
  54:Menu.c        ****     {14,0},//fixed MAGENTA 4
  55:Menu.c        ****     {0,0},//fixed RED 5
  56:Menu.c        ****     {4,0},//fixed YELLOW 6
  57:Menu.c        ****     {17,0},//fixed GREEN 7
  58:Menu.c        ****     {2,0},// cycle single 8
  59:Menu.c        ****     {12,0},// cycle all 9
  60:Menu.c        ****     {HEURE,&M0main}//return    
  61:Menu.c        **** }};
  62:Menu.c        **** const Menu M1nightmode={4+48,MsetNightMode,{//MAGENTA
  63:Menu.c        ****     {7,0},//none
  64:Menu.c        ****     {8,&M2offhour},//Half brightness
  65:Menu.c        ****     {10,&M2offhour},//Off completely
  66:Menu.c        ****     {HEURE,&M0main}//return
  67:Menu.c        **** }};
  68:Menu.c        **** const Menu M2offhour={12+64,MsetNightOff,{//RED
  69:Menu.c        ****     {7,&M3onhour},//heures
  70:Menu.c        ****     {8,&M3onhour},
  71:Menu.c        ****     {10,&M3onhour},
  72:Menu.c        ****     {14,&M3onhour},
  73:Menu.c        ****     {0,&M3onhour},
  74:Menu.c        ****     {4,&M3onhour},
  75:Menu.c        ****     {17,&M3onhour},
  76:Menu.c        ****     {2,&M3onhour},
  77:Menu.c        ****     {12,&M3onhour},
  78:Menu.c        ****     {6,&M3onhour},
  79:Menu.c        ****     {16,&M3onhour},
  80:Menu.c        ****     {HEURE,&M1nightmode}//return
  81:Menu.c        **** }};
  82:Menu.c        **** const Menu M3onhour={12+80,MsetNightOn,{//YELLOW
  83:Menu.c        ****     {7,0},//heures
  84:Menu.c        ****     {8,0},
  85:Menu.c        ****     {10,0},
  86:Menu.c        ****     {14,0},
  87:Menu.c        ****     {0,0},
  88:Menu.c        ****     {4,0},
  89:Menu.c        ****     {17,0},
  90:Menu.c        ****     {2,0},
  91:Menu.c        ****     {12,0},
  92:Menu.c        ****     {6,0},
  93:Menu.c        ****     {16,0},
  94:Menu.c        ****     {HEURE,&M1nightmode}//return
  95:Menu.c        **** }};
  96:Menu.c        **** const Menu M1setTime={5,0,{
  97:Menu.c        ****     {7,&M2sethouram},//hour am
  98:Menu.c        ****     {8,&M2sethourpm},//hour pm
  99:Menu.c        ****     {10,&M2setminam},//min am
 100:Menu.c        ****     {14,&M2setminpm},//min pm
 101:Menu.c        ****     {HEURE,&M0main}//return
 102:Menu.c        **** }};
 103:Menu.c        **** const Menu M2sethouram={13,MsetHouram,{
 104:Menu.c        ****     {7,0},//heure
 105:Menu.c        ****     {8,0},
 106:Menu.c        ****     {10,0},
 107:Menu.c        ****     {14,0},
 108:Menu.c        ****     {0,0},
 109:Menu.c        ****     {4,0},
 110:Menu.c        ****     {17,0},
 111:Menu.c        ****     {2,0},
 112:Menu.c        ****     {12,0},
 113:Menu.c        ****     {6,0},
 114:Menu.c        ****     {16,0},
 115:Menu.c        ****     {MIDI,0},//midi
 116:Menu.c        ****     {HEURE,&M1setTime}//return
 117:Menu.c        **** }};
 118:Menu.c        **** const Menu M2sethourpm={13,MsetHourpm,{
 119:Menu.c        ****     {7,0},//heure
 120:Menu.c        ****     {8,0},
 121:Menu.c        ****     {10,0},
 122:Menu.c        ****     {14,0},
 123:Menu.c        ****     {0,0},
 124:Menu.c        ****     {4,0},
 125:Menu.c        ****     {17,0},
 126:Menu.c        ****     {2,0},
 127:Menu.c        ****     {12,0},
 128:Menu.c        ****     {6,0},
 129:Menu.c        ****     {16,0},
 130:Menu.c        ****     {MINUIT,0},//minuit
 131:Menu.c        ****     {HEURE,&M1setTime}//return
 132:Menu.c        **** }};
 133:Menu.c        **** const Menu M2setminam={4,MsetMinam,{
 134:Menu.c        ****     {DIX,0},//dix
 135:Menu.c        ****     {VINGT,0},//vingt
 136:Menu.c        ****     {ETDEMIE,0},//1/2
 137:Menu.c        ****     {HEURE,&M1setTime}//return
 138:Menu.c        **** }};
 139:Menu.c        **** const Menu M2setminpm={4,MsetMinpm,{
 140:Menu.c        ****     {DIX,0},//dix
 141:Menu.c        ****     {VINGT,0},//vingt
 142:Menu.c        ****     {ETDEMIE,0},//1/2
 143:Menu.c        ****     {HEURE,&M1setTime}//return
 144:Menu.c        **** }};
 145:Menu.c        **** const Menu M1eventMode={3,MsetEventMode,{
 146:Menu.c        ****     {7,0},//Event on
 147:Menu.c        ****     {8,0},//Event off
 148:Menu.c        ****     {HEURE,&M0main}//return
 149:Menu.c        **** }};
 150:Menu.c        **** const Menu M1reset={2,Mreset,{
 151:Menu.c        ****     {18,0},//yes
 152:Menu.c        ****     {HEURE,&M0main}//return
 153:Menu.c        **** }};
 154:Menu.c        **** const Menu M1rainbow={3,MsetRainbow,{
 155:Menu.c        ****     {7,0},//Rainbow on
 156:Menu.c        ****     {8,0},//Rainbow off
 157:Menu.c        ****     {HEURE,&M0main}//return
 158:Menu.c        **** }};
 159:Menu.c        **** 
 160:Menu.c        **** void MsetMode(uint8_t i){
 161:Menu.c        ****     if(i<4){
 162:Menu.c        ****         TCCR1B|=(1<<CS12)|(1<<CS10);
 163:Menu.c        ****         if(i==2)TCCR1B&=~(1<<CS10);
 164:Menu.c        ****         mode=i;
 165:Menu.c        ****         EEPROM_write(EE_MODE,i);
 166:Menu.c        ****     }
 167:Menu.c        **** }
 168:Menu.c        **** uint8_t getMode(void){
 169:Menu.c        ****     if(mode==2){
 170:Menu.c        ****         mode=1;
 171:Menu.c        ****     }else if(mode==1){
 172:Menu.c        ****         mode=2;
 173:Menu.c        ****     }
 174:Menu.c        ****     return mode;
 175:Menu.c        **** }
 176:Menu.c        **** void MsetColorMode(uint8_t i){
 177:Menu.c        ****     if(i<7){
 178:Menu.c        ****         colorMode=colorArray[i];//fixed
 179:Menu.c        ****         EEPROM_write(EE_COLOR,colorArray[i]);
 180:Menu.c        ****     }else if(i==7){//cycle single
 181:Menu.c        ****         colorMode=WHITE+128;
 182:Menu.c        ****         EEPROM_write(EE_COLOR,128);
 183:Menu.c        ****     }else if(i==8){//cycle all
 184:Menu.c        ****         colorMode=WHITE+64;
 185:Menu.c        ****         EEPROM_write(EE_COLOR,64);
 186:Menu.c        ****     }
 187:Menu.c        **** }
 188:Menu.c        **** uint8_t getColor(void){
 189:Menu.c        ****     if(colorMode>127){//cycle single
 190:Menu.c        ****         if(colorMode>134)colorMode=128;
 191:Menu.c        ****         colorMode++;
 192:Menu.c        ****         return colorArray[colorMode-128];
 193:Menu.c        ****     }else if(colorMode>63){//cycle all
 194:Menu.c        ****         return RED;
 195:Menu.c        ****     }else{//fixed
 196:Menu.c        ****         return colorMode;
 197:Menu.c        ****     }
 198:Menu.c        **** }
 199:Menu.c        **** void MsetNightMode(uint8_t i){
 200:Menu.c        ****     if(i<3)EEPROM_write(EE_NIGHTMODE,i);
 201:Menu.c        **** }
 202:Menu.c        **** uint8_t isInAllowedTime(uint8_t h){
 203:Menu.c        ****     if(EEPROM_read(EE_NIGHTMODE))return (h>=EEPROM_read(EE_ONHOUR) && h<=EEPROM_read(EE_OFFHOUR));
 204:Menu.c        ****     return 1;
 205:Menu.c        **** }
 206:Menu.c        **** void MsetNightOff(uint8_t i){
 207:Menu.c        ****     EEPROM_write(EE_OFFHOUR,12+i);
 208:Menu.c        **** }
 209:Menu.c        **** void MsetNightOn(uint8_t i){
 210:Menu.c        ****     EEPROM_write(EE_ONHOUR,1+i);
 211:Menu.c        **** }
 212:Menu.c        **** void MsetHouram(uint8_t i){
 213:Menu.c        **** }
 214:Menu.c        **** void MsetHourpm(uint8_t i){
 215:Menu.c        **** }
 216:Menu.c        **** void MsetMinam(uint8_t i){
 217:Menu.c        **** }
 218:Menu.c        **** void MsetMinpm(uint8_t i){
 219:Menu.c        **** }
 220:Menu.c        **** void MsetEventMode(uint8_t i){
  15               		.loc 1 220 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22 0000 0895      		ret
  23               		.cfi_endproc
  24               	.LFE23:
  26               	.global	MsetRainbow
  28               	MsetRainbow:
  29               	.LFB25:
 221:Menu.c        **** }
 222:Menu.c        **** void Mreset(uint8_t i){
 223:Menu.c        ****     if(i<1){
 224:Menu.c        ****         MsetMode(1);
 225:Menu.c        ****         MsetColorMode(0);
 226:Menu.c        ****         EEPROM_write(EE_NIGHTMODE,1);
 227:Menu.c        ****         EEPROM_write(EE_OFFHOUR,12+22);
 228:Menu.c        ****         EEPROM_write(EE_ONHOUR,1+8);
 229:Menu.c        ****         TCCR1B|=(1<<CS12)|(1<<CS10);
 230:Menu.c        ****     }
 231:Menu.c        **** }
 232:Menu.c        **** void MsetRainbow(uint8_t i){
  30               		.loc 1 232 0
  31               		.cfi_startproc
  32               	.LVL1:
  33               	/* prologue: function */
  34               	/* frame size = 0 */
  35               	/* stack size = 0 */
  36               	.L__stack_usage = 0
 233:Menu.c        ****   //  cli();
 234:Menu.c        ****     sendRawData(0b11111100001111111111);//white
  37               		.loc 1 234 0
  38 0002 6FEF      		ldi r22,lo8(-1)
  39 0004 73EC      		ldi r23,lo8(-61)
  40 0006 8FE0      		ldi r24,lo8(15)
  41 0008 90E0      		ldi r25,0
  42 000a 00D0      		rcall sendRawData
  43               	.LVL2:
  44               	.LBB20:
  45               	.LBB21:
  46               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  47               		.loc 2 187 0
  48 000c 2FEF      		ldi r18,lo8(1599999)
  49 000e 89E6      		ldi r24,hi8(1599999)
  50 0010 98E1      		ldi r25,hlo8(1599999)
  51 0012 2150      	1:	subi r18,1
  52 0014 8040      		sbci r24,0
  53 0016 9040      		sbci r25,0
  54 0018 01F4      		brne 1b
  55 001a 00C0      		rjmp .
  56 001c 0000      		nop
  57               	.LVL3:
  58               	.LBE21:
  59               	.LBE20:
 235:Menu.c        ****     _delay_ms(500);
 236:Menu.c        ****     sendRawData(0b11000000001111111111);//green
  60               		.loc 1 236 0
  61 001e 6FEF      		ldi r22,lo8(-1)
  62 0020 73E0      		ldi r23,lo8(3)
  63 0022 8CE0      		ldi r24,lo8(12)
  64 0024 90E0      		ldi r25,0
  65 0026 00D0      		rcall sendRawData
  66               	.LVL4:
  67               	.LBB22:
  68               	.LBB23:
  69               		.loc 2 187 0
  70 0028 2FEF      		ldi r18,lo8(1599999)
  71 002a 89E6      		ldi r24,hi8(1599999)
  72 002c 98E1      		ldi r25,hlo8(1599999)
  73 002e 2150      	1:	subi r18,1
  74 0030 8040      		sbci r24,0
  75 0032 9040      		sbci r25,0
  76 0034 01F4      		brne 1b
  77 0036 00C0      		rjmp .
  78 0038 0000      		nop
  79               	.LVL5:
  80               	.LBE23:
  81               	.LBE22:
 237:Menu.c        ****     _delay_ms(500);
 238:Menu.c        ****     sendRawData(0b00001100001111111111);//red
  82               		.loc 1 238 0
  83 003a 6FEF      		ldi r22,lo8(-1)
  84 003c 73EC      		ldi r23,lo8(-61)
  85 003e 80E0      		ldi r24,0
  86 0040 90E0      		ldi r25,0
  87 0042 00D0      		rcall sendRawData
  88               	.LVL6:
  89               	.LBB24:
  90               	.LBB25:
  91               		.loc 2 187 0
  92 0044 2FEF      		ldi r18,lo8(1599999)
  93 0046 89E6      		ldi r24,hi8(1599999)
  94 0048 98E1      		ldi r25,hlo8(1599999)
  95 004a 2150      	1:	subi r18,1
  96 004c 8040      		sbci r24,0
  97 004e 9040      		sbci r25,0
  98 0050 01F4      		brne 1b
  99 0052 00C0      		rjmp .
 100 0054 0000      		nop
 101               	.LVL7:
 102               	.LBE25:
 103               	.LBE24:
 239:Menu.c        ****     _delay_ms(500);
 240:Menu.c        ****     sendRawData(0b00110000001111111111);//blue
 104               		.loc 1 240 0
 105 0056 6FEF      		ldi r22,lo8(-1)
 106 0058 73E0      		ldi r23,lo8(3)
 107 005a 83E0      		ldi r24,lo8(3)
 108 005c 90E0      		ldi r25,0
 109 005e 00D0      		rcall sendRawData
 110               	.LVL8:
 111               	.LBB26:
 112               	.LBB27:
 113               		.loc 2 187 0
 114 0060 2FEF      		ldi r18,lo8(1599999)
 115 0062 89E6      		ldi r24,hi8(1599999)
 116 0064 98E1      		ldi r25,hlo8(1599999)
 117 0066 2150      	1:	subi r18,1
 118 0068 8040      		sbci r24,0
 119 006a 9040      		sbci r25,0
 120 006c 01F4      		brne 1b
 121 006e 00C0      		rjmp .
 122 0070 0000      		nop
 123               	.LVL9:
 124               	.LBE27:
 125               	.LBE26:
 241:Menu.c        ****     _delay_ms(500);
 242:Menu.c        ****     sendRawData(0b11110000001111111111);//cyan
 126               		.loc 1 242 0
 127 0072 6FEF      		ldi r22,lo8(-1)
 128 0074 73E0      		ldi r23,lo8(3)
 129 0076 8FE0      		ldi r24,lo8(15)
 130 0078 90E0      		ldi r25,0
 131 007a 00D0      		rcall sendRawData
 132               	.LVL10:
 133               	.LBB28:
 134               	.LBB29:
 135               		.loc 2 187 0
 136 007c 2FEF      		ldi r18,lo8(1599999)
 137 007e 89E6      		ldi r24,hi8(1599999)
 138 0080 98E1      		ldi r25,hlo8(1599999)
 139 0082 2150      	1:	subi r18,1
 140 0084 8040      		sbci r24,0
 141 0086 9040      		sbci r25,0
 142 0088 01F4      		brne 1b
 143 008a 00C0      		rjmp .
 144 008c 0000      		nop
 145               	.LVL11:
 146               	.LBE29:
 147               	.LBE28:
 243:Menu.c        ****     _delay_ms(500);
 244:Menu.c        ****     sendRawData(0b00111100001111111111);//magenta
 148               		.loc 1 244 0
 149 008e 6FEF      		ldi r22,lo8(-1)
 150 0090 73EC      		ldi r23,lo8(-61)
 151 0092 83E0      		ldi r24,lo8(3)
 152 0094 90E0      		ldi r25,0
 153 0096 00D0      		rcall sendRawData
 154               	.LVL12:
 155               	.LBB30:
 156               	.LBB31:
 157               		.loc 2 187 0
 158 0098 2FEF      		ldi r18,lo8(1599999)
 159 009a 89E6      		ldi r24,hi8(1599999)
 160 009c 98E1      		ldi r25,hlo8(1599999)
 161 009e 2150      	1:	subi r18,1
 162 00a0 8040      		sbci r24,0
 163 00a2 9040      		sbci r25,0
 164 00a4 01F4      		brne 1b
 165 00a6 00C0      		rjmp .
 166 00a8 0000      		nop
 167               	.LVL13:
 168               	.LBE31:
 169               	.LBE30:
 245:Menu.c        ****     _delay_ms(500);
 246:Menu.c        ****     sendRawData(0b11001100001111111111);//yellow
 170               		.loc 1 246 0
 171 00aa 6FEF      		ldi r22,lo8(-1)
 172 00ac 73EC      		ldi r23,lo8(-61)
 173 00ae 8CE0      		ldi r24,lo8(12)
 174 00b0 90E0      		ldi r25,0
 175 00b2 00D0      		rcall sendRawData
 176               	.LVL14:
 177               	.LBB32:
 178               	.LBB33:
 179               		.loc 2 187 0
 180 00b4 2FEF      		ldi r18,lo8(1599999)
 181 00b6 89E6      		ldi r24,hi8(1599999)
 182 00b8 98E1      		ldi r25,hlo8(1599999)
 183 00ba 2150      	1:	subi r18,1
 184 00bc 8040      		sbci r24,0
 185 00be 9040      		sbci r25,0
 186 00c0 01F4      		brne 1b
 187 00c2 00C0      		rjmp .
 188 00c4 0000      		nop
 189               	.LVL15:
 190 00c6 0895      		ret
 191               	.LBE33:
 192               	.LBE32:
 193               		.cfi_endproc
 194               	.LFE25:
 196               	.global	MsetMinpm
 198               	MsetMinpm:
 199               	.LFB30:
 200               		.cfi_startproc
 201               	/* prologue: function */
 202               	/* frame size = 0 */
 203               	/* stack size = 0 */
 204               	.L__stack_usage = 0
 205 00c8 0895      		ret
 206               		.cfi_endproc
 207               	.LFE30:
 209               	.global	MsetHouram
 211               	MsetHouram:
 212               	.LFB36:
 213               		.cfi_startproc
 214               	/* prologue: function */
 215               	/* frame size = 0 */
 216               	/* stack size = 0 */
 217               	.L__stack_usage = 0
 218 00ca 0895      		ret
 219               		.cfi_endproc
 220               	.LFE36:
 222               	.global	MsetHourpm
 224               	MsetHourpm:
 225               	.LFB34:
 226               		.cfi_startproc
 227               	/* prologue: function */
 228               	/* frame size = 0 */
 229               	/* stack size = 0 */
 230               	.L__stack_usage = 0
 231 00cc 0895      		ret
 232               		.cfi_endproc
 233               	.LFE34:
 235               	.global	MsetMinam
 237               	MsetMinam:
 238               	.LFB32:
 239               		.cfi_startproc
 240               	/* prologue: function */
 241               	/* frame size = 0 */
 242               	/* stack size = 0 */
 243               	.L__stack_usage = 0
 244 00ce 0895      		ret
 245               		.cfi_endproc
 246               	.LFE32:
 248               	.global	findNextEntry
 250               	findNextEntry:
 251               	.LFB6:
   5:Menu.c        ****     if((index+2)>(m->nb_optn%16))return 0;
 252               		.loc 1 5 0
 253               		.cfi_startproc
 254               	.LVL16:
 255               	/* prologue: function */
 256               	/* frame size = 0 */
 257               	/* stack size = 0 */
 258               	.L__stack_usage = 0
   6:Menu.c        ****     return index+1;
 259               		.loc 1 6 0
 260 00d0 262F      		mov r18,r22
 261 00d2 30E0      		ldi r19,0
 262 00d4 2F5F      		subi r18,-1
 263 00d6 3F4F      		sbci r19,-1
 264 00d8 FC01      		movw r30,r24
 265 00da 8081      		ld r24,Z
 266               	.LVL17:
 267 00dc 8F70      		andi r24,lo8(15)
 268 00de 90E0      		ldi r25,0
 269 00e0 2817      		cp r18,r24
 270 00e2 3907      		cpc r19,r25
 271 00e4 04F4      		brge .L9
   7:Menu.c        **** }
 272               		.loc 1 7 0
 273 00e6 81E0      		ldi r24,lo8(1)
 274 00e8 860F      		add r24,r22
 275 00ea 0895      		ret
 276               	.L9:
   6:Menu.c        ****     return index+1;
 277               		.loc 1 6 0
 278 00ec 80E0      		ldi r24,0
   8:Menu.c        **** 
 279               		.loc 1 8 0
 280 00ee 0895      		ret
 281               		.cfi_endproc
 282               	.LFE6:
 284               	.global	getSubMenu
 286               	getSubMenu:
 287               	.LFB7:
  10:Menu.c        ****     if(m->sub[index].submenu==0)return 0;//if executed NULL, return blank menu (==exit setup)
 288               		.loc 1 10 0
 289               		.cfi_startproc
 290               	.LVL18:
 291               	/* prologue: function */
 292               	/* frame size = 0 */
 293               	/* stack size = 0 */
 294               	.L__stack_usage = 0
 295 00f0 9C01      		movw r18,r24
  11:Menu.c        ****     return m->sub[index].submenu;
 296               		.loc 1 11 0
 297 00f2 862F      		mov r24,r22
 298               	.LVL19:
 299 00f4 90E0      		ldi r25,0
 300 00f6 63E0      		ldi r22,lo8(3)
 301 00f8 70E0      		ldi r23,0
 302               	.LVL20:
 303 00fa 00D0      		rcall __mulhi3
 304               	.LVL21:
 305 00fc 820F      		add r24,r18
 306 00fe 931F      		adc r25,r19
  13:Menu.c        **** void EEPROM_write(uint8_t addr, uint8_t data){
 307               		.loc 1 13 0
 308 0100 FC01      		movw r30,r24
 309 0102 8481      		ldd r24,Z+4
 310 0104 9581      		ldd r25,Z+5
 311 0106 0895      		ret
 312               		.cfi_endproc
 313               	.LFE7:
 315               	.global	EEPROM_write
 317               	EEPROM_write:
 318               	.LFB8:
  14:Menu.c        ****     while(EECR & (1<<EEPE));
 319               		.loc 1 14 0
 320               		.cfi_startproc
 321               	/* prologue: function */
 322               	/* frame size = 0 */
 323               	/* stack size = 0 */
 324               	.L__stack_usage = 0
 325               	.LVL22:
 326               	.L13:
  15:Menu.c        ****     EECR = (0<<EEPM1)|(0<<EEPM0);
 327               		.loc 1 15 0 discriminator 1
 328 0108 E199      		sbic 0x1c,1
 329 010a 00C0      		rjmp .L13
  16:Menu.c        ****     EEAR = addr;
 330               		.loc 1 16 0
 331 010c 1CBA      		out 0x1c,__zero_reg__
  17:Menu.c        ****     EEDR = data;
 332               		.loc 1 17 0
 333 010e 90E0      		ldi r25,0
 334 0110 9FBB      		out 0x1e+1,r25
 335 0112 8EBB      		out 0x1e,r24
  18:Menu.c        ****     EECR |= (1<<EEMPE);
 336               		.loc 1 18 0
 337 0114 6DBB      		out 0x1d,r22
  19:Menu.c        ****     EECR |= (1<<EEPE);
 338               		.loc 1 19 0
 339 0116 E29A      		sbi 0x1c,2
  20:Menu.c        **** }
 340               		.loc 1 20 0
 341 0118 E19A      		sbi 0x1c,1
 342 011a 0895      		ret
 343               		.cfi_endproc
 344               	.LFE8:
 346               	.global	MsetMode
 348               	MsetMode:
 349               	.LFB11:
 160:Menu.c        ****     if(i<4){
 350               		.loc 1 160 0
 351               		.cfi_startproc
 352               	.LVL23:
 353               	/* prologue: function */
 354               	/* frame size = 0 */
 355               	/* stack size = 0 */
 356               	.L__stack_usage = 0
 161:Menu.c        ****         TCCR1B|=(1<<CS12)|(1<<CS10);
 357               		.loc 1 161 0
 358 011c 8430      		cpi r24,lo8(4)
 359 011e 00F4      		brsh .L15
 360               	.LVL24:
 361               	.LBB36:
 362               	.LBB37:
 162:Menu.c        ****         if(i==2)TCCR1B&=~(1<<CS10);
 363               		.loc 1 162 0
 364 0120 9EB5      		in r25,0x2e
 365 0122 9560      		ori r25,lo8(5)
 366 0124 9EBD      		out 0x2e,r25
 163:Menu.c        ****         mode=i;
 367               		.loc 1 163 0
 368 0126 8230      		cpi r24,lo8(2)
 369 0128 01F4      		brne .L17
 370 012a 9EB5      		in r25,0x2e
 371 012c 9E7F      		andi r25,lo8(-2)
 372 012e 9EBD      		out 0x2e,r25
 373               	.L17:
 164:Menu.c        ****         EEPROM_write(EE_MODE,i);
 374               		.loc 1 164 0
 375 0130 8093 0000 		sts mode,r24
 165:Menu.c        ****     }
 376               		.loc 1 165 0
 377 0134 682F      		mov r22,r24
 378 0136 84E0      		ldi r24,lo8(4)
 379               	.LVL25:
 380 0138 00C0      		rjmp EEPROM_write
 381               	.LVL26:
 382               	.L15:
 383 013a 0895      		ret
 384               	.LBE37:
 385               	.LBE36:
 386               		.cfi_endproc
 387               	.LFE11:
 389               	.global	MsetColorMode
 391               	MsetColorMode:
 392               	.LFB13:
 176:Menu.c        ****     if(i<7){
 393               		.loc 1 176 0
 394               		.cfi_startproc
 395               	.LVL27:
 396               	/* prologue: function */
 397               	/* frame size = 0 */
 398               	/* stack size = 0 */
 399               	.L__stack_usage = 0
 177:Menu.c        ****         colorMode=colorArray[i];//fixed
 400               		.loc 1 177 0
 401 013c 8730      		cpi r24,lo8(7)
 402 013e 00F4      		brsh .L19
 178:Menu.c        ****         EEPROM_write(EE_COLOR,colorArray[i]);
 403               		.loc 1 178 0
 404 0140 E82F      		mov r30,r24
 405 0142 F0E0      		ldi r31,0
 406 0144 E050      		subi r30,lo8(-(colorArray))
 407 0146 F040      		sbci r31,hi8(-(colorArray))
 408 0148 6081      		ld r22,Z
 409 014a 6093 0000 		sts colorMode,r22
 410 014e 00C0      		rjmp .L22
 411               	.L19:
 180:Menu.c        ****         colorMode=WHITE+128;
 412               		.loc 1 180 0
 413 0150 8730      		cpi r24,lo8(7)
 414 0152 01F4      		brne .L20
 415               	.LVL28:
 416               	.LBB40:
 417               	.LBB41:
 181:Menu.c        ****         EEPROM_write(EE_COLOR,128);
 418               		.loc 1 181 0
 419 0154 87E8      		ldi r24,lo8(-121)
 420               	.LVL29:
 421 0156 8093 0000 		sts colorMode,r24
 182:Menu.c        ****     }else if(i==8){//cycle all
 422               		.loc 1 182 0
 423 015a 60E8      		ldi r22,lo8(-128)
 424 015c 00C0      		rjmp .L22
 425               	.LVL30:
 426               	.L20:
 427               	.LBE41:
 428               	.LBE40:
 183:Menu.c        ****         colorMode=WHITE+64;
 429               		.loc 1 183 0
 430 015e 8830      		cpi r24,lo8(8)
 431 0160 01F4      		brne .L18
 184:Menu.c        ****         EEPROM_write(EE_COLOR,64);
 432               		.loc 1 184 0
 433 0162 87E4      		ldi r24,lo8(71)
 434               	.LVL31:
 435 0164 8093 0000 		sts colorMode,r24
 185:Menu.c        ****     }
 436               		.loc 1 185 0
 437 0168 60E4      		ldi r22,lo8(64)
 438               	.L22:
 439 016a 80E0      		ldi r24,0
 440 016c 00C0      		rjmp EEPROM_write
 441               	.LVL32:
 442               	.L18:
 443 016e 0895      		ret
 444               		.cfi_endproc
 445               	.LFE13:
 447               	.global	MsetNightMode
 449               	MsetNightMode:
 450               	.LFB15:
 199:Menu.c        ****     if(i<3)EEPROM_write(EE_NIGHTMODE,i);
 451               		.loc 1 199 0
 452               		.cfi_startproc
 453               	.LVL33:
 454               	/* prologue: function */
 455               	/* frame size = 0 */
 456               	/* stack size = 0 */
 457               	.L__stack_usage = 0
 200:Menu.c        **** }
 458               		.loc 1 200 0
 459 0170 8330      		cpi r24,lo8(3)
 460 0172 00F4      		brsh .L23
 200:Menu.c        **** }
 461               		.loc 1 200 0 is_stmt 0 discriminator 1
 462 0174 682F      		mov r22,r24
 463 0176 81E0      		ldi r24,lo8(1)
 464               	.LVL34:
 465 0178 00C0      		rjmp EEPROM_write
 466               	.LVL35:
 467               	.L23:
 468 017a 0895      		ret
 469               		.cfi_endproc
 470               	.LFE15:
 472               	.global	MsetNightOff
 474               	MsetNightOff:
 475               	.LFB17:
 206:Menu.c        ****     EEPROM_write(EE_OFFHOUR,12+i);
 476               		.loc 1 206 0 is_stmt 1
 477               		.cfi_startproc
 478               	.LVL36:
 479               	/* prologue: function */
 480               	/* frame size = 0 */
 481               	/* stack size = 0 */
 482               	.L__stack_usage = 0
 207:Menu.c        **** }
 483               		.loc 1 207 0
 484 017c 6CE0      		ldi r22,lo8(12)
 485 017e 680F      		add r22,r24
 486 0180 83E0      		ldi r24,lo8(3)
 487               	.LVL37:
 488 0182 00C0      		rjmp EEPROM_write
 489               	.LVL38:
 490               		.cfi_endproc
 491               	.LFE17:
 493               	.global	MsetNightOn
 495               	MsetNightOn:
 496               	.LFB18:
 209:Menu.c        ****     EEPROM_write(EE_ONHOUR,1+i);
 497               		.loc 1 209 0
 498               		.cfi_startproc
 499               	.LVL39:
 500               	/* prologue: function */
 501               	/* frame size = 0 */
 502               	/* stack size = 0 */
 503               	.L__stack_usage = 0
 210:Menu.c        **** }
 504               		.loc 1 210 0
 505 0184 61E0      		ldi r22,lo8(1)
 506 0186 680F      		add r22,r24
 507 0188 82E0      		ldi r24,lo8(2)
 508               	.LVL40:
 509 018a 00C0      		rjmp EEPROM_write
 510               	.LVL41:
 511               		.cfi_endproc
 512               	.LFE18:
 514               	.global	Mreset
 516               	Mreset:
 517               	.LFB24:
 222:Menu.c        ****     if(i<1){
 518               		.loc 1 222 0
 519               		.cfi_startproc
 520               	.LVL42:
 521               	/* prologue: function */
 522               	/* frame size = 0 */
 523               	/* stack size = 0 */
 524               	.L__stack_usage = 0
 223:Menu.c        ****         MsetMode(1);
 525               		.loc 1 223 0
 526 018c 8111      		cpse r24,__zero_reg__
 527 018e 00C0      		rjmp .L27
 528               	.LVL43:
 529               	.LBB48:
 530               	.LBB49:
 531               	.LBB50:
 532               	.LBB51:
 533               	.LBB52:
 162:Menu.c        ****         if(i==2)TCCR1B&=~(1<<CS10);
 534               		.loc 1 162 0
 535 0190 8EB5      		in r24,0x2e
 536               	.LVL44:
 537 0192 8560      		ori r24,lo8(5)
 538 0194 8EBD      		out 0x2e,r24
 164:Menu.c        ****         EEPROM_write(EE_MODE,i);
 539               		.loc 1 164 0
 540 0196 81E0      		ldi r24,lo8(1)
 541 0198 8093 0000 		sts mode,r24
 165:Menu.c        ****     }
 542               		.loc 1 165 0
 543 019c 61E0      		ldi r22,lo8(1)
 544 019e 84E0      		ldi r24,lo8(4)
 545 01a0 00D0      		rcall EEPROM_write
 546               	.LVL45:
 547               	.LBE52:
 548               	.LBE51:
 549               	.LBE50:
 225:Menu.c        ****         EEPROM_write(EE_NIGHTMODE,1);
 550               		.loc 1 225 0
 551 01a2 80E0      		ldi r24,0
 552 01a4 00D0      		rcall MsetColorMode
 553               	.LVL46:
 226:Menu.c        ****         EEPROM_write(EE_OFFHOUR,12+22);
 554               		.loc 1 226 0
 555 01a6 61E0      		ldi r22,lo8(1)
 556 01a8 81E0      		ldi r24,lo8(1)
 557 01aa 00D0      		rcall EEPROM_write
 558               	.LVL47:
 227:Menu.c        ****         EEPROM_write(EE_ONHOUR,1+8);
 559               		.loc 1 227 0
 560 01ac 62E2      		ldi r22,lo8(34)
 561 01ae 83E0      		ldi r24,lo8(3)
 562 01b0 00D0      		rcall EEPROM_write
 563               	.LVL48:
 228:Menu.c        ****         TCCR1B|=(1<<CS12)|(1<<CS10);
 564               		.loc 1 228 0
 565 01b2 69E0      		ldi r22,lo8(9)
 566 01b4 82E0      		ldi r24,lo8(2)
 567 01b6 00D0      		rcall EEPROM_write
 568               	.LVL49:
 229:Menu.c        ****     }
 569               		.loc 1 229 0
 570 01b8 8EB5      		in r24,0x2e
 571 01ba 8560      		ori r24,lo8(5)
 572 01bc 8EBD      		out 0x2e,r24
 573               	.LVL50:
 574               	.L27:
 575 01be 0895      		ret
 576               	.LBE49:
 577               	.LBE48:
 578               		.cfi_endproc
 579               	.LFE24:
 581               	.global	EEPROM_read
 583               	EEPROM_read:
 584               	.LFB9:
  22:Menu.c        ****     while(EECR & (1<<EEPE));
 585               		.loc 1 22 0
 586               		.cfi_startproc
 587               	/* prologue: function */
 588               	/* frame size = 0 */
 589               	/* stack size = 0 */
 590               	.L__stack_usage = 0
 591               	.LVL51:
 592               	.L30:
  23:Menu.c        ****     EEAR = addr;
 593               		.loc 1 23 0 discriminator 1
 594 01c0 E199      		sbic 0x1c,1
 595 01c2 00C0      		rjmp .L30
  24:Menu.c        ****     EECR |= (1<<EERE);
 596               		.loc 1 24 0
 597 01c4 90E0      		ldi r25,0
 598 01c6 9FBB      		out 0x1e+1,r25
 599 01c8 8EBB      		out 0x1e,r24
  25:Menu.c        ****     return EEDR;
 600               		.loc 1 25 0
 601 01ca E09A      		sbi 0x1c,0
  26:Menu.c        **** }
 602               		.loc 1 26 0
 603 01cc 8DB3      		in r24,0x1d
 604               	.LVL52:
  27:Menu.c        **** 
 605               		.loc 1 27 0
 606 01ce 0895      		ret
 607               		.cfi_endproc
 608               	.LFE9:
 610               	.global	Minit
 612               	Minit:
 613               	.LFB10:
  29:Menu.c        ****     colorMode=EEPROM_read(EE_COLOR);
 614               		.loc 1 29 0
 615               		.cfi_startproc
 616               	/* prologue: function */
 617               	/* frame size = 0 */
 618               	/* stack size = 0 */
 619               	.L__stack_usage = 0
  30:Menu.c        ****     MsetMode(EEPROM_read(EE_MODE));
 620               		.loc 1 30 0
 621 01d0 80E0      		ldi r24,0
 622 01d2 00D0      		rcall EEPROM_read
 623               	.LVL53:
 624 01d4 8093 0000 		sts colorMode,r24
  31:Menu.c        **** }
 625               		.loc 1 31 0
 626 01d8 84E0      		ldi r24,lo8(4)
 627 01da 00D0      		rcall EEPROM_read
 628               	.LVL54:
 629 01dc 00C0      		rjmp MsetMode
 630               	.LVL55:
 631               		.cfi_endproc
 632               	.LFE10:
 634               	.global	getMode
 636               	getMode:
 637               	.LFB12:
 168:Menu.c        ****     if(mode==2){
 638               		.loc 1 168 0
 639               		.cfi_startproc
 640               	/* prologue: function */
 641               	/* frame size = 0 */
 642               	/* stack size = 0 */
 643               	.L__stack_usage = 0
 169:Menu.c        ****         mode=1;
 644               		.loc 1 169 0
 645 01de 8091 0000 		lds r24,mode
 646 01e2 8230      		cpi r24,lo8(2)
 647 01e4 01F4      		brne .L34
 170:Menu.c        ****     }else if(mode==1){
 648               		.loc 1 170 0
 649 01e6 81E0      		ldi r24,lo8(1)
 650 01e8 00C0      		rjmp .L36
 651               	.L34:
 171:Menu.c        ****         mode=2;
 652               		.loc 1 171 0
 653 01ea 8130      		cpi r24,lo8(1)
 654 01ec 01F4      		brne .L35
 172:Menu.c        ****     }
 655               		.loc 1 172 0
 656 01ee 82E0      		ldi r24,lo8(2)
 657               	.L36:
 658 01f0 8093 0000 		sts mode,r24
 659               	.L35:
 175:Menu.c        **** void MsetColorMode(uint8_t i){
 660               		.loc 1 175 0
 661 01f4 8091 0000 		lds r24,mode
 662 01f8 0895      		ret
 663               		.cfi_endproc
 664               	.LFE12:
 666               	.global	getColor
 668               	getColor:
 669               	.LFB14:
 188:Menu.c        ****     if(colorMode>127){//cycle single
 670               		.loc 1 188 0
 671               		.cfi_startproc
 672               	/* prologue: function */
 673               	/* frame size = 0 */
 674               	/* stack size = 0 */
 675               	.L__stack_usage = 0
 189:Menu.c        ****         if(colorMode>134)colorMode=128;
 676               		.loc 1 189 0
 677 01fa 8091 0000 		lds r24,colorMode
 678 01fe 87FF      		sbrs r24,7
 679 0200 00C0      		rjmp .L38
 190:Menu.c        ****         colorMode++;
 680               		.loc 1 190 0
 681 0202 8738      		cpi r24,lo8(-121)
 682 0204 00F0      		brlo .L39
 190:Menu.c        ****         colorMode++;
 683               		.loc 1 190 0 is_stmt 0 discriminator 1
 684 0206 80E8      		ldi r24,lo8(-128)
 685 0208 8093 0000 		sts colorMode,r24
 686               	.L39:
 191:Menu.c        ****         return colorArray[colorMode-128];
 687               		.loc 1 191 0 is_stmt 1
 688 020c E091 0000 		lds r30,colorMode
 689 0210 EF5F      		subi r30,lo8(-(1))
 690 0212 E093 0000 		sts colorMode,r30
 192:Menu.c        ****     }else if(colorMode>63){//cycle all
 691               		.loc 1 192 0
 692 0216 F0E0      		ldi r31,0
 693 0218 E050      		subi r30,lo8(-(colorArray-128))
 694 021a F040      		sbci r31,hi8(-(colorArray-128))
 695 021c 8081      		ld r24,Z
 696 021e 0895      		ret
 697               	.L38:
 193:Menu.c        ****         return RED;
 698               		.loc 1 193 0
 699 0220 8034      		cpi r24,lo8(64)
 700 0222 00F0      		brlo .L40
 194:Menu.c        ****     }else{//fixed
 701               		.loc 1 194 0
 702 0224 84E0      		ldi r24,lo8(4)
 703               	.L40:
 198:Menu.c        **** void MsetNightMode(uint8_t i){
 704               		.loc 1 198 0
 705 0226 0895      		ret
 706               		.cfi_endproc
 707               	.LFE14:
 709               	.global	isInAllowedTime
 711               	isInAllowedTime:
 712               	.LFB16:
 202:Menu.c        ****     if(EEPROM_read(EE_NIGHTMODE))return (h>=EEPROM_read(EE_ONHOUR) && h<=EEPROM_read(EE_OFFHOUR));
 713               		.loc 1 202 0
 714               		.cfi_startproc
 715               	.LVL56:
 716 0228 CF93      		push r28
 717               	.LCFI0:
 718               		.cfi_def_cfa_offset 3
 719               		.cfi_offset 28, -2
 720               	/* prologue: function */
 721               	/* frame size = 0 */
 722               	/* stack size = 1 */
 723               	.L__stack_usage = 1
 724 022a C82F      		mov r28,r24
 203:Menu.c        ****     return 1;
 725               		.loc 1 203 0
 726 022c 81E0      		ldi r24,lo8(1)
 727               	.LVL57:
 728 022e 00D0      		rcall EEPROM_read
 729               	.LVL58:
 730 0230 8823      		tst r24
 731 0232 01F0      		breq .L46
 203:Menu.c        ****     return 1;
 732               		.loc 1 203 0 is_stmt 0 discriminator 1
 733 0234 82E0      		ldi r24,lo8(2)
 734 0236 00D0      		rcall EEPROM_read
 735               	.LVL59:
 736 0238 C817      		cp r28,r24
 737 023a 00F0      		brlo .L47
 203:Menu.c        ****     return 1;
 738               		.loc 1 203 0 discriminator 2
 739 023c 83E0      		ldi r24,lo8(3)
 740 023e 00D0      		rcall EEPROM_read
 741               	.LVL60:
 742 0240 91E0      		ldi r25,lo8(1)
 743 0242 8C17      		cp r24,r28
 744 0244 00F4      		brsh .L45
 745 0246 90E0      		ldi r25,0
 746               	.L45:
 747 0248 892F      		mov r24,r25
 748 024a 00C0      		rjmp .L43
 749               	.L47:
 203:Menu.c        ****     return 1;
 750               		.loc 1 203 0
 751 024c 80E0      		ldi r24,0
 752 024e 00C0      		rjmp .L43
 753               	.L46:
 204:Menu.c        **** }
 754               		.loc 1 204 0 is_stmt 1
 755 0250 81E0      		ldi r24,lo8(1)
 756               	.L43:
 757               	/* epilogue start */
 205:Menu.c        **** void MsetNightOff(uint8_t i){
 758               		.loc 1 205 0
 759 0252 CF91      		pop r28
 760               	.LVL61:
 761 0254 0895      		ret
 762               		.cfi_endproc
 763               	.LFE16:
 765               	.global	colorMode
 766               		.section .bss
 769               	colorMode:
 770 0000 00        		.zero	1
 771               	.global	mode
 772               		.data
 775               	mode:
 776 0000 01        		.byte	1
 777               	.global	M1rainbow
 778               		.section	.rodata
 781               	M1rainbow:
 782 0000 03        		.byte	3
 783 0001 0000      		.word	gs(MsetRainbow)
 784 0003 07        		.byte	7
 785 0004 0000      		.word	0
 786 0006 08        		.byte	8
 787 0007 0000      		.word	0
 788 0009 0F        		.byte	15
 789 000a 0000      		.word	M0main
 790               	.global	M1reset
 793               	M1reset:
 794 000c 02        		.byte	2
 795 000d 0000      		.word	gs(Mreset)
 796 000f 12        		.byte	18
 797 0010 0000      		.word	0
 798 0012 0F        		.byte	15
 799 0013 0000      		.word	M0main
 800               	.global	M1eventMode
 803               	M1eventMode:
 804 0015 03        		.byte	3
 805 0016 0000      		.word	gs(MsetEventMode)
 806 0018 07        		.byte	7
 807 0019 0000      		.word	0
 808 001b 08        		.byte	8
 809 001c 0000      		.word	0
 810 001e 0F        		.byte	15
 811 001f 0000      		.word	M0main
 812               	.global	M2setminpm
 815               	M2setminpm:
 816 0021 04        		.byte	4
 817 0022 0000      		.word	gs(MsetMinpm)
 818 0024 05        		.byte	5
 819 0025 0000      		.word	0
 820 0027 0B        		.byte	11
 821 0028 0000      		.word	0
 822 002a 01        		.byte	1
 823 002b 0000      		.word	0
 824 002d 0F        		.byte	15
 825 002e 0000      		.word	M1setTime
 826               	.global	M2setminam
 829               	M2setminam:
 830 0030 04        		.byte	4
 831 0031 0000      		.word	gs(MsetMinam)
 832 0033 05        		.byte	5
 833 0034 0000      		.word	0
 834 0036 0B        		.byte	11
 835 0037 0000      		.word	0
 836 0039 01        		.byte	1
 837 003a 0000      		.word	0
 838 003c 0F        		.byte	15
 839 003d 0000      		.word	M1setTime
 840               	.global	M2sethourpm
 843               	M2sethourpm:
 844 003f 0D        		.byte	13
 845 0040 0000      		.word	gs(MsetHourpm)
 846 0042 07        		.byte	7
 847 0043 0000      		.word	0
 848 0045 08        		.byte	8
 849 0046 0000      		.word	0
 850 0048 0A        		.byte	10
 851 0049 0000      		.word	0
 852 004b 0E        		.byte	14
 853 004c 0000      		.word	0
 854 004e 00        		.byte	0
 855 004f 0000      		.word	0
 856 0051 04        		.byte	4
 857 0052 0000      		.word	0
 858 0054 11        		.byte	17
 859 0055 0000      		.word	0
 860 0057 02        		.byte	2
 861 0058 0000      		.word	0
 862 005a 0C        		.byte	12
 863 005b 0000      		.word	0
 864 005d 06        		.byte	6
 865 005e 0000      		.word	0
 866 0060 10        		.byte	16
 867 0061 0000      		.word	0
 868 0063 03        		.byte	3
 869 0064 0000      		.word	0
 870 0066 0F        		.byte	15
 871 0067 0000      		.word	M1setTime
 872               	.global	M2sethouram
 875               	M2sethouram:
 876 0069 0D        		.byte	13
 877 006a 0000      		.word	gs(MsetHouram)
 878 006c 07        		.byte	7
 879 006d 0000      		.word	0
 880 006f 08        		.byte	8
 881 0070 0000      		.word	0
 882 0072 0A        		.byte	10
 883 0073 0000      		.word	0
 884 0075 0E        		.byte	14
 885 0076 0000      		.word	0
 886 0078 00        		.byte	0
 887 0079 0000      		.word	0
 888 007b 04        		.byte	4
 889 007c 0000      		.word	0
 890 007e 11        		.byte	17
 891 007f 0000      		.word	0
 892 0081 02        		.byte	2
 893 0082 0000      		.word	0
 894 0084 0C        		.byte	12
 895 0085 0000      		.word	0
 896 0087 06        		.byte	6
 897 0088 0000      		.word	0
 898 008a 10        		.byte	16
 899 008b 0000      		.word	0
 900 008d 0D        		.byte	13
 901 008e 0000      		.word	0
 902 0090 0F        		.byte	15
 903 0091 0000      		.word	M1setTime
 904               	.global	M1setTime
 907               	M1setTime:
 908 0093 05        		.byte	5
 909 0094 0000      		.word	0
 910 0096 07        		.byte	7
 911 0097 0000      		.word	M2sethouram
 912 0099 08        		.byte	8
 913 009a 0000      		.word	M2sethourpm
 914 009c 0A        		.byte	10
 915 009d 0000      		.word	M2setminam
 916 009f 0E        		.byte	14
 917 00a0 0000      		.word	M2setminpm
 918 00a2 0F        		.byte	15
 919 00a3 0000      		.word	M0main
 920               	.global	M3onhour
 923               	M3onhour:
 924 00a5 5C        		.byte	92
 925 00a6 0000      		.word	gs(MsetNightOn)
 926 00a8 07        		.byte	7
 927 00a9 0000      		.word	0
 928 00ab 08        		.byte	8
 929 00ac 0000      		.word	0
 930 00ae 0A        		.byte	10
 931 00af 0000      		.word	0
 932 00b1 0E        		.byte	14
 933 00b2 0000      		.word	0
 934 00b4 00        		.byte	0
 935 00b5 0000      		.word	0
 936 00b7 04        		.byte	4
 937 00b8 0000      		.word	0
 938 00ba 11        		.byte	17
 939 00bb 0000      		.word	0
 940 00bd 02        		.byte	2
 941 00be 0000      		.word	0
 942 00c0 0C        		.byte	12
 943 00c1 0000      		.word	0
 944 00c3 06        		.byte	6
 945 00c4 0000      		.word	0
 946 00c6 10        		.byte	16
 947 00c7 0000      		.word	0
 948 00c9 0F        		.byte	15
 949 00ca 0000      		.word	M1nightmode
 950               	.global	M2offhour
 953               	M2offhour:
 954 00cc 4C        		.byte	76
 955 00cd 0000      		.word	gs(MsetNightOff)
 956 00cf 07        		.byte	7
 957 00d0 0000      		.word	M3onhour
 958 00d2 08        		.byte	8
 959 00d3 0000      		.word	M3onhour
 960 00d5 0A        		.byte	10
 961 00d6 0000      		.word	M3onhour
 962 00d8 0E        		.byte	14
 963 00d9 0000      		.word	M3onhour
 964 00db 00        		.byte	0
 965 00dc 0000      		.word	M3onhour
 966 00de 04        		.byte	4
 967 00df 0000      		.word	M3onhour
 968 00e1 11        		.byte	17
 969 00e2 0000      		.word	M3onhour
 970 00e4 02        		.byte	2
 971 00e5 0000      		.word	M3onhour
 972 00e7 0C        		.byte	12
 973 00e8 0000      		.word	M3onhour
 974 00ea 06        		.byte	6
 975 00eb 0000      		.word	M3onhour
 976 00ed 10        		.byte	16
 977 00ee 0000      		.word	M3onhour
 978 00f0 0F        		.byte	15
 979 00f1 0000      		.word	M1nightmode
 980               	.global	M1nightmode
 983               	M1nightmode:
 984 00f3 34        		.byte	52
 985 00f4 0000      		.word	gs(MsetNightMode)
 986 00f6 07        		.byte	7
 987 00f7 0000      		.word	0
 988 00f9 08        		.byte	8
 989 00fa 0000      		.word	M2offhour
 990 00fc 0A        		.byte	10
 991 00fd 0000      		.word	M2offhour
 992 00ff 0F        		.byte	15
 993 0100 0000      		.word	M0main
 994               	.global	M1cmode
 997               	M1cmode:
 998 0102 2A        		.byte	42
 999 0103 0000      		.word	gs(MsetColorMode)
 1000 0105 07        		.byte	7
 1001 0106 0000      		.word	0
 1002 0108 08        		.byte	8
 1003 0109 0000      		.word	0
 1004 010b 0A        		.byte	10
 1005 010c 0000      		.word	0
 1006 010e 0E        		.byte	14
 1007 010f 0000      		.word	0
 1008 0111 00        		.byte	0
 1009 0112 0000      		.word	0
 1010 0114 04        		.byte	4
 1011 0115 0000      		.word	0
 1012 0117 11        		.byte	17
 1013 0118 0000      		.word	0
 1014 011a 02        		.byte	2
 1015 011b 0000      		.word	0
 1016 011d 0C        		.byte	12
 1017 011e 0000      		.word	0
 1018 0120 0F        		.byte	15
 1019 0121 0000      		.word	M0main
 1020               	.global	M1mode
 1023               	M1mode:
 1024 0123 15        		.byte	21
 1025 0124 0000      		.word	gs(MsetMode)
 1026 0126 07        		.byte	7
 1027 0127 0000      		.word	0
 1028 0129 08        		.byte	8
 1029 012a 0000      		.word	0
 1030 012c 0A        		.byte	10
 1031 012d 0000      		.word	0
 1032 012f 0E        		.byte	14
 1033 0130 0000      		.word	0
 1034 0132 0F        		.byte	15
 1035 0133 0000      		.word	M0main
 1036               	.global	M0main
 1039               	M0main:
 1040 0135 08        		.byte	8
 1041 0136 0000      		.word	0
 1042 0138 07        		.byte	7
 1043 0139 0000      		.word	M1mode
 1044 013b 08        		.byte	8
 1045 013c 0000      		.word	M1cmode
 1046 013e 0A        		.byte	10
 1047 013f 0000      		.word	M1nightmode
 1048 0141 0E        		.byte	14
 1049 0142 0000      		.word	M1setTime
 1050 0144 00        		.byte	0
 1051 0145 0000      		.word	M1eventMode
 1052 0147 04        		.byte	4
 1053 0148 0000      		.word	M1reset
 1054 014a 11        		.byte	17
 1055 014b 0000      		.word	M1rainbow
 1056 014d 0F        		.byte	15
 1057 014e 0000      		.word	0
 1058               		.comm	USI_I2C_Master_State,1,1
 1059               		.comm	currentTime,5,1
 1062               	colorArray:
 1063 0150 07        		.byte	7
 1064 0151 03        		.byte	3
 1065 0152 01        		.byte	1
 1066 0153 05        		.byte	5
 1067 0154 04        		.byte	4
 1068 0155 06        		.byte	6
 1069 0156 02        		.byte	2
 1070               		.text
 1071               	.Letext0:
 1072               		.file 3 "/usr/lib/avr/include/stdint.h"
 1073               		.file 4 "RTC.h"
 1074               		.file 5 "Menu.h"
 1075               		.file 6 "defines.h"
 1076               		.file 7 "Led.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Menu.c
     /tmp/cccDkuIO.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cccDkuIO.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cccDkuIO.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cccDkuIO.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cccDkuIO.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cccDkuIO.s:12     .text:0000000000000000 MsetEventMode
     /tmp/cccDkuIO.s:28     .text:0000000000000002 MsetRainbow
     /tmp/cccDkuIO.s:198    .text:00000000000000c8 MsetMinpm
     /tmp/cccDkuIO.s:211    .text:00000000000000ca MsetHouram
     /tmp/cccDkuIO.s:224    .text:00000000000000cc MsetHourpm
     /tmp/cccDkuIO.s:237    .text:00000000000000ce MsetMinam
     /tmp/cccDkuIO.s:250    .text:00000000000000d0 findNextEntry
     /tmp/cccDkuIO.s:286    .text:00000000000000f0 getSubMenu
     /tmp/cccDkuIO.s:317    .text:0000000000000108 EEPROM_write
     /tmp/cccDkuIO.s:348    .text:000000000000011c MsetMode
     /tmp/cccDkuIO.s:775    .data:0000000000000000 mode
     /tmp/cccDkuIO.s:391    .text:000000000000013c MsetColorMode
     /tmp/cccDkuIO.s:1062   .rodata:0000000000000150 colorArray
     /tmp/cccDkuIO.s:769    .bss:0000000000000000 colorMode
     /tmp/cccDkuIO.s:449    .text:0000000000000170 MsetNightMode
     /tmp/cccDkuIO.s:474    .text:000000000000017c MsetNightOff
     /tmp/cccDkuIO.s:495    .text:0000000000000184 MsetNightOn
     /tmp/cccDkuIO.s:516    .text:000000000000018c Mreset
     /tmp/cccDkuIO.s:583    .text:00000000000001c0 EEPROM_read
     /tmp/cccDkuIO.s:612    .text:00000000000001d0 Minit
     /tmp/cccDkuIO.s:636    .text:00000000000001de getMode
     /tmp/cccDkuIO.s:668    .text:00000000000001fa getColor
     /tmp/cccDkuIO.s:711    .text:0000000000000228 isInAllowedTime
     /tmp/cccDkuIO.s:781    .rodata:0000000000000000 M1rainbow
     /tmp/cccDkuIO.s:1039   .rodata:0000000000000135 M0main
     /tmp/cccDkuIO.s:793    .rodata:000000000000000c M1reset
     /tmp/cccDkuIO.s:803    .rodata:0000000000000015 M1eventMode
     /tmp/cccDkuIO.s:815    .rodata:0000000000000021 M2setminpm
     /tmp/cccDkuIO.s:907    .rodata:0000000000000093 M1setTime
     /tmp/cccDkuIO.s:829    .rodata:0000000000000030 M2setminam
     /tmp/cccDkuIO.s:843    .rodata:000000000000003f M2sethourpm
     /tmp/cccDkuIO.s:875    .rodata:0000000000000069 M2sethouram
     /tmp/cccDkuIO.s:923    .rodata:00000000000000a5 M3onhour
     /tmp/cccDkuIO.s:983    .rodata:00000000000000f3 M1nightmode
     /tmp/cccDkuIO.s:953    .rodata:00000000000000cc M2offhour
     /tmp/cccDkuIO.s:997    .rodata:0000000000000102 M1cmode
     /tmp/cccDkuIO.s:1023   .rodata:0000000000000123 M1mode
                            *COM*:0000000000000001 USI_I2C_Master_State
                            *COM*:0000000000000005 currentTime

UNDEFINED SYMBOLS
sendRawData
__mulhi3
__do_copy_data
__do_clear_bss
