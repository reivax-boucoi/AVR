   1               		.file	"Menu.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	MsetHouram
  12               	MsetHouram:
  13               	.LFB19:
  14               		.file 1 "Menu.c"
   1:Menu.c        **** #include "Menu.h"
   2:Menu.c        **** 
   3:Menu.c        **** uint8_t mode=1;//0: hour only, 1-2: hour+temp, 3: temp only, >=4:Rainbow !
   4:Menu.c        **** uint8_t colorMode=0;
   5:Menu.c        **** 
   6:Menu.c        **** uint8_t findNextEntry(Menu* m,uint8_t index){
   7:Menu.c        ****     if((index+2)>(m->nb_optn%16))return 0;
   8:Menu.c        ****     return index+1;
   9:Menu.c        **** }
  10:Menu.c        **** 
  11:Menu.c        **** Menu* getSubMenu(Menu* m,uint8_t index){
  12:Menu.c        ****     if(m->sub[index].submenu==0)return 0;//if executed NULL, return blank menu (==exit setup)
  13:Menu.c        ****     return m->sub[index].submenu;
  14:Menu.c        **** }
  15:Menu.c        **** void EEPROM_write(uint8_t addr, uint8_t data){
  16:Menu.c        ****     while(EECR & (1<<EEPE));
  17:Menu.c        ****     EECR = (0<<EEPM1)|(0<<EEPM0);
  18:Menu.c        ****     EEAR = addr;
  19:Menu.c        ****     EEDR = data;
  20:Menu.c        ****     EECR |= (1<<EEMPE);
  21:Menu.c        ****     EECR |= (1<<EEPE);
  22:Menu.c        **** }
  23:Menu.c        **** uint8_t EEPROM_read(uint8_t addr){
  24:Menu.c        ****     while(EECR & (1<<EEPE));
  25:Menu.c        ****     EEAR = addr;
  26:Menu.c        ****     EECR |= (1<<EERE);
  27:Menu.c        ****     return EEDR;
  28:Menu.c        **** }
  29:Menu.c        **** 
  30:Menu.c        **** void Minit(void){
  31:Menu.c        ****     colorMode=EEPROM_read(EE_COLOR);
  32:Menu.c        ****     mode=EEPROM_read(EE_MODE);
  33:Menu.c        ****     MsetMode(EEPROM_read(EE_MODE));
  34:Menu.c        **** }
  35:Menu.c        **** const Menu M0main={8,0,{//WHITE
  36:Menu.c        ****     {7,&M1mode},
  37:Menu.c        ****     {8,&M1cmode},
  38:Menu.c        ****     {10,&M1nightmode},
  39:Menu.c        ****     {14,&M1setTime},
  40:Menu.c        ****     {0,&M1eventMode},
  41:Menu.c        ****     {4,&M1reset},
  42:Menu.c        ****     {17,&M1rainbow},
  43:Menu.c        ****     {HEURE,0}//exit      
  44:Menu.c        **** }};
  45:Menu.c        **** const Menu M1mode={5+16,MsetMode,{//CYAN
  46:Menu.c        ****     {7,0},//Hour only
  47:Menu.c        ****     {8,0},//Hour + temp (slow)
  48:Menu.c        ****     {10,0},//Hour + temp (fast)
  49:Menu.c        ****     {14,0},//temp only
  50:Menu.c        ****     {HEURE,&M0main}//return    
  51:Menu.c        **** }};
  52:Menu.c        **** const Menu M1cmode={10+32,MsetColorMode,{//BLUE
  53:Menu.c        ****     {7,0},//fixed WHITE 1
  54:Menu.c        ****     {8,0},//fixed CYAN 2
  55:Menu.c        ****     {10,0},//fixed BLUE 3
  56:Menu.c        ****     {14,0},//fixed MAGENTA 4
  57:Menu.c        ****     {0,0},//fixed RED 5
  58:Menu.c        ****     {4,0},//fixed YELLOW 6
  59:Menu.c        ****     {17,0},//fixed GREEN 7
  60:Menu.c        ****     {2,0},// cycle single 8
  61:Menu.c        ****     {12,0},// cycle all 9
  62:Menu.c        ****     {HEURE,&M0main}//return    
  63:Menu.c        **** }};
  64:Menu.c        **** const Menu M1nightmode={4+48,MsetNightMode,{//MAGENTA
  65:Menu.c        ****     {7,0},//none
  66:Menu.c        ****     {8,&M2offhour},//Half brightness
  67:Menu.c        ****     {10,&M2offhour},//Off completely
  68:Menu.c        ****     {HEURE,&M0main}//return
  69:Menu.c        **** }};
  70:Menu.c        **** const Menu M2offhour={12+64,MsetNightOff,{//RED
  71:Menu.c        ****     {7,&M3onhour},//heures
  72:Menu.c        ****     {8,&M3onhour},
  73:Menu.c        ****     {10,&M3onhour},
  74:Menu.c        ****     {14,&M3onhour},
  75:Menu.c        ****     {0,&M3onhour},
  76:Menu.c        ****     {4,&M3onhour},
  77:Menu.c        ****     {17,&M3onhour},
  78:Menu.c        ****     {2,&M3onhour},
  79:Menu.c        ****     {12,&M3onhour},
  80:Menu.c        ****     {6,&M3onhour},
  81:Menu.c        ****     {16,&M3onhour},
  82:Menu.c        ****     {HEURE,&M1nightmode}//return
  83:Menu.c        **** }};
  84:Menu.c        **** const Menu M3onhour={12+80,MsetNightOn,{//YELLOW
  85:Menu.c        ****     {7,0},//heures
  86:Menu.c        ****     {8,0},
  87:Menu.c        ****     {10,0},
  88:Menu.c        ****     {14,0},
  89:Menu.c        ****     {0,0},
  90:Menu.c        ****     {4,0},
  91:Menu.c        ****     {17,0},
  92:Menu.c        ****     {2,0},
  93:Menu.c        ****     {12,0},
  94:Menu.c        ****     {6,0},
  95:Menu.c        ****     {16,0},
  96:Menu.c        ****     {HEURE,&M1nightmode}//return
  97:Menu.c        **** }};
  98:Menu.c        **** const Menu M1setTime={5+96,0,{//GREEN
  99:Menu.c        ****     {7,&M2sethouram},//hour am
 100:Menu.c        ****     {8,&M2sethourpm},//hour pm
 101:Menu.c        ****     {10,&M2setminam},//min am
 102:Menu.c        ****     {14,&M2setminpm},//min pm
 103:Menu.c        ****     {HEURE,&M0main}//return
 104:Menu.c        **** }};
 105:Menu.c        **** const Menu M2sethouram={13+64,MsetHouram,{//RED
 106:Menu.c        ****     {7,0},//heure
 107:Menu.c        ****     {8,0},
 108:Menu.c        ****     {10,0},
 109:Menu.c        ****     {14,0},
 110:Menu.c        ****     {0,0},
 111:Menu.c        ****     {4,0},
 112:Menu.c        ****     {17,0},
 113:Menu.c        ****     {2,0},
 114:Menu.c        ****     {12,0},
 115:Menu.c        ****     {6,0},
 116:Menu.c        ****     {16,0},
 117:Menu.c        ****     {MIDI,0},//midi
 118:Menu.c        ****     {HEURE,&M1setTime}//return
 119:Menu.c        **** }};
 120:Menu.c        **** const Menu M2sethourpm={12+64,MsetHourpm,{//RED
 121:Menu.c        ****     {7,0},//heure
 122:Menu.c        ****     {8,0},
 123:Menu.c        ****     {10,0},
 124:Menu.c        ****     {14,0},
 125:Menu.c        ****     {0,0},
 126:Menu.c        ****     {4,0},
 127:Menu.c        ****     {17,0},
 128:Menu.c        ****     {2,0},
 129:Menu.c        ****     {12,0},
 130:Menu.c        ****     {6,0},
 131:Menu.c        ****     {16,0},
 132:Menu.c        ****     {HEURE,&M1setTime}//return
 133:Menu.c        **** }};
 134:Menu.c        **** const Menu M2setminam={4+32,MsetMinam,{//BLUE
 135:Menu.c        ****     {DIX,0},//dix
 136:Menu.c        ****     {VINGT,0},//vingt
 137:Menu.c        ****     {ETDEMIE,0},//1/2
 138:Menu.c        ****     {HEURE,&M1setTime}//return
 139:Menu.c        **** }};
 140:Menu.c        **** const Menu M2setminpm={4+32,MsetMinpm,{//BLUE
 141:Menu.c        ****     {DIX,0},//dix
 142:Menu.c        ****     {VINGT,0},//vingt
 143:Menu.c        ****     {ETDEMIE,0},//1/2
 144:Menu.c        ****     {HEURE,&M1setTime}//return
 145:Menu.c        **** }};
 146:Menu.c        **** const Menu M1eventMode={3+16,MsetEventMode,{//CYAN
 147:Menu.c        ****     {7,0},//Event on
 148:Menu.c        ****     {8,0},//Event off
 149:Menu.c        ****     {HEURE,&M0main}//return
 150:Menu.c        **** }};
 151:Menu.c        **** const Menu M1reset={2+64,Mreset,{//RED
 152:Menu.c        ****     {ILEST,0},//yes
 153:Menu.c        ****     {HEURE,&M0main}//return
 154:Menu.c        **** }};
 155:Menu.c        **** const Menu M1rainbow={3+48,MsetRainbow,{//MAGENTA
 156:Menu.c        ****     {7,0},//Rainbow on
 157:Menu.c        ****     {8,0},//Rainbow off
 158:Menu.c        ****     {HEURE,&M0main}//return
 159:Menu.c        **** }};
 160:Menu.c        **** 
 161:Menu.c        **** void MsetMode(uint8_t i){
 162:Menu.c        ****    if(i<4){
 163:Menu.c        ****         TCCR1B|=(1<<CS12)|(1<<CS10);
 164:Menu.c        ****         if(i==2)TCCR1B&=~(1<<CS10);
 165:Menu.c        ****         mode=i;
 166:Menu.c        ****         EEPROM_write(EE_MODE,i);
 167:Menu.c        ****     }
 168:Menu.c        **** }
 169:Menu.c        **** uint8_t getMode(void){
 170:Menu.c        ****     if(mode==2){
 171:Menu.c        ****         mode=1;
 172:Menu.c        ****     }else if(mode==1){
 173:Menu.c        ****         mode=2;
 174:Menu.c        ****     }
 175:Menu.c        ****     if(colorMode>63 && colorMode<128){
 176:Menu.c        ****         colorMode=((colorMode-64+1)%7)+64;
 177:Menu.c        ****     }
 178:Menu.c        ****     return mode;
 179:Menu.c        **** }
 180:Menu.c        **** void MsetColorMode(uint8_t i){
 181:Menu.c        ****     if(i<7){
 182:Menu.c        ****         colorMode=colorArray[i];//fixed
 183:Menu.c        ****         EEPROM_write(EE_COLOR,colorArray[i]);
 184:Menu.c        ****     }else if(i==7){//cycle single
 185:Menu.c        ****         colorMode=WHITE+128;
 186:Menu.c        ****         EEPROM_write(EE_COLOR,128);
 187:Menu.c        ****     }else if(i==8){//cycle all
 188:Menu.c        ****         colorMode=WHITE+64;
 189:Menu.c        ****         EEPROM_write(EE_COLOR,64);
 190:Menu.c        ****     }
 191:Menu.c        **** }
 192:Menu.c        **** uint8_t getColor(void){
 193:Menu.c        ****     if(colorMode>127){//cycle single
 194:Menu.c        ****         if(colorMode>134)colorMode=128;
 195:Menu.c        ****         colorMode++;
 196:Menu.c        ****         return colorArray[colorMode-129];
 197:Menu.c        ****     }else if(colorMode>63){//cycle all
 198:Menu.c        ****         return colorArray[(colorMode-64)%7];
 199:Menu.c        ****     }else{//fixed
 200:Menu.c        ****         return colorMode;
 201:Menu.c        ****     }
 202:Menu.c        **** }
 203:Menu.c        **** void MsetNightMode(uint8_t i){
 204:Menu.c        ****     if(i<3)EEPROM_write(EE_NIGHTMODE,i);
 205:Menu.c        **** }
 206:Menu.c        **** uint8_t isInAllowedTime(uint8_t h){
 207:Menu.c        ****     if(EEPROM_read(EE_NIGHTMODE))return (h>=EEPROM_read(EE_ONHOUR) && h<=EEPROM_read(EE_OFFHOUR));
 208:Menu.c        ****     return 1;
 209:Menu.c        **** }
 210:Menu.c        **** void MsetNightOff(uint8_t i){
 211:Menu.c        ****     EEPROM_write(EE_OFFHOUR,12+i);
 212:Menu.c        **** }
 213:Menu.c        **** void MsetNightOn(uint8_t i){
 214:Menu.c        ****     EEPROM_write(EE_ONHOUR,1+i);
 215:Menu.c        **** }
 216:Menu.c        **** void MsetHouram(uint8_t i){
  15               		.loc 1 216 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 217:Menu.c        ****    if(i<12)RTC_setHour(i+1);
  22               		.loc 1 217 0
  23 0000 8C30      		cpi r24,lo8(12)
  24 0002 00F4      		brsh .L1
  25               		.loc 1 217 0 is_stmt 0 discriminator 1
  26 0004 8F5F      		subi r24,lo8(-(1))
  27               	.LVL1:
  28 0006 00C0      		rjmp RTC_setHour
  29               	.LVL2:
  30               	.L1:
  31 0008 0895      		ret
  32               		.cfi_endproc
  33               	.LFE19:
  35               	.global	MsetHourpm
  37               	MsetHourpm:
  38               	.LFB20:
 218:Menu.c        **** }
 219:Menu.c        **** void MsetHourpm(uint8_t i){
  39               		.loc 1 219 0 is_stmt 1
  40               		.cfi_startproc
  41               	.LVL3:
  42               	/* prologue: function */
  43               	/* frame size = 0 */
  44               	/* stack size = 0 */
  45               	.L__stack_usage = 0
 220:Menu.c        ****    if(i<11)RTC_setHour(i+13);    
  46               		.loc 1 220 0
  47 000a 8B30      		cpi r24,lo8(11)
  48 000c 00F4      		brsh .L4
  49               		.loc 1 220 0 is_stmt 0 discriminator 1
  50 000e 835F      		subi r24,lo8(-(13))
  51               	.LVL4:
  52 0010 00C0      		rjmp RTC_setHour
  53               	.LVL5:
  54               	.L4:
  55 0012 0895      		ret
  56               		.cfi_endproc
  57               	.LFE20:
  59               	.global	MsetRainbow
  61               	MsetRainbow:
  62               	.LFB25:
 221:Menu.c        **** }
 222:Menu.c        **** void MsetMinam(uint8_t i){
 223:Menu.c        ****     if(i<3)RTC_setMin((i+1)*10);
 224:Menu.c        ****     }
 225:Menu.c        **** void MsetMinpm(uint8_t i){
 226:Menu.c        ****     if(i<3)RTC_setMin(60-(i+1)*10);
 227:Menu.c        **** }
 228:Menu.c        **** void MsetEventMode(uint8_t i){
 229:Menu.c        ****     if(i<2)EEPROM_write(EE_EVENT,1-i);//1 for active
 230:Menu.c        **** }
 231:Menu.c        **** void Mreset(uint8_t i){
 232:Menu.c        ****     if(i<1){
 233:Menu.c        ****         MsetMode(1);
 234:Menu.c        ****         MsetColorMode(0);
 235:Menu.c        ****         EEPROM_write(EE_NIGHTMODE,1);
 236:Menu.c        ****         EEPROM_write(EE_OFFHOUR,12+10);
 237:Menu.c        ****         EEPROM_write(EE_ONHOUR,1+8);
 238:Menu.c        ****         TCCR1B|=(1<<CS12)|(1<<CS10);
 239:Menu.c        ****     }
 240:Menu.c        **** }
 241:Menu.c        **** 
 242:Menu.c        **** void MsetRainbow(uint8_t i){
  63               		.loc 1 242 0 is_stmt 1
  64               		.cfi_startproc
  65               	.LVL6:
  66               	/* prologue: function */
  67               	/* frame size = 0 */
  68               	/* stack size = 0 */
  69               	.L__stack_usage = 0
 243:Menu.c        ****     if(i<2)mode=4;
  70               		.loc 1 243 0
  71 0014 8230      		cpi r24,lo8(2)
  72 0016 00F4      		brsh .L7
  73               		.loc 1 243 0 is_stmt 0 discriminator 1
  74 0018 84E0      		ldi r24,lo8(4)
  75               	.LVL7:
  76 001a 8093 0000 		sts mode,r24
  77               	.L7:
 244:Menu.c        ****   //  cli();
 245:Menu.c        ****     sendRawData(0b11111100001111111111);//white
  78               		.loc 1 245 0 is_stmt 1
  79 001e 6FEF      		ldi r22,lo8(-1)
  80 0020 73EC      		ldi r23,lo8(-61)
  81 0022 8FE0      		ldi r24,lo8(15)
  82 0024 90E0      		ldi r25,0
  83 0026 00D0      		rcall sendRawData
  84               	.LVL8:
  85               	.LBB20:
  86               	.LBB21:
  87               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  88               		.loc 2 187 0
  89 0028 2FEF      		ldi r18,lo8(1599999)
  90 002a 89E6      		ldi r24,hi8(1599999)
  91 002c 98E1      		ldi r25,hlo8(1599999)
  92 002e 2150      	1:	subi r18,1
  93 0030 8040      		sbci r24,0
  94 0032 9040      		sbci r25,0
  95 0034 01F4      		brne 1b
  96 0036 00C0      		rjmp .
  97 0038 0000      		nop
  98               	.LVL9:
  99               	.LBE21:
 100               	.LBE20:
 246:Menu.c        ****     _delay_ms(500);
 247:Menu.c        ****     sendRawData(0b11000000001111111111);//green
 101               		.loc 1 247 0
 102 003a 6FEF      		ldi r22,lo8(-1)
 103 003c 73E0      		ldi r23,lo8(3)
 104 003e 8CE0      		ldi r24,lo8(12)
 105 0040 90E0      		ldi r25,0
 106 0042 00D0      		rcall sendRawData
 107               	.LVL10:
 108               	.LBB22:
 109               	.LBB23:
 110               		.loc 2 187 0
 111 0044 2FEF      		ldi r18,lo8(1599999)
 112 0046 89E6      		ldi r24,hi8(1599999)
 113 0048 98E1      		ldi r25,hlo8(1599999)
 114 004a 2150      	1:	subi r18,1
 115 004c 8040      		sbci r24,0
 116 004e 9040      		sbci r25,0
 117 0050 01F4      		brne 1b
 118 0052 00C0      		rjmp .
 119 0054 0000      		nop
 120               	.LVL11:
 121               	.LBE23:
 122               	.LBE22:
 248:Menu.c        ****     _delay_ms(500);
 249:Menu.c        ****     sendRawData(0b00001100001111111111);//red
 123               		.loc 1 249 0
 124 0056 6FEF      		ldi r22,lo8(-1)
 125 0058 73EC      		ldi r23,lo8(-61)
 126 005a 80E0      		ldi r24,0
 127 005c 90E0      		ldi r25,0
 128 005e 00D0      		rcall sendRawData
 129               	.LVL12:
 130               	.LBB24:
 131               	.LBB25:
 132               		.loc 2 187 0
 133 0060 2FEF      		ldi r18,lo8(1599999)
 134 0062 89E6      		ldi r24,hi8(1599999)
 135 0064 98E1      		ldi r25,hlo8(1599999)
 136 0066 2150      	1:	subi r18,1
 137 0068 8040      		sbci r24,0
 138 006a 9040      		sbci r25,0
 139 006c 01F4      		brne 1b
 140 006e 00C0      		rjmp .
 141 0070 0000      		nop
 142               	.LVL13:
 143               	.LBE25:
 144               	.LBE24:
 250:Menu.c        ****     _delay_ms(500);
 251:Menu.c        ****     sendRawData(0b00110000001111111111);//blue
 145               		.loc 1 251 0
 146 0072 6FEF      		ldi r22,lo8(-1)
 147 0074 73E0      		ldi r23,lo8(3)
 148 0076 83E0      		ldi r24,lo8(3)
 149 0078 90E0      		ldi r25,0
 150 007a 00D0      		rcall sendRawData
 151               	.LVL14:
 152               	.LBB26:
 153               	.LBB27:
 154               		.loc 2 187 0
 155 007c 2FEF      		ldi r18,lo8(1599999)
 156 007e 89E6      		ldi r24,hi8(1599999)
 157 0080 98E1      		ldi r25,hlo8(1599999)
 158 0082 2150      	1:	subi r18,1
 159 0084 8040      		sbci r24,0
 160 0086 9040      		sbci r25,0
 161 0088 01F4      		brne 1b
 162 008a 00C0      		rjmp .
 163 008c 0000      		nop
 164               	.LVL15:
 165               	.LBE27:
 166               	.LBE26:
 252:Menu.c        ****     _delay_ms(500);
 253:Menu.c        ****     sendRawData(0b11110000001111111111);//cyan
 167               		.loc 1 253 0
 168 008e 6FEF      		ldi r22,lo8(-1)
 169 0090 73E0      		ldi r23,lo8(3)
 170 0092 8FE0      		ldi r24,lo8(15)
 171 0094 90E0      		ldi r25,0
 172 0096 00D0      		rcall sendRawData
 173               	.LVL16:
 174               	.LBB28:
 175               	.LBB29:
 176               		.loc 2 187 0
 177 0098 2FEF      		ldi r18,lo8(1599999)
 178 009a 89E6      		ldi r24,hi8(1599999)
 179 009c 98E1      		ldi r25,hlo8(1599999)
 180 009e 2150      	1:	subi r18,1
 181 00a0 8040      		sbci r24,0
 182 00a2 9040      		sbci r25,0
 183 00a4 01F4      		brne 1b
 184 00a6 00C0      		rjmp .
 185 00a8 0000      		nop
 186               	.LVL17:
 187               	.LBE29:
 188               	.LBE28:
 254:Menu.c        ****     _delay_ms(500);
 255:Menu.c        ****     sendRawData(0b00111100001111111111);//magenta
 189               		.loc 1 255 0
 190 00aa 6FEF      		ldi r22,lo8(-1)
 191 00ac 73EC      		ldi r23,lo8(-61)
 192 00ae 83E0      		ldi r24,lo8(3)
 193 00b0 90E0      		ldi r25,0
 194 00b2 00D0      		rcall sendRawData
 195               	.LVL18:
 196               	.LBB30:
 197               	.LBB31:
 198               		.loc 2 187 0
 199 00b4 2FEF      		ldi r18,lo8(1599999)
 200 00b6 89E6      		ldi r24,hi8(1599999)
 201 00b8 98E1      		ldi r25,hlo8(1599999)
 202 00ba 2150      	1:	subi r18,1
 203 00bc 8040      		sbci r24,0
 204 00be 9040      		sbci r25,0
 205 00c0 01F4      		brne 1b
 206 00c2 00C0      		rjmp .
 207 00c4 0000      		nop
 208               	.LVL19:
 209               	.LBE31:
 210               	.LBE30:
 256:Menu.c        ****     _delay_ms(500);
 257:Menu.c        ****     sendRawData(0b11001100001111111111);//yellow
 211               		.loc 1 257 0
 212 00c6 6FEF      		ldi r22,lo8(-1)
 213 00c8 73EC      		ldi r23,lo8(-61)
 214 00ca 8CE0      		ldi r24,lo8(12)
 215 00cc 90E0      		ldi r25,0
 216 00ce 00D0      		rcall sendRawData
 217               	.LVL20:
 218               	.LBB32:
 219               	.LBB33:
 220               		.loc 2 187 0
 221 00d0 2FEF      		ldi r18,lo8(1599999)
 222 00d2 89E6      		ldi r24,hi8(1599999)
 223 00d4 98E1      		ldi r25,hlo8(1599999)
 224 00d6 2150      	1:	subi r18,1
 225 00d8 8040      		sbci r24,0
 226 00da 9040      		sbci r25,0
 227 00dc 01F4      		brne 1b
 228 00de 00C0      		rjmp .
 229 00e0 0000      		nop
 230               	.LVL21:
 231 00e2 0895      		ret
 232               	.LBE33:
 233               	.LBE32:
 234               		.cfi_endproc
 235               	.LFE25:
 237               	.global	MsetMinam
 239               	MsetMinam:
 240               	.LFB21:
 222:Menu.c        ****     if(i<3)RTC_setMin((i+1)*10);
 241               		.loc 1 222 0
 242               		.cfi_startproc
 243               	.LVL22:
 244               	/* prologue: function */
 245               	/* frame size = 0 */
 246               	/* stack size = 0 */
 247               	.L__stack_usage = 0
 223:Menu.c        ****     }
 248               		.loc 1 223 0
 249 00e4 8330      		cpi r24,lo8(3)
 250 00e6 00F4      		brsh .L8
 251               	.LVL23:
 252               	.LBB36:
 253               	.LBB37:
 254 00e8 8F5F      		subi r24,lo8(-(1))
 255               	.LVL24:
 256 00ea 6AE0      		ldi r22,lo8(10)
 257 00ec 00D0      		rcall __mulqi3
 258               	.LVL25:
 259 00ee 00C0      		rjmp RTC_setMin
 260               	.LVL26:
 261               	.L8:
 262 00f0 0895      		ret
 263               	.LBE37:
 264               	.LBE36:
 265               		.cfi_endproc
 266               	.LFE21:
 268               	.global	MsetMinpm
 270               	MsetMinpm:
 271               	.LFB22:
 225:Menu.c        ****     if(i<3)RTC_setMin(60-(i+1)*10);
 272               		.loc 1 225 0
 273               		.cfi_startproc
 274               	.LVL27:
 275               	/* prologue: function */
 276               	/* frame size = 0 */
 277               	/* stack size = 0 */
 278               	.L__stack_usage = 0
 226:Menu.c        **** }
 279               		.loc 1 226 0
 280 00f2 8330      		cpi r24,lo8(3)
 281 00f4 00F4      		brsh .L10
 282               	.LVL28:
 283               	.LBB40:
 284               	.LBB41:
 285 00f6 8F5F      		subi r24,lo8(-(1))
 286               	.LVL29:
 287 00f8 66EF      		ldi r22,lo8(-10)
 288 00fa 00D0      		rcall __mulqi3
 289               	.LVL30:
 290 00fc 845C      		subi r24,lo8(-(60))
 291 00fe 00C0      		rjmp RTC_setMin
 292               	.LVL31:
 293               	.L10:
 294 0100 0895      		ret
 295               	.LBE41:
 296               	.LBE40:
 297               		.cfi_endproc
 298               	.LFE22:
 300               	.global	findNextEntry
 302               	findNextEntry:
 303               	.LFB6:
   6:Menu.c        ****     if((index+2)>(m->nb_optn%16))return 0;
 304               		.loc 1 6 0
 305               		.cfi_startproc
 306               	.LVL32:
 307               	/* prologue: function */
 308               	/* frame size = 0 */
 309               	/* stack size = 0 */
 310               	.L__stack_usage = 0
   7:Menu.c        ****     return index+1;
 311               		.loc 1 7 0
 312 0102 262F      		mov r18,r22
 313 0104 30E0      		ldi r19,0
 314 0106 2F5F      		subi r18,-1
 315 0108 3F4F      		sbci r19,-1
 316 010a FC01      		movw r30,r24
 317 010c 8081      		ld r24,Z
 318               	.LVL33:
 319 010e 8F70      		andi r24,lo8(15)
 320 0110 90E0      		ldi r25,0
 321 0112 2817      		cp r18,r24
 322 0114 3907      		cpc r19,r25
 323 0116 04F4      		brge .L14
   8:Menu.c        **** }
 324               		.loc 1 8 0
 325 0118 81E0      		ldi r24,lo8(1)
 326 011a 860F      		add r24,r22
 327 011c 0895      		ret
 328               	.L14:
   7:Menu.c        ****     return index+1;
 329               		.loc 1 7 0
 330 011e 80E0      		ldi r24,0
   9:Menu.c        **** 
 331               		.loc 1 9 0
 332 0120 0895      		ret
 333               		.cfi_endproc
 334               	.LFE6:
 336               	.global	getSubMenu
 338               	getSubMenu:
 339               	.LFB7:
  11:Menu.c        ****     if(m->sub[index].submenu==0)return 0;//if executed NULL, return blank menu (==exit setup)
 340               		.loc 1 11 0
 341               		.cfi_startproc
 342               	.LVL34:
 343               	/* prologue: function */
 344               	/* frame size = 0 */
 345               	/* stack size = 0 */
 346               	.L__stack_usage = 0
 347 0122 9C01      		movw r18,r24
  12:Menu.c        ****     return m->sub[index].submenu;
 348               		.loc 1 12 0
 349 0124 862F      		mov r24,r22
 350               	.LVL35:
 351 0126 90E0      		ldi r25,0
 352 0128 63E0      		ldi r22,lo8(3)
 353 012a 70E0      		ldi r23,0
 354               	.LVL36:
 355 012c 00D0      		rcall __mulhi3
 356               	.LVL37:
 357 012e 820F      		add r24,r18
 358 0130 931F      		adc r25,r19
  14:Menu.c        **** void EEPROM_write(uint8_t addr, uint8_t data){
 359               		.loc 1 14 0
 360 0132 FC01      		movw r30,r24
 361 0134 8481      		ldd r24,Z+4
 362 0136 9581      		ldd r25,Z+5
 363 0138 0895      		ret
 364               		.cfi_endproc
 365               	.LFE7:
 367               	.global	EEPROM_write
 369               	EEPROM_write:
 370               	.LFB8:
  15:Menu.c        ****     while(EECR & (1<<EEPE));
 371               		.loc 1 15 0
 372               		.cfi_startproc
 373               	/* prologue: function */
 374               	/* frame size = 0 */
 375               	/* stack size = 0 */
 376               	.L__stack_usage = 0
 377               	.LVL38:
 378               	.L17:
  16:Menu.c        ****     EECR = (0<<EEPM1)|(0<<EEPM0);
 379               		.loc 1 16 0 discriminator 1
 380 013a E199      		sbic 0x1c,1
 381 013c 00C0      		rjmp .L17
  17:Menu.c        ****     EEAR = addr;
 382               		.loc 1 17 0
 383 013e 1CBA      		out 0x1c,__zero_reg__
  18:Menu.c        ****     EEDR = data;
 384               		.loc 1 18 0
 385 0140 90E0      		ldi r25,0
 386 0142 9FBB      		out 0x1e+1,r25
 387 0144 8EBB      		out 0x1e,r24
  19:Menu.c        ****     EECR |= (1<<EEMPE);
 388               		.loc 1 19 0
 389 0146 6DBB      		out 0x1d,r22
  20:Menu.c        ****     EECR |= (1<<EEPE);
 390               		.loc 1 20 0
 391 0148 E29A      		sbi 0x1c,2
  21:Menu.c        **** }
 392               		.loc 1 21 0
 393 014a E19A      		sbi 0x1c,1
 394 014c 0895      		ret
 395               		.cfi_endproc
 396               	.LFE8:
 398               	.global	MsetMode
 400               	MsetMode:
 401               	.LFB11:
 161:Menu.c        ****    if(i<4){
 402               		.loc 1 161 0
 403               		.cfi_startproc
 404               	.LVL39:
 405               	/* prologue: function */
 406               	/* frame size = 0 */
 407               	/* stack size = 0 */
 408               	.L__stack_usage = 0
 162:Menu.c        ****         TCCR1B|=(1<<CS12)|(1<<CS10);
 409               		.loc 1 162 0
 410 014e 8430      		cpi r24,lo8(4)
 411 0150 00F4      		brsh .L19
 412               	.LVL40:
 413               	.LBB44:
 414               	.LBB45:
 163:Menu.c        ****         if(i==2)TCCR1B&=~(1<<CS10);
 415               		.loc 1 163 0
 416 0152 9EB5      		in r25,0x2e
 417 0154 9560      		ori r25,lo8(5)
 418 0156 9EBD      		out 0x2e,r25
 164:Menu.c        ****         mode=i;
 419               		.loc 1 164 0
 420 0158 8230      		cpi r24,lo8(2)
 421 015a 01F4      		brne .L21
 422 015c 9EB5      		in r25,0x2e
 423 015e 9E7F      		andi r25,lo8(-2)
 424 0160 9EBD      		out 0x2e,r25
 425               	.L21:
 165:Menu.c        ****         EEPROM_write(EE_MODE,i);
 426               		.loc 1 165 0
 427 0162 8093 0000 		sts mode,r24
 166:Menu.c        ****     }
 428               		.loc 1 166 0
 429 0166 682F      		mov r22,r24
 430 0168 84E0      		ldi r24,lo8(4)
 431               	.LVL41:
 432 016a 00C0      		rjmp EEPROM_write
 433               	.LVL42:
 434               	.L19:
 435 016c 0895      		ret
 436               	.LBE45:
 437               	.LBE44:
 438               		.cfi_endproc
 439               	.LFE11:
 441               	.global	MsetColorMode
 443               	MsetColorMode:
 444               	.LFB13:
 180:Menu.c        ****     if(i<7){
 445               		.loc 1 180 0
 446               		.cfi_startproc
 447               	.LVL43:
 448               	/* prologue: function */
 449               	/* frame size = 0 */
 450               	/* stack size = 0 */
 451               	.L__stack_usage = 0
 181:Menu.c        ****         colorMode=colorArray[i];//fixed
 452               		.loc 1 181 0
 453 016e 8730      		cpi r24,lo8(7)
 454 0170 00F4      		brsh .L23
 182:Menu.c        ****         EEPROM_write(EE_COLOR,colorArray[i]);
 455               		.loc 1 182 0
 456 0172 E82F      		mov r30,r24
 457 0174 F0E0      		ldi r31,0
 458 0176 E050      		subi r30,lo8(-(colorArray))
 459 0178 F040      		sbci r31,hi8(-(colorArray))
 460 017a 6081      		ld r22,Z
 461 017c 6093 0000 		sts colorMode,r22
 462 0180 00C0      		rjmp .L26
 463               	.L23:
 184:Menu.c        ****         colorMode=WHITE+128;
 464               		.loc 1 184 0
 465 0182 8730      		cpi r24,lo8(7)
 466 0184 01F4      		brne .L24
 467               	.LVL44:
 468               	.LBB48:
 469               	.LBB49:
 185:Menu.c        ****         EEPROM_write(EE_COLOR,128);
 470               		.loc 1 185 0
 471 0186 87E8      		ldi r24,lo8(-121)
 472               	.LVL45:
 473 0188 8093 0000 		sts colorMode,r24
 186:Menu.c        ****     }else if(i==8){//cycle all
 474               		.loc 1 186 0
 475 018c 60E8      		ldi r22,lo8(-128)
 476 018e 00C0      		rjmp .L26
 477               	.LVL46:
 478               	.L24:
 479               	.LBE49:
 480               	.LBE48:
 187:Menu.c        ****         colorMode=WHITE+64;
 481               		.loc 1 187 0
 482 0190 8830      		cpi r24,lo8(8)
 483 0192 01F4      		brne .L22
 188:Menu.c        ****         EEPROM_write(EE_COLOR,64);
 484               		.loc 1 188 0
 485 0194 87E4      		ldi r24,lo8(71)
 486               	.LVL47:
 487 0196 8093 0000 		sts colorMode,r24
 189:Menu.c        ****     }
 488               		.loc 1 189 0
 489 019a 60E4      		ldi r22,lo8(64)
 490               	.L26:
 491 019c 80E0      		ldi r24,0
 492 019e 00C0      		rjmp EEPROM_write
 493               	.LVL48:
 494               	.L22:
 495 01a0 0895      		ret
 496               		.cfi_endproc
 497               	.LFE13:
 499               	.global	MsetNightMode
 501               	MsetNightMode:
 502               	.LFB15:
 203:Menu.c        ****     if(i<3)EEPROM_write(EE_NIGHTMODE,i);
 503               		.loc 1 203 0
 504               		.cfi_startproc
 505               	.LVL49:
 506               	/* prologue: function */
 507               	/* frame size = 0 */
 508               	/* stack size = 0 */
 509               	.L__stack_usage = 0
 204:Menu.c        **** }
 510               		.loc 1 204 0
 511 01a2 8330      		cpi r24,lo8(3)
 512 01a4 00F4      		brsh .L27
 204:Menu.c        **** }
 513               		.loc 1 204 0 is_stmt 0 discriminator 1
 514 01a6 682F      		mov r22,r24
 515 01a8 81E0      		ldi r24,lo8(1)
 516               	.LVL50:
 517 01aa 00C0      		rjmp EEPROM_write
 518               	.LVL51:
 519               	.L27:
 520 01ac 0895      		ret
 521               		.cfi_endproc
 522               	.LFE15:
 524               	.global	MsetNightOff
 526               	MsetNightOff:
 527               	.LFB17:
 210:Menu.c        ****     EEPROM_write(EE_OFFHOUR,12+i);
 528               		.loc 1 210 0 is_stmt 1
 529               		.cfi_startproc
 530               	.LVL52:
 531               	/* prologue: function */
 532               	/* frame size = 0 */
 533               	/* stack size = 0 */
 534               	.L__stack_usage = 0
 211:Menu.c        **** }
 535               		.loc 1 211 0
 536 01ae 6CE0      		ldi r22,lo8(12)
 537 01b0 680F      		add r22,r24
 538 01b2 83E0      		ldi r24,lo8(3)
 539               	.LVL53:
 540 01b4 00C0      		rjmp EEPROM_write
 541               	.LVL54:
 542               		.cfi_endproc
 543               	.LFE17:
 545               	.global	MsetNightOn
 547               	MsetNightOn:
 548               	.LFB18:
 213:Menu.c        ****     EEPROM_write(EE_ONHOUR,1+i);
 549               		.loc 1 213 0
 550               		.cfi_startproc
 551               	.LVL55:
 552               	/* prologue: function */
 553               	/* frame size = 0 */
 554               	/* stack size = 0 */
 555               	.L__stack_usage = 0
 214:Menu.c        **** }
 556               		.loc 1 214 0
 557 01b6 61E0      		ldi r22,lo8(1)
 558 01b8 680F      		add r22,r24
 559 01ba 82E0      		ldi r24,lo8(2)
 560               	.LVL56:
 561 01bc 00C0      		rjmp EEPROM_write
 562               	.LVL57:
 563               		.cfi_endproc
 564               	.LFE18:
 566               	.global	MsetEventMode
 568               	MsetEventMode:
 569               	.LFB23:
 228:Menu.c        ****     if(i<2)EEPROM_write(EE_EVENT,1-i);//1 for active
 570               		.loc 1 228 0
 571               		.cfi_startproc
 572               	.LVL58:
 573               	/* prologue: function */
 574               	/* frame size = 0 */
 575               	/* stack size = 0 */
 576               	.L__stack_usage = 0
 229:Menu.c        **** }
 577               		.loc 1 229 0
 578 01be 8230      		cpi r24,lo8(2)
 579 01c0 00F4      		brsh .L31
 580               	.LVL59:
 581               	.LBB52:
 582               	.LBB53:
 583 01c2 61E0      		ldi r22,lo8(1)
 584 01c4 681B      		sub r22,r24
 585 01c6 85E0      		ldi r24,lo8(5)
 586               	.LVL60:
 587 01c8 00C0      		rjmp EEPROM_write
 588               	.LVL61:
 589               	.L31:
 590 01ca 0895      		ret
 591               	.LBE53:
 592               	.LBE52:
 593               		.cfi_endproc
 594               	.LFE23:
 596               	.global	Mreset
 598               	Mreset:
 599               	.LFB24:
 231:Menu.c        ****     if(i<1){
 600               		.loc 1 231 0
 601               		.cfi_startproc
 602               	.LVL62:
 603               	/* prologue: function */
 604               	/* frame size = 0 */
 605               	/* stack size = 0 */
 606               	.L__stack_usage = 0
 232:Menu.c        ****         MsetMode(1);
 607               		.loc 1 232 0
 608 01cc 8111      		cpse r24,__zero_reg__
 609 01ce 00C0      		rjmp .L33
 610               	.LVL63:
 611               	.LBB60:
 612               	.LBB61:
 613               	.LBB62:
 614               	.LBB63:
 615               	.LBB64:
 163:Menu.c        ****         if(i==2)TCCR1B&=~(1<<CS10);
 616               		.loc 1 163 0
 617 01d0 8EB5      		in r24,0x2e
 618               	.LVL64:
 619 01d2 8560      		ori r24,lo8(5)
 620 01d4 8EBD      		out 0x2e,r24
 165:Menu.c        ****         EEPROM_write(EE_MODE,i);
 621               		.loc 1 165 0
 622 01d6 81E0      		ldi r24,lo8(1)
 623 01d8 8093 0000 		sts mode,r24
 166:Menu.c        ****     }
 624               		.loc 1 166 0
 625 01dc 61E0      		ldi r22,lo8(1)
 626 01de 84E0      		ldi r24,lo8(4)
 627 01e0 00D0      		rcall EEPROM_write
 628               	.LVL65:
 629               	.LBE64:
 630               	.LBE63:
 631               	.LBE62:
 234:Menu.c        ****         EEPROM_write(EE_NIGHTMODE,1);
 632               		.loc 1 234 0
 633 01e2 80E0      		ldi r24,0
 634 01e4 00D0      		rcall MsetColorMode
 635               	.LVL66:
 235:Menu.c        ****         EEPROM_write(EE_OFFHOUR,12+10);
 636               		.loc 1 235 0
 637 01e6 61E0      		ldi r22,lo8(1)
 638 01e8 81E0      		ldi r24,lo8(1)
 639 01ea 00D0      		rcall EEPROM_write
 640               	.LVL67:
 236:Menu.c        ****         EEPROM_write(EE_ONHOUR,1+8);
 641               		.loc 1 236 0
 642 01ec 66E1      		ldi r22,lo8(22)
 643 01ee 83E0      		ldi r24,lo8(3)
 644 01f0 00D0      		rcall EEPROM_write
 645               	.LVL68:
 237:Menu.c        ****         TCCR1B|=(1<<CS12)|(1<<CS10);
 646               		.loc 1 237 0
 647 01f2 69E0      		ldi r22,lo8(9)
 648 01f4 82E0      		ldi r24,lo8(2)
 649 01f6 00D0      		rcall EEPROM_write
 650               	.LVL69:
 238:Menu.c        ****     }
 651               		.loc 1 238 0
 652 01f8 8EB5      		in r24,0x2e
 653 01fa 8560      		ori r24,lo8(5)
 654 01fc 8EBD      		out 0x2e,r24
 655               	.LVL70:
 656               	.L33:
 657 01fe 0895      		ret
 658               	.LBE61:
 659               	.LBE60:
 660               		.cfi_endproc
 661               	.LFE24:
 663               	.global	EEPROM_read
 665               	EEPROM_read:
 666               	.LFB9:
  23:Menu.c        ****     while(EECR & (1<<EEPE));
 667               		.loc 1 23 0
 668               		.cfi_startproc
 669               	/* prologue: function */
 670               	/* frame size = 0 */
 671               	/* stack size = 0 */
 672               	.L__stack_usage = 0
 673               	.LVL71:
 674               	.L36:
  24:Menu.c        ****     EEAR = addr;
 675               		.loc 1 24 0 discriminator 1
 676 0200 E199      		sbic 0x1c,1
 677 0202 00C0      		rjmp .L36
  25:Menu.c        ****     EECR |= (1<<EERE);
 678               		.loc 1 25 0
 679 0204 90E0      		ldi r25,0
 680 0206 9FBB      		out 0x1e+1,r25
 681 0208 8EBB      		out 0x1e,r24
  26:Menu.c        ****     return EEDR;
 682               		.loc 1 26 0
 683 020a E09A      		sbi 0x1c,0
  27:Menu.c        **** }
 684               		.loc 1 27 0
 685 020c 8DB3      		in r24,0x1d
 686               	.LVL72:
  28:Menu.c        **** 
 687               		.loc 1 28 0
 688 020e 0895      		ret
 689               		.cfi_endproc
 690               	.LFE9:
 692               	.global	Minit
 694               	Minit:
 695               	.LFB10:
  30:Menu.c        ****     colorMode=EEPROM_read(EE_COLOR);
 696               		.loc 1 30 0
 697               		.cfi_startproc
 698               	/* prologue: function */
 699               	/* frame size = 0 */
 700               	/* stack size = 0 */
 701               	.L__stack_usage = 0
  31:Menu.c        ****     mode=EEPROM_read(EE_MODE);
 702               		.loc 1 31 0
 703 0210 80E0      		ldi r24,0
 704 0212 00D0      		rcall EEPROM_read
 705               	.LVL73:
 706 0214 8093 0000 		sts colorMode,r24
  32:Menu.c        ****     MsetMode(EEPROM_read(EE_MODE));
 707               		.loc 1 32 0
 708 0218 84E0      		ldi r24,lo8(4)
 709 021a 00D0      		rcall EEPROM_read
 710               	.LVL74:
 711 021c 8093 0000 		sts mode,r24
  33:Menu.c        **** }
 712               		.loc 1 33 0
 713 0220 84E0      		ldi r24,lo8(4)
 714 0222 00D0      		rcall EEPROM_read
 715               	.LVL75:
 716 0224 00C0      		rjmp MsetMode
 717               	.LVL76:
 718               		.cfi_endproc
 719               	.LFE10:
 721               	.global	getMode
 723               	getMode:
 724               	.LFB12:
 169:Menu.c        ****     if(mode==2){
 725               		.loc 1 169 0
 726               		.cfi_startproc
 727               	/* prologue: function */
 728               	/* frame size = 0 */
 729               	/* stack size = 0 */
 730               	.L__stack_usage = 0
 170:Menu.c        ****         mode=1;
 731               		.loc 1 170 0
 732 0226 8091 0000 		lds r24,mode
 733 022a 8230      		cpi r24,lo8(2)
 734 022c 01F4      		brne .L40
 171:Menu.c        ****     }else if(mode==1){
 735               		.loc 1 171 0
 736 022e 81E0      		ldi r24,lo8(1)
 737 0230 00C0      		rjmp .L43
 738               	.L40:
 172:Menu.c        ****         mode=2;
 739               		.loc 1 172 0
 740 0232 8130      		cpi r24,lo8(1)
 741 0234 01F4      		brne .L41
 173:Menu.c        ****     }
 742               		.loc 1 173 0
 743 0236 82E0      		ldi r24,lo8(2)
 744               	.L43:
 745 0238 8093 0000 		sts mode,r24
 746               	.L41:
 175:Menu.c        ****         colorMode=((colorMode-64+1)%7)+64;
 747               		.loc 1 175 0
 748 023c 8091 0000 		lds r24,colorMode
 749 0240 90EC      		ldi r25,lo8(-64)
 750 0242 980F      		add r25,r24
 751 0244 9034      		cpi r25,lo8(64)
 752 0246 00F4      		brsh .L42
 176:Menu.c        ****     }
 753               		.loc 1 176 0
 754 0248 90E0      		ldi r25,0
 755 024a CF97      		sbiw r24,63
 756 024c 67E0      		ldi r22,lo8(7)
 757 024e 70E0      		ldi r23,0
 758 0250 00D0      		rcall __divmodhi4
 759 0252 805C      		subi r24,lo8(-(64))
 760 0254 8093 0000 		sts colorMode,r24
 761               	.L42:
 179:Menu.c        **** void MsetColorMode(uint8_t i){
 762               		.loc 1 179 0
 763 0258 8091 0000 		lds r24,mode
 764 025c 0895      		ret
 765               		.cfi_endproc
 766               	.LFE12:
 768               	.global	getColor
 770               	getColor:
 771               	.LFB14:
 192:Menu.c        ****     if(colorMode>127){//cycle single
 772               		.loc 1 192 0
 773               		.cfi_startproc
 774               	/* prologue: function */
 775               	/* frame size = 0 */
 776               	/* stack size = 0 */
 777               	.L__stack_usage = 0
 193:Menu.c        ****         if(colorMode>134)colorMode=128;
 778               		.loc 1 193 0
 779 025e 8091 0000 		lds r24,colorMode
 780 0262 87FF      		sbrs r24,7
 781 0264 00C0      		rjmp .L45
 194:Menu.c        ****         colorMode++;
 782               		.loc 1 194 0
 783 0266 8738      		cpi r24,lo8(-121)
 784 0268 00F0      		brlo .L46
 194:Menu.c        ****         colorMode++;
 785               		.loc 1 194 0 is_stmt 0 discriminator 1
 786 026a 80E8      		ldi r24,lo8(-128)
 787 026c 8093 0000 		sts colorMode,r24
 788               	.L46:
 195:Menu.c        ****         return colorArray[colorMode-129];
 789               		.loc 1 195 0 is_stmt 1
 790 0270 E091 0000 		lds r30,colorMode
 791 0274 EF5F      		subi r30,lo8(-(1))
 792 0276 E093 0000 		sts colorMode,r30
 196:Menu.c        ****     }else if(colorMode>63){//cycle all
 793               		.loc 1 196 0
 794 027a F0E0      		ldi r31,0
 795 027c E050      		subi r30,lo8(-(colorArray-129))
 796 027e F040      		sbci r31,hi8(-(colorArray-129))
 797 0280 00C0      		rjmp .L48
 798               	.L45:
 197:Menu.c        ****         return colorArray[(colorMode-64)%7];
 799               		.loc 1 197 0
 800 0282 8034      		cpi r24,lo8(64)
 801 0284 00F0      		brlo .L47
 198:Menu.c        ****     }else{//fixed
 802               		.loc 1 198 0
 803 0286 90E0      		ldi r25,0
 804 0288 8054      		subi r24,64
 805 028a 9109      		sbc r25,__zero_reg__
 806 028c 67E0      		ldi r22,lo8(7)
 807 028e 70E0      		ldi r23,0
 808 0290 00D0      		rcall __divmodhi4
 809 0292 FC01      		movw r30,r24
 810 0294 E050      		subi r30,lo8(-(colorArray))
 811 0296 F040      		sbci r31,hi8(-(colorArray))
 812               	.L48:
 813 0298 8081      		ld r24,Z
 814               	.L47:
 202:Menu.c        **** void MsetNightMode(uint8_t i){
 815               		.loc 1 202 0
 816 029a 0895      		ret
 817               		.cfi_endproc
 818               	.LFE14:
 820               	.global	isInAllowedTime
 822               	isInAllowedTime:
 823               	.LFB16:
 206:Menu.c        ****     if(EEPROM_read(EE_NIGHTMODE))return (h>=EEPROM_read(EE_ONHOUR) && h<=EEPROM_read(EE_OFFHOUR));
 824               		.loc 1 206 0
 825               		.cfi_startproc
 826               	.LVL77:
 827 029c CF93      		push r28
 828               	.LCFI0:
 829               		.cfi_def_cfa_offset 3
 830               		.cfi_offset 28, -2
 831               	/* prologue: function */
 832               	/* frame size = 0 */
 833               	/* stack size = 1 */
 834               	.L__stack_usage = 1
 835 029e C82F      		mov r28,r24
 207:Menu.c        ****     return 1;
 836               		.loc 1 207 0
 837 02a0 81E0      		ldi r24,lo8(1)
 838               	.LVL78:
 839 02a2 00D0      		rcall EEPROM_read
 840               	.LVL79:
 841 02a4 8823      		tst r24
 842 02a6 01F0      		breq .L53
 207:Menu.c        ****     return 1;
 843               		.loc 1 207 0 is_stmt 0 discriminator 1
 844 02a8 82E0      		ldi r24,lo8(2)
 845 02aa 00D0      		rcall EEPROM_read
 846               	.LVL80:
 847 02ac C817      		cp r28,r24
 848 02ae 00F0      		brlo .L54
 207:Menu.c        ****     return 1;
 849               		.loc 1 207 0 discriminator 2
 850 02b0 83E0      		ldi r24,lo8(3)
 851 02b2 00D0      		rcall EEPROM_read
 852               	.LVL81:
 853 02b4 91E0      		ldi r25,lo8(1)
 854 02b6 8C17      		cp r24,r28
 855 02b8 00F4      		brsh .L52
 856 02ba 90E0      		ldi r25,0
 857               	.L52:
 858 02bc 892F      		mov r24,r25
 859 02be 00C0      		rjmp .L50
 860               	.L54:
 207:Menu.c        ****     return 1;
 861               		.loc 1 207 0
 862 02c0 80E0      		ldi r24,0
 863 02c2 00C0      		rjmp .L50
 864               	.L53:
 208:Menu.c        **** }
 865               		.loc 1 208 0 is_stmt 1
 866 02c4 81E0      		ldi r24,lo8(1)
 867               	.L50:
 868               	/* epilogue start */
 209:Menu.c        **** void MsetNightOff(uint8_t i){
 869               		.loc 1 209 0
 870 02c6 CF91      		pop r28
 871               	.LVL82:
 872 02c8 0895      		ret
 873               		.cfi_endproc
 874               	.LFE16:
 876               	.global	colorMode
 877               		.section .bss
 880               	colorMode:
 881 0000 00        		.zero	1
 882               	.global	mode
 883               		.data
 886               	mode:
 887 0000 01        		.byte	1
 888               	.global	M1rainbow
 889               		.section	.rodata
 892               	M1rainbow:
 893 0000 33        		.byte	51
 894 0001 0000      		.word	gs(MsetRainbow)
 895 0003 07        		.byte	7
 896 0004 0000      		.word	0
 897 0006 08        		.byte	8
 898 0007 0000      		.word	0
 899 0009 0F        		.byte	15
 900 000a 0000      		.word	M0main
 901               	.global	M1reset
 904               	M1reset:
 905 000c 42        		.byte	66
 906 000d 0000      		.word	gs(Mreset)
 907 000f 12        		.byte	18
 908 0010 0000      		.word	0
 909 0012 0F        		.byte	15
 910 0013 0000      		.word	M0main
 911               	.global	M1eventMode
 914               	M1eventMode:
 915 0015 13        		.byte	19
 916 0016 0000      		.word	gs(MsetEventMode)
 917 0018 07        		.byte	7
 918 0019 0000      		.word	0
 919 001b 08        		.byte	8
 920 001c 0000      		.word	0
 921 001e 0F        		.byte	15
 922 001f 0000      		.word	M0main
 923               	.global	M2setminpm
 926               	M2setminpm:
 927 0021 24        		.byte	36
 928 0022 0000      		.word	gs(MsetMinpm)
 929 0024 05        		.byte	5
 930 0025 0000      		.word	0
 931 0027 0B        		.byte	11
 932 0028 0000      		.word	0
 933 002a 01        		.byte	1
 934 002b 0000      		.word	0
 935 002d 0F        		.byte	15
 936 002e 0000      		.word	M1setTime
 937               	.global	M2setminam
 940               	M2setminam:
 941 0030 24        		.byte	36
 942 0031 0000      		.word	gs(MsetMinam)
 943 0033 05        		.byte	5
 944 0034 0000      		.word	0
 945 0036 0B        		.byte	11
 946 0037 0000      		.word	0
 947 0039 01        		.byte	1
 948 003a 0000      		.word	0
 949 003c 0F        		.byte	15
 950 003d 0000      		.word	M1setTime
 951               	.global	M2sethourpm
 954               	M2sethourpm:
 955 003f 4C        		.byte	76
 956 0040 0000      		.word	gs(MsetHourpm)
 957 0042 07        		.byte	7
 958 0043 0000      		.word	0
 959 0045 08        		.byte	8
 960 0046 0000      		.word	0
 961 0048 0A        		.byte	10
 962 0049 0000      		.word	0
 963 004b 0E        		.byte	14
 964 004c 0000      		.word	0
 965 004e 00        		.byte	0
 966 004f 0000      		.word	0
 967 0051 04        		.byte	4
 968 0052 0000      		.word	0
 969 0054 11        		.byte	17
 970 0055 0000      		.word	0
 971 0057 02        		.byte	2
 972 0058 0000      		.word	0
 973 005a 0C        		.byte	12
 974 005b 0000      		.word	0
 975 005d 06        		.byte	6
 976 005e 0000      		.word	0
 977 0060 10        		.byte	16
 978 0061 0000      		.word	0
 979 0063 0F        		.byte	15
 980 0064 0000      		.word	M1setTime
 981               	.global	M2sethouram
 984               	M2sethouram:
 985 0066 4D        		.byte	77
 986 0067 0000      		.word	gs(MsetHouram)
 987 0069 07        		.byte	7
 988 006a 0000      		.word	0
 989 006c 08        		.byte	8
 990 006d 0000      		.word	0
 991 006f 0A        		.byte	10
 992 0070 0000      		.word	0
 993 0072 0E        		.byte	14
 994 0073 0000      		.word	0
 995 0075 00        		.byte	0
 996 0076 0000      		.word	0
 997 0078 04        		.byte	4
 998 0079 0000      		.word	0
 999 007b 11        		.byte	17
 1000 007c 0000      		.word	0
 1001 007e 02        		.byte	2
 1002 007f 0000      		.word	0
 1003 0081 0C        		.byte	12
 1004 0082 0000      		.word	0
 1005 0084 06        		.byte	6
 1006 0085 0000      		.word	0
 1007 0087 10        		.byte	16
 1008 0088 0000      		.word	0
 1009 008a 0D        		.byte	13
 1010 008b 0000      		.word	0
 1011 008d 0F        		.byte	15
 1012 008e 0000      		.word	M1setTime
 1013               	.global	M1setTime
 1016               	M1setTime:
 1017 0090 65        		.byte	101
 1018 0091 0000      		.word	0
 1019 0093 07        		.byte	7
 1020 0094 0000      		.word	M2sethouram
 1021 0096 08        		.byte	8
 1022 0097 0000      		.word	M2sethourpm
 1023 0099 0A        		.byte	10
 1024 009a 0000      		.word	M2setminam
 1025 009c 0E        		.byte	14
 1026 009d 0000      		.word	M2setminpm
 1027 009f 0F        		.byte	15
 1028 00a0 0000      		.word	M0main
 1029               	.global	M3onhour
 1032               	M3onhour:
 1033 00a2 5C        		.byte	92
 1034 00a3 0000      		.word	gs(MsetNightOn)
 1035 00a5 07        		.byte	7
 1036 00a6 0000      		.word	0
 1037 00a8 08        		.byte	8
 1038 00a9 0000      		.word	0
 1039 00ab 0A        		.byte	10
 1040 00ac 0000      		.word	0
 1041 00ae 0E        		.byte	14
 1042 00af 0000      		.word	0
 1043 00b1 00        		.byte	0
 1044 00b2 0000      		.word	0
 1045 00b4 04        		.byte	4
 1046 00b5 0000      		.word	0
 1047 00b7 11        		.byte	17
 1048 00b8 0000      		.word	0
 1049 00ba 02        		.byte	2
 1050 00bb 0000      		.word	0
 1051 00bd 0C        		.byte	12
 1052 00be 0000      		.word	0
 1053 00c0 06        		.byte	6
 1054 00c1 0000      		.word	0
 1055 00c3 10        		.byte	16
 1056 00c4 0000      		.word	0
 1057 00c6 0F        		.byte	15
 1058 00c7 0000      		.word	M1nightmode
 1059               	.global	M2offhour
 1062               	M2offhour:
 1063 00c9 4C        		.byte	76
 1064 00ca 0000      		.word	gs(MsetNightOff)
 1065 00cc 07        		.byte	7
 1066 00cd 0000      		.word	M3onhour
 1067 00cf 08        		.byte	8
 1068 00d0 0000      		.word	M3onhour
 1069 00d2 0A        		.byte	10
 1070 00d3 0000      		.word	M3onhour
 1071 00d5 0E        		.byte	14
 1072 00d6 0000      		.word	M3onhour
 1073 00d8 00        		.byte	0
 1074 00d9 0000      		.word	M3onhour
 1075 00db 04        		.byte	4
 1076 00dc 0000      		.word	M3onhour
 1077 00de 11        		.byte	17
 1078 00df 0000      		.word	M3onhour
 1079 00e1 02        		.byte	2
 1080 00e2 0000      		.word	M3onhour
 1081 00e4 0C        		.byte	12
 1082 00e5 0000      		.word	M3onhour
 1083 00e7 06        		.byte	6
 1084 00e8 0000      		.word	M3onhour
 1085 00ea 10        		.byte	16
 1086 00eb 0000      		.word	M3onhour
 1087 00ed 0F        		.byte	15
 1088 00ee 0000      		.word	M1nightmode
 1089               	.global	M1nightmode
 1092               	M1nightmode:
 1093 00f0 34        		.byte	52
 1094 00f1 0000      		.word	gs(MsetNightMode)
 1095 00f3 07        		.byte	7
 1096 00f4 0000      		.word	0
 1097 00f6 08        		.byte	8
 1098 00f7 0000      		.word	M2offhour
 1099 00f9 0A        		.byte	10
 1100 00fa 0000      		.word	M2offhour
 1101 00fc 0F        		.byte	15
 1102 00fd 0000      		.word	M0main
 1103               	.global	M1cmode
 1106               	M1cmode:
 1107 00ff 2A        		.byte	42
 1108 0100 0000      		.word	gs(MsetColorMode)
 1109 0102 07        		.byte	7
 1110 0103 0000      		.word	0
 1111 0105 08        		.byte	8
 1112 0106 0000      		.word	0
 1113 0108 0A        		.byte	10
 1114 0109 0000      		.word	0
 1115 010b 0E        		.byte	14
 1116 010c 0000      		.word	0
 1117 010e 00        		.byte	0
 1118 010f 0000      		.word	0
 1119 0111 04        		.byte	4
 1120 0112 0000      		.word	0
 1121 0114 11        		.byte	17
 1122 0115 0000      		.word	0
 1123 0117 02        		.byte	2
 1124 0118 0000      		.word	0
 1125 011a 0C        		.byte	12
 1126 011b 0000      		.word	0
 1127 011d 0F        		.byte	15
 1128 011e 0000      		.word	M0main
 1129               	.global	M1mode
 1132               	M1mode:
 1133 0120 15        		.byte	21
 1134 0121 0000      		.word	gs(MsetMode)
 1135 0123 07        		.byte	7
 1136 0124 0000      		.word	0
 1137 0126 08        		.byte	8
 1138 0127 0000      		.word	0
 1139 0129 0A        		.byte	10
 1140 012a 0000      		.word	0
 1141 012c 0E        		.byte	14
 1142 012d 0000      		.word	0
 1143 012f 0F        		.byte	15
 1144 0130 0000      		.word	M0main
 1145               	.global	M0main
 1148               	M0main:
 1149 0132 08        		.byte	8
 1150 0133 0000      		.word	0
 1151 0135 07        		.byte	7
 1152 0136 0000      		.word	M1mode
 1153 0138 08        		.byte	8
 1154 0139 0000      		.word	M1cmode
 1155 013b 0A        		.byte	10
 1156 013c 0000      		.word	M1nightmode
 1157 013e 0E        		.byte	14
 1158 013f 0000      		.word	M1setTime
 1159 0141 00        		.byte	0
 1160 0142 0000      		.word	M1eventMode
 1161 0144 04        		.byte	4
 1162 0145 0000      		.word	M1reset
 1163 0147 11        		.byte	17
 1164 0148 0000      		.word	M1rainbow
 1165 014a 0F        		.byte	15
 1166 014b 0000      		.word	0
 1167               		.comm	USI_I2C_Master_State,1,1
 1168               		.comm	currentTime,5,1
 1171               	colorArray:
 1172 014d 07        		.byte	7
 1173 014e 03        		.byte	3
 1174 014f 01        		.byte	1
 1175 0150 05        		.byte	5
 1176 0151 04        		.byte	4
 1177 0152 06        		.byte	6
 1178 0153 02        		.byte	2
 1179               		.text
 1180               	.Letext0:
 1181               		.file 3 "/usr/lib/avr/include/stdint.h"
 1182               		.file 4 "RTC.h"
 1183               		.file 5 "Menu.h"
 1184               		.file 6 "Led.h"
 1185               		.file 7 "defines.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Menu.c
     /tmp/cclBLG5H.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cclBLG5H.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cclBLG5H.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cclBLG5H.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cclBLG5H.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cclBLG5H.s:12     .text:0000000000000000 MsetHouram
     /tmp/cclBLG5H.s:37     .text:000000000000000a MsetHourpm
     /tmp/cclBLG5H.s:61     .text:0000000000000014 MsetRainbow
     /tmp/cclBLG5H.s:886    .data:0000000000000000 mode
     /tmp/cclBLG5H.s:239    .text:00000000000000e4 MsetMinam
     /tmp/cclBLG5H.s:270    .text:00000000000000f2 MsetMinpm
     /tmp/cclBLG5H.s:302    .text:0000000000000102 findNextEntry
     /tmp/cclBLG5H.s:338    .text:0000000000000122 getSubMenu
     /tmp/cclBLG5H.s:369    .text:000000000000013a EEPROM_write
     /tmp/cclBLG5H.s:400    .text:000000000000014e MsetMode
     /tmp/cclBLG5H.s:443    .text:000000000000016e MsetColorMode
     /tmp/cclBLG5H.s:1171   .rodata:000000000000014d colorArray
     /tmp/cclBLG5H.s:880    .bss:0000000000000000 colorMode
     /tmp/cclBLG5H.s:501    .text:00000000000001a2 MsetNightMode
     /tmp/cclBLG5H.s:526    .text:00000000000001ae MsetNightOff
     /tmp/cclBLG5H.s:547    .text:00000000000001b6 MsetNightOn
     /tmp/cclBLG5H.s:568    .text:00000000000001be MsetEventMode
     /tmp/cclBLG5H.s:598    .text:00000000000001cc Mreset
     /tmp/cclBLG5H.s:665    .text:0000000000000200 EEPROM_read
     /tmp/cclBLG5H.s:694    .text:0000000000000210 Minit
     /tmp/cclBLG5H.s:723    .text:0000000000000226 getMode
     /tmp/cclBLG5H.s:770    .text:000000000000025e getColor
     /tmp/cclBLG5H.s:822    .text:000000000000029c isInAllowedTime
     /tmp/cclBLG5H.s:892    .rodata:0000000000000000 M1rainbow
     /tmp/cclBLG5H.s:1148   .rodata:0000000000000132 M0main
     /tmp/cclBLG5H.s:904    .rodata:000000000000000c M1reset
     /tmp/cclBLG5H.s:914    .rodata:0000000000000015 M1eventMode
     /tmp/cclBLG5H.s:926    .rodata:0000000000000021 M2setminpm
     /tmp/cclBLG5H.s:1016   .rodata:0000000000000090 M1setTime
     /tmp/cclBLG5H.s:940    .rodata:0000000000000030 M2setminam
     /tmp/cclBLG5H.s:954    .rodata:000000000000003f M2sethourpm
     /tmp/cclBLG5H.s:984    .rodata:0000000000000066 M2sethouram
     /tmp/cclBLG5H.s:1032   .rodata:00000000000000a2 M3onhour
     /tmp/cclBLG5H.s:1092   .rodata:00000000000000f0 M1nightmode
     /tmp/cclBLG5H.s:1062   .rodata:00000000000000c9 M2offhour
     /tmp/cclBLG5H.s:1106   .rodata:00000000000000ff M1cmode
     /tmp/cclBLG5H.s:1132   .rodata:0000000000000120 M1mode
                            *COM*:0000000000000001 USI_I2C_Master_State
                            *COM*:0000000000000005 currentTime

UNDEFINED SYMBOLS
RTC_setHour
sendRawData
__mulqi3
RTC_setMin
__mulhi3
__divmodhi4
__do_copy_data
__do_clear_bss
