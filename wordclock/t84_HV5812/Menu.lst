   1               		.file	"Menu.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	MsetHouram
  12               	MsetHouram:
  13               	.LFB19:
  14               		.file 1 "Menu.c"
   1:Menu.c        **** #include "Menu.h"
   2:Menu.c        **** 
   3:Menu.c        **** uint8_t mode=1;//0: hour only, 1-2: hour+temp, 3: temp only, >=4:Rainbow !
   4:Menu.c        **** uint8_t colorMode=0;
   5:Menu.c        **** 
   6:Menu.c        **** uint8_t findNextEntry(Menu* m,uint8_t index){
   7:Menu.c        ****     if((index+2)>(m->nb_optn%16))return 0;
   8:Menu.c        ****     return index+1;
   9:Menu.c        **** }
  10:Menu.c        **** 
  11:Menu.c        **** Menu* getSubMenu(Menu* m,uint8_t index){
  12:Menu.c        ****     if(m->sub[index].submenu==0)return 0;//if executed NULL, return blank menu (==exit setup)
  13:Menu.c        ****     return m->sub[index].submenu;
  14:Menu.c        **** }
  15:Menu.c        **** void EEPROM_write(uint8_t addr, uint8_t data){
  16:Menu.c        ****     while(EECR & (1<<EEPE));
  17:Menu.c        ****     EECR = (0<<EEPM1)|(0<<EEPM0);
  18:Menu.c        ****     EEAR = addr;
  19:Menu.c        ****     EEDR = data;
  20:Menu.c        ****     EECR |= (1<<EEMPE);
  21:Menu.c        ****     EECR |= (1<<EEPE);
  22:Menu.c        **** }
  23:Menu.c        **** uint8_t EEPROM_read(uint8_t addr){
  24:Menu.c        ****     while(EECR & (1<<EEPE));
  25:Menu.c        ****     EEAR = addr;
  26:Menu.c        ****     EECR |= (1<<EERE);
  27:Menu.c        ****     return EEDR;
  28:Menu.c        **** }
  29:Menu.c        **** 
  30:Menu.c        **** void Minit(void){
  31:Menu.c        ****     colorMode=EEPROM_read(EE_COLOR);
  32:Menu.c        ****     mode=EEPROM_read(EE_MODE);
  33:Menu.c        ****     MsetMode(EEPROM_read(EE_MODE));
  34:Menu.c        **** }
  35:Menu.c        **** const Menu M0main={8,0,{//WHITE
  36:Menu.c        ****     {7,&M1mode},
  37:Menu.c        ****     {8,&M1cmode},
  38:Menu.c        ****     {10,&M1nightmode},
  39:Menu.c        ****     {14,&M1setTime},
  40:Menu.c        ****     {0,&M1eventMode},
  41:Menu.c        ****     {4,&M1reset},
  42:Menu.c        ****     {17,&M1rainbow},
  43:Menu.c        ****     {HEURE,0}//exit      
  44:Menu.c        **** }};
  45:Menu.c        **** const Menu M1mode={5+16,MsetMode,{//CYAN
  46:Menu.c        ****     {7,0},//Hour only
  47:Menu.c        ****     {8,0},//Hour + temp (slow)
  48:Menu.c        ****     {10,0},//Hour + temp (fast)
  49:Menu.c        ****     {14,0},//temp only
  50:Menu.c        ****     {HEURE,&M0main}//return    
  51:Menu.c        **** }};
  52:Menu.c        **** const Menu M1cmode={10+32,MsetColorMode,{//BLUE
  53:Menu.c        ****     {7,0},//fixed WHITE 1
  54:Menu.c        ****     {8,0},//fixed CYAN 2
  55:Menu.c        ****     {10,0},//fixed BLUE 3
  56:Menu.c        ****     {14,0},//fixed MAGENTA 4
  57:Menu.c        ****     {0,0},//fixed RED 5
  58:Menu.c        ****     {4,0},//fixed YELLOW 6
  59:Menu.c        ****     {17,0},//fixed GREEN 7
  60:Menu.c        ****     {2,0},// cycle single 8
  61:Menu.c        ****     {12,0},// cycle all 9
  62:Menu.c        ****     {HEURE,&M0main}//return    
  63:Menu.c        **** }};
  64:Menu.c        **** const Menu M1nightmode={4+48,MsetNightMode,{//MAGENTA
  65:Menu.c        ****     {7,0},//none
  66:Menu.c        ****     {8,&M2offhour},//Half brightness
  67:Menu.c        ****     {10,&M2offhour},//Off completely
  68:Menu.c        ****     {HEURE,&M0main}//return
  69:Menu.c        **** }};
  70:Menu.c        **** const Menu M2offhour={12+64,MsetNightOff,{//RED
  71:Menu.c        ****     {7,&M3onhour},//heures
  72:Menu.c        ****     {8,&M3onhour},
  73:Menu.c        ****     {10,&M3onhour},
  74:Menu.c        ****     {14,&M3onhour},
  75:Menu.c        ****     {0,&M3onhour},
  76:Menu.c        ****     {4,&M3onhour},
  77:Menu.c        ****     {17,&M3onhour},
  78:Menu.c        ****     {2,&M3onhour},
  79:Menu.c        ****     {12,&M3onhour},
  80:Menu.c        ****     {6,&M3onhour},
  81:Menu.c        ****     {16,&M3onhour},
  82:Menu.c        ****     {HEURE,&M1nightmode}//return
  83:Menu.c        **** }};
  84:Menu.c        **** const Menu M3onhour={12+80,MsetNightOn,{//YELLOW
  85:Menu.c        ****     {7,0},//heures
  86:Menu.c        ****     {8,0},
  87:Menu.c        ****     {10,0},
  88:Menu.c        ****     {14,0},
  89:Menu.c        ****     {0,0},
  90:Menu.c        ****     {4,0},
  91:Menu.c        ****     {17,0},
  92:Menu.c        ****     {2,0},
  93:Menu.c        ****     {12,0},
  94:Menu.c        ****     {6,0},
  95:Menu.c        ****     {16,0},
  96:Menu.c        ****     {HEURE,&M1nightmode}//return
  97:Menu.c        **** }};
  98:Menu.c        **** const Menu M1setTime={5+96,0,{//GREEN
  99:Menu.c        ****     {7,&M2sethouram},//hour am
 100:Menu.c        ****     {8,&M2sethourpm},//hour pm
 101:Menu.c        ****     {10,&M2setminam},//min am
 102:Menu.c        ****     {14,&M2setminpm},//min pm
 103:Menu.c        ****     {HEURE,&M0main}//return
 104:Menu.c        **** }};
 105:Menu.c        **** const Menu M2sethouram={13+64,MsetHouram,{//RED
 106:Menu.c        ****     {7,0},//heure
 107:Menu.c        ****     {8,0},
 108:Menu.c        ****     {10,0},
 109:Menu.c        ****     {14,0},
 110:Menu.c        ****     {0,0},
 111:Menu.c        ****     {4,0},
 112:Menu.c        ****     {17,0},
 113:Menu.c        ****     {2,0},
 114:Menu.c        ****     {12,0},
 115:Menu.c        ****     {6,0},
 116:Menu.c        ****     {16,0},
 117:Menu.c        ****     {MIDI,0},//midi
 118:Menu.c        ****     {HEURE,&M1setTime}//return
 119:Menu.c        **** }};
 120:Menu.c        **** const Menu M2sethourpm={12+64,MsetHourpm,{//RED
 121:Menu.c        ****     {7,0},//heure
 122:Menu.c        ****     {8,0},
 123:Menu.c        ****     {10,0},
 124:Menu.c        ****     {14,0},
 125:Menu.c        ****     {0,0},
 126:Menu.c        ****     {4,0},
 127:Menu.c        ****     {17,0},
 128:Menu.c        ****     {2,0},
 129:Menu.c        ****     {12,0},
 130:Menu.c        ****     {6,0},
 131:Menu.c        ****     {16,0},
 132:Menu.c        ****     {HEURE,&M1setTime}//return
 133:Menu.c        **** }};
 134:Menu.c        **** const Menu M2setminam={4+32,MsetMinam,{//BLUE
 135:Menu.c        ****     {DIX,0},//dix
 136:Menu.c        ****     {VINGT,0},//vingt
 137:Menu.c        ****     {ETDEMIE,0},//1/2
 138:Menu.c        ****     {HEURE,&M1setTime}//return
 139:Menu.c        **** }};
 140:Menu.c        **** const Menu M2setminpm={4+32,MsetMinpm,{//BLUE
 141:Menu.c        ****     {DIX,0},//dix
 142:Menu.c        ****     {VINGT,0},//vingt
 143:Menu.c        ****     {ETDEMIE,0},//1/2
 144:Menu.c        ****     {HEURE,&M1setTime}//return
 145:Menu.c        **** }};
 146:Menu.c        **** const Menu M1eventMode={3+16,MsetEventMode,{//CYAN
 147:Menu.c        ****     {7,0},//Event on
 148:Menu.c        ****     {8,0},//Event off
 149:Menu.c        ****     {HEURE,&M0main}//return
 150:Menu.c        **** }};
 151:Menu.c        **** const Menu M1reset={2+64,Mreset,{//RED
 152:Menu.c        ****     {ILEST,0},//yes
 153:Menu.c        ****     {HEURE,&M0main}//return
 154:Menu.c        **** }};
 155:Menu.c        **** const Menu M1rainbow={3+48,MsetRainbow,{//MAGENTA
 156:Menu.c        ****     {7,0},//Rainbow on
 157:Menu.c        ****     {8,0},//Rainbow off
 158:Menu.c        ****     {HEURE,&M0main}//return
 159:Menu.c        **** }};
 160:Menu.c        **** 
 161:Menu.c        **** void MsetMode(uint8_t i){
 162:Menu.c        ****    if(i<4){
 163:Menu.c        ****         TCCR1B|=(1<<CS12)|(1<<CS10);
 164:Menu.c        ****         if(i==2)TCCR1B&=~(1<<CS10);
 165:Menu.c        ****         mode=i;
 166:Menu.c        ****         EEPROM_write(EE_MODE,i);
 167:Menu.c        ****     }
 168:Menu.c        **** }
 169:Menu.c        **** uint8_t getMode(void){
 170:Menu.c        ****     if(mode==2){
 171:Menu.c        ****         mode=1;
 172:Menu.c        ****     }else if(mode==1){
 173:Menu.c        ****         mode=2;
 174:Menu.c        ****     }
 175:Menu.c        ****     return mode;
 176:Menu.c        **** }
 177:Menu.c        **** void MsetColorMode(uint8_t i){
 178:Menu.c        ****     if(i<7){
 179:Menu.c        ****         colorMode=colorArray[i];//fixed
 180:Menu.c        ****         EEPROM_write(EE_COLOR,colorArray[i]);
 181:Menu.c        ****     }else if(i==7){//cycle single
 182:Menu.c        ****         colorMode=WHITE+128;
 183:Menu.c        ****         EEPROM_write(EE_COLOR,128);
 184:Menu.c        ****     }else if(i==8){//cycle all
 185:Menu.c        ****         colorMode=WHITE+64;
 186:Menu.c        ****         EEPROM_write(EE_COLOR,64);
 187:Menu.c        ****     }
 188:Menu.c        **** }
 189:Menu.c        **** uint8_t getColor(void){
 190:Menu.c        ****     if(colorMode>127){//cycle single
 191:Menu.c        ****         if(colorMode>134)colorMode=128;
 192:Menu.c        ****         colorMode++;
 193:Menu.c        ****         return colorArray[colorMode-129];
 194:Menu.c        ****     }else if(colorMode>63){//cycle all
 195:Menu.c        ****         return RED;
 196:Menu.c        ****     }else{//fixed
 197:Menu.c        ****         return colorMode;
 198:Menu.c        ****     }
 199:Menu.c        **** }
 200:Menu.c        **** void MsetNightMode(uint8_t i){
 201:Menu.c        ****     if(i<3)EEPROM_write(EE_NIGHTMODE,i);
 202:Menu.c        **** }
 203:Menu.c        **** uint8_t isInAllowedTime(uint8_t h){
 204:Menu.c        ****     if(EEPROM_read(EE_NIGHTMODE))return (h>=EEPROM_read(EE_ONHOUR) && h<=EEPROM_read(EE_OFFHOUR));
 205:Menu.c        ****     return 1;
 206:Menu.c        **** }
 207:Menu.c        **** void MsetNightOff(uint8_t i){
 208:Menu.c        ****     EEPROM_write(EE_OFFHOUR,12+i);
 209:Menu.c        **** }
 210:Menu.c        **** void MsetNightOn(uint8_t i){
 211:Menu.c        ****     EEPROM_write(EE_ONHOUR,1+i);
 212:Menu.c        **** }
 213:Menu.c        **** void MsetHouram(uint8_t i){
  15               		.loc 1 213 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 214:Menu.c        ****    if(i<12)RTC_setHour(i+1);
  22               		.loc 1 214 0
  23 0000 8C30      		cpi r24,lo8(12)
  24 0002 00F4      		brsh .L1
  25               		.loc 1 214 0 is_stmt 0 discriminator 1
  26 0004 8F5F      		subi r24,lo8(-(1))
  27               	.LVL1:
  28 0006 00C0      		rjmp RTC_setHour
  29               	.LVL2:
  30               	.L1:
  31 0008 0895      		ret
  32               		.cfi_endproc
  33               	.LFE19:
  35               	.global	MsetHourpm
  37               	MsetHourpm:
  38               	.LFB20:
 215:Menu.c        **** }
 216:Menu.c        **** void MsetHourpm(uint8_t i){
  39               		.loc 1 216 0 is_stmt 1
  40               		.cfi_startproc
  41               	.LVL3:
  42               	/* prologue: function */
  43               	/* frame size = 0 */
  44               	/* stack size = 0 */
  45               	.L__stack_usage = 0
 217:Menu.c        ****    if(i<11)RTC_setHour(i+13);    
  46               		.loc 1 217 0
  47 000a 8B30      		cpi r24,lo8(11)
  48 000c 00F4      		brsh .L4
  49               		.loc 1 217 0 is_stmt 0 discriminator 1
  50 000e 835F      		subi r24,lo8(-(13))
  51               	.LVL4:
  52 0010 00C0      		rjmp RTC_setHour
  53               	.LVL5:
  54               	.L4:
  55 0012 0895      		ret
  56               		.cfi_endproc
  57               	.LFE20:
  59               	.global	MsetRainbow
  61               	MsetRainbow:
  62               	.LFB25:
 218:Menu.c        **** }
 219:Menu.c        **** void MsetMinam(uint8_t i){
 220:Menu.c        ****     if(i<3)RTC_setMin((i+1)*10);
 221:Menu.c        ****     }
 222:Menu.c        **** void MsetMinpm(uint8_t i){
 223:Menu.c        ****     if(i<3)RTC_setMin(60-(i+1)*10);
 224:Menu.c        **** }
 225:Menu.c        **** void MsetEventMode(uint8_t i){
 226:Menu.c        ****     if(i<2)EEPROM_write(EE_EVENT,1-i);//1 for active
 227:Menu.c        **** }
 228:Menu.c        **** void Mreset(uint8_t i){
 229:Menu.c        ****     if(i<1){
 230:Menu.c        ****         MsetMode(1);
 231:Menu.c        ****         MsetColorMode(0);
 232:Menu.c        ****         EEPROM_write(EE_NIGHTMODE,1);
 233:Menu.c        ****         EEPROM_write(EE_OFFHOUR,12+10);
 234:Menu.c        ****         EEPROM_write(EE_ONHOUR,1+8);
 235:Menu.c        ****         TCCR1B|=(1<<CS12)|(1<<CS10);
 236:Menu.c        ****     }
 237:Menu.c        **** }
 238:Menu.c        **** 
 239:Menu.c        **** void MsetRainbow(uint8_t i){
  63               		.loc 1 239 0 is_stmt 1
  64               		.cfi_startproc
  65               	.LVL6:
  66               	/* prologue: function */
  67               	/* frame size = 0 */
  68               	/* stack size = 0 */
  69               	.L__stack_usage = 0
 240:Menu.c        ****     if(i<2)mode=4;
  70               		.loc 1 240 0
  71 0014 8230      		cpi r24,lo8(2)
  72 0016 00F4      		brsh .L7
  73               		.loc 1 240 0 is_stmt 0 discriminator 1
  74 0018 84E0      		ldi r24,lo8(4)
  75               	.LVL7:
  76 001a 8093 0000 		sts mode,r24
  77               	.L7:
 241:Menu.c        ****   //  cli();
 242:Menu.c        ****     sendRawData(0b11111100001111111111);//white
  78               		.loc 1 242 0 is_stmt 1
  79 001e 6FEF      		ldi r22,lo8(-1)
  80 0020 73EC      		ldi r23,lo8(-61)
  81 0022 8FE0      		ldi r24,lo8(15)
  82 0024 90E0      		ldi r25,0
  83 0026 00D0      		rcall sendRawData
  84               	.LVL8:
  85               	.LBB20:
  86               	.LBB21:
  87               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  88               		.loc 2 187 0
  89 0028 2FEF      		ldi r18,lo8(1599999)
  90 002a 89E6      		ldi r24,hi8(1599999)
  91 002c 98E1      		ldi r25,hlo8(1599999)
  92 002e 2150      	1:	subi r18,1
  93 0030 8040      		sbci r24,0
  94 0032 9040      		sbci r25,0
  95 0034 01F4      		brne 1b
  96 0036 00C0      		rjmp .
  97 0038 0000      		nop
  98               	.LVL9:
  99               	.LBE21:
 100               	.LBE20:
 243:Menu.c        ****     _delay_ms(500);
 244:Menu.c        ****     sendRawData(0b11000000001111111111);//green
 101               		.loc 1 244 0
 102 003a 6FEF      		ldi r22,lo8(-1)
 103 003c 73E0      		ldi r23,lo8(3)
 104 003e 8CE0      		ldi r24,lo8(12)
 105 0040 90E0      		ldi r25,0
 106 0042 00D0      		rcall sendRawData
 107               	.LVL10:
 108               	.LBB22:
 109               	.LBB23:
 110               		.loc 2 187 0
 111 0044 2FEF      		ldi r18,lo8(1599999)
 112 0046 89E6      		ldi r24,hi8(1599999)
 113 0048 98E1      		ldi r25,hlo8(1599999)
 114 004a 2150      	1:	subi r18,1
 115 004c 8040      		sbci r24,0
 116 004e 9040      		sbci r25,0
 117 0050 01F4      		brne 1b
 118 0052 00C0      		rjmp .
 119 0054 0000      		nop
 120               	.LVL11:
 121               	.LBE23:
 122               	.LBE22:
 245:Menu.c        ****     _delay_ms(500);
 246:Menu.c        ****     sendRawData(0b00001100001111111111);//red
 123               		.loc 1 246 0
 124 0056 6FEF      		ldi r22,lo8(-1)
 125 0058 73EC      		ldi r23,lo8(-61)
 126 005a 80E0      		ldi r24,0
 127 005c 90E0      		ldi r25,0
 128 005e 00D0      		rcall sendRawData
 129               	.LVL12:
 130               	.LBB24:
 131               	.LBB25:
 132               		.loc 2 187 0
 133 0060 2FEF      		ldi r18,lo8(1599999)
 134 0062 89E6      		ldi r24,hi8(1599999)
 135 0064 98E1      		ldi r25,hlo8(1599999)
 136 0066 2150      	1:	subi r18,1
 137 0068 8040      		sbci r24,0
 138 006a 9040      		sbci r25,0
 139 006c 01F4      		brne 1b
 140 006e 00C0      		rjmp .
 141 0070 0000      		nop
 142               	.LVL13:
 143               	.LBE25:
 144               	.LBE24:
 247:Menu.c        ****     _delay_ms(500);
 248:Menu.c        ****     sendRawData(0b00110000001111111111);//blue
 145               		.loc 1 248 0
 146 0072 6FEF      		ldi r22,lo8(-1)
 147 0074 73E0      		ldi r23,lo8(3)
 148 0076 83E0      		ldi r24,lo8(3)
 149 0078 90E0      		ldi r25,0
 150 007a 00D0      		rcall sendRawData
 151               	.LVL14:
 152               	.LBB26:
 153               	.LBB27:
 154               		.loc 2 187 0
 155 007c 2FEF      		ldi r18,lo8(1599999)
 156 007e 89E6      		ldi r24,hi8(1599999)
 157 0080 98E1      		ldi r25,hlo8(1599999)
 158 0082 2150      	1:	subi r18,1
 159 0084 8040      		sbci r24,0
 160 0086 9040      		sbci r25,0
 161 0088 01F4      		brne 1b
 162 008a 00C0      		rjmp .
 163 008c 0000      		nop
 164               	.LVL15:
 165               	.LBE27:
 166               	.LBE26:
 249:Menu.c        ****     _delay_ms(500);
 250:Menu.c        ****     sendRawData(0b11110000001111111111);//cyan
 167               		.loc 1 250 0
 168 008e 6FEF      		ldi r22,lo8(-1)
 169 0090 73E0      		ldi r23,lo8(3)
 170 0092 8FE0      		ldi r24,lo8(15)
 171 0094 90E0      		ldi r25,0
 172 0096 00D0      		rcall sendRawData
 173               	.LVL16:
 174               	.LBB28:
 175               	.LBB29:
 176               		.loc 2 187 0
 177 0098 2FEF      		ldi r18,lo8(1599999)
 178 009a 89E6      		ldi r24,hi8(1599999)
 179 009c 98E1      		ldi r25,hlo8(1599999)
 180 009e 2150      	1:	subi r18,1
 181 00a0 8040      		sbci r24,0
 182 00a2 9040      		sbci r25,0
 183 00a4 01F4      		brne 1b
 184 00a6 00C0      		rjmp .
 185 00a8 0000      		nop
 186               	.LVL17:
 187               	.LBE29:
 188               	.LBE28:
 251:Menu.c        ****     _delay_ms(500);
 252:Menu.c        ****     sendRawData(0b00111100001111111111);//magenta
 189               		.loc 1 252 0
 190 00aa 6FEF      		ldi r22,lo8(-1)
 191 00ac 73EC      		ldi r23,lo8(-61)
 192 00ae 83E0      		ldi r24,lo8(3)
 193 00b0 90E0      		ldi r25,0
 194 00b2 00D0      		rcall sendRawData
 195               	.LVL18:
 196               	.LBB30:
 197               	.LBB31:
 198               		.loc 2 187 0
 199 00b4 2FEF      		ldi r18,lo8(1599999)
 200 00b6 89E6      		ldi r24,hi8(1599999)
 201 00b8 98E1      		ldi r25,hlo8(1599999)
 202 00ba 2150      	1:	subi r18,1
 203 00bc 8040      		sbci r24,0
 204 00be 9040      		sbci r25,0
 205 00c0 01F4      		brne 1b
 206 00c2 00C0      		rjmp .
 207 00c4 0000      		nop
 208               	.LVL19:
 209               	.LBE31:
 210               	.LBE30:
 253:Menu.c        ****     _delay_ms(500);
 254:Menu.c        ****     sendRawData(0b11001100001111111111);//yellow
 211               		.loc 1 254 0
 212 00c6 6FEF      		ldi r22,lo8(-1)
 213 00c8 73EC      		ldi r23,lo8(-61)
 214 00ca 8CE0      		ldi r24,lo8(12)
 215 00cc 90E0      		ldi r25,0
 216 00ce 00D0      		rcall sendRawData
 217               	.LVL20:
 218               	.LBB32:
 219               	.LBB33:
 220               		.loc 2 187 0
 221 00d0 2FEF      		ldi r18,lo8(1599999)
 222 00d2 89E6      		ldi r24,hi8(1599999)
 223 00d4 98E1      		ldi r25,hlo8(1599999)
 224 00d6 2150      	1:	subi r18,1
 225 00d8 8040      		sbci r24,0
 226 00da 9040      		sbci r25,0
 227 00dc 01F4      		brne 1b
 228 00de 00C0      		rjmp .
 229 00e0 0000      		nop
 230               	.LVL21:
 231 00e2 0895      		ret
 232               	.LBE33:
 233               	.LBE32:
 234               		.cfi_endproc
 235               	.LFE25:
 237               	.global	MsetMinam
 239               	MsetMinam:
 240               	.LFB21:
 219:Menu.c        ****     if(i<3)RTC_setMin((i+1)*10);
 241               		.loc 1 219 0
 242               		.cfi_startproc
 243               	.LVL22:
 244               	/* prologue: function */
 245               	/* frame size = 0 */
 246               	/* stack size = 0 */
 247               	.L__stack_usage = 0
 220:Menu.c        ****     }
 248               		.loc 1 220 0
 249 00e4 8330      		cpi r24,lo8(3)
 250 00e6 00F4      		brsh .L8
 251               	.LVL23:
 252               	.LBB36:
 253               	.LBB37:
 254 00e8 8F5F      		subi r24,lo8(-(1))
 255               	.LVL24:
 256 00ea 6AE0      		ldi r22,lo8(10)
 257 00ec 00D0      		rcall __mulqi3
 258               	.LVL25:
 259 00ee 00C0      		rjmp RTC_setMin
 260               	.LVL26:
 261               	.L8:
 262 00f0 0895      		ret
 263               	.LBE37:
 264               	.LBE36:
 265               		.cfi_endproc
 266               	.LFE21:
 268               	.global	MsetMinpm
 270               	MsetMinpm:
 271               	.LFB22:
 222:Menu.c        ****     if(i<3)RTC_setMin(60-(i+1)*10);
 272               		.loc 1 222 0
 273               		.cfi_startproc
 274               	.LVL27:
 275               	/* prologue: function */
 276               	/* frame size = 0 */
 277               	/* stack size = 0 */
 278               	.L__stack_usage = 0
 223:Menu.c        **** }
 279               		.loc 1 223 0
 280 00f2 8330      		cpi r24,lo8(3)
 281 00f4 00F4      		brsh .L10
 282               	.LVL28:
 283               	.LBB40:
 284               	.LBB41:
 285 00f6 8F5F      		subi r24,lo8(-(1))
 286               	.LVL29:
 287 00f8 66EF      		ldi r22,lo8(-10)
 288 00fa 00D0      		rcall __mulqi3
 289               	.LVL30:
 290 00fc 845C      		subi r24,lo8(-(60))
 291 00fe 00C0      		rjmp RTC_setMin
 292               	.LVL31:
 293               	.L10:
 294 0100 0895      		ret
 295               	.LBE41:
 296               	.LBE40:
 297               		.cfi_endproc
 298               	.LFE22:
 300               	.global	findNextEntry
 302               	findNextEntry:
 303               	.LFB6:
   6:Menu.c        ****     if((index+2)>(m->nb_optn%16))return 0;
 304               		.loc 1 6 0
 305               		.cfi_startproc
 306               	.LVL32:
 307               	/* prologue: function */
 308               	/* frame size = 0 */
 309               	/* stack size = 0 */
 310               	.L__stack_usage = 0
   7:Menu.c        ****     return index+1;
 311               		.loc 1 7 0
 312 0102 262F      		mov r18,r22
 313 0104 30E0      		ldi r19,0
 314 0106 2F5F      		subi r18,-1
 315 0108 3F4F      		sbci r19,-1
 316 010a FC01      		movw r30,r24
 317 010c 8081      		ld r24,Z
 318               	.LVL33:
 319 010e 8F70      		andi r24,lo8(15)
 320 0110 90E0      		ldi r25,0
 321 0112 2817      		cp r18,r24
 322 0114 3907      		cpc r19,r25
 323 0116 04F4      		brge .L14
   8:Menu.c        **** }
 324               		.loc 1 8 0
 325 0118 81E0      		ldi r24,lo8(1)
 326 011a 860F      		add r24,r22
 327 011c 0895      		ret
 328               	.L14:
   7:Menu.c        ****     return index+1;
 329               		.loc 1 7 0
 330 011e 80E0      		ldi r24,0
   9:Menu.c        **** 
 331               		.loc 1 9 0
 332 0120 0895      		ret
 333               		.cfi_endproc
 334               	.LFE6:
 336               	.global	getSubMenu
 338               	getSubMenu:
 339               	.LFB7:
  11:Menu.c        ****     if(m->sub[index].submenu==0)return 0;//if executed NULL, return blank menu (==exit setup)
 340               		.loc 1 11 0
 341               		.cfi_startproc
 342               	.LVL34:
 343               	/* prologue: function */
 344               	/* frame size = 0 */
 345               	/* stack size = 0 */
 346               	.L__stack_usage = 0
 347 0122 9C01      		movw r18,r24
  12:Menu.c        ****     return m->sub[index].submenu;
 348               		.loc 1 12 0
 349 0124 862F      		mov r24,r22
 350               	.LVL35:
 351 0126 90E0      		ldi r25,0
 352 0128 63E0      		ldi r22,lo8(3)
 353 012a 70E0      		ldi r23,0
 354               	.LVL36:
 355 012c 00D0      		rcall __mulhi3
 356               	.LVL37:
 357 012e 820F      		add r24,r18
 358 0130 931F      		adc r25,r19
  14:Menu.c        **** void EEPROM_write(uint8_t addr, uint8_t data){
 359               		.loc 1 14 0
 360 0132 FC01      		movw r30,r24
 361 0134 8481      		ldd r24,Z+4
 362 0136 9581      		ldd r25,Z+5
 363 0138 0895      		ret
 364               		.cfi_endproc
 365               	.LFE7:
 367               	.global	EEPROM_write
 369               	EEPROM_write:
 370               	.LFB8:
  15:Menu.c        ****     while(EECR & (1<<EEPE));
 371               		.loc 1 15 0
 372               		.cfi_startproc
 373               	/* prologue: function */
 374               	/* frame size = 0 */
 375               	/* stack size = 0 */
 376               	.L__stack_usage = 0
 377               	.LVL38:
 378               	.L17:
  16:Menu.c        ****     EECR = (0<<EEPM1)|(0<<EEPM0);
 379               		.loc 1 16 0 discriminator 1
 380 013a E199      		sbic 0x1c,1
 381 013c 00C0      		rjmp .L17
  17:Menu.c        ****     EEAR = addr;
 382               		.loc 1 17 0
 383 013e 1CBA      		out 0x1c,__zero_reg__
  18:Menu.c        ****     EEDR = data;
 384               		.loc 1 18 0
 385 0140 90E0      		ldi r25,0
 386 0142 9FBB      		out 0x1e+1,r25
 387 0144 8EBB      		out 0x1e,r24
  19:Menu.c        ****     EECR |= (1<<EEMPE);
 388               		.loc 1 19 0
 389 0146 6DBB      		out 0x1d,r22
  20:Menu.c        ****     EECR |= (1<<EEPE);
 390               		.loc 1 20 0
 391 0148 E29A      		sbi 0x1c,2
  21:Menu.c        **** }
 392               		.loc 1 21 0
 393 014a E19A      		sbi 0x1c,1
 394 014c 0895      		ret
 395               		.cfi_endproc
 396               	.LFE8:
 398               	.global	MsetMode
 400               	MsetMode:
 401               	.LFB11:
 161:Menu.c        ****    if(i<4){
 402               		.loc 1 161 0
 403               		.cfi_startproc
 404               	.LVL39:
 405               	/* prologue: function */
 406               	/* frame size = 0 */
 407               	/* stack size = 0 */
 408               	.L__stack_usage = 0
 162:Menu.c        ****         TCCR1B|=(1<<CS12)|(1<<CS10);
 409               		.loc 1 162 0
 410 014e 8430      		cpi r24,lo8(4)
 411 0150 00F4      		brsh .L19
 412               	.LVL40:
 413               	.LBB44:
 414               	.LBB45:
 163:Menu.c        ****         if(i==2)TCCR1B&=~(1<<CS10);
 415               		.loc 1 163 0
 416 0152 9EB5      		in r25,0x2e
 417 0154 9560      		ori r25,lo8(5)
 418 0156 9EBD      		out 0x2e,r25
 164:Menu.c        ****         mode=i;
 419               		.loc 1 164 0
 420 0158 8230      		cpi r24,lo8(2)
 421 015a 01F4      		brne .L21
 422 015c 9EB5      		in r25,0x2e
 423 015e 9E7F      		andi r25,lo8(-2)
 424 0160 9EBD      		out 0x2e,r25
 425               	.L21:
 165:Menu.c        ****         EEPROM_write(EE_MODE,i);
 426               		.loc 1 165 0
 427 0162 8093 0000 		sts mode,r24
 166:Menu.c        ****     }
 428               		.loc 1 166 0
 429 0166 682F      		mov r22,r24
 430 0168 84E0      		ldi r24,lo8(4)
 431               	.LVL41:
 432 016a 00C0      		rjmp EEPROM_write
 433               	.LVL42:
 434               	.L19:
 435 016c 0895      		ret
 436               	.LBE45:
 437               	.LBE44:
 438               		.cfi_endproc
 439               	.LFE11:
 441               	.global	MsetColorMode
 443               	MsetColorMode:
 444               	.LFB13:
 177:Menu.c        ****     if(i<7){
 445               		.loc 1 177 0
 446               		.cfi_startproc
 447               	.LVL43:
 448               	/* prologue: function */
 449               	/* frame size = 0 */
 450               	/* stack size = 0 */
 451               	.L__stack_usage = 0
 178:Menu.c        ****         colorMode=colorArray[i];//fixed
 452               		.loc 1 178 0
 453 016e 8730      		cpi r24,lo8(7)
 454 0170 00F4      		brsh .L23
 179:Menu.c        ****         EEPROM_write(EE_COLOR,colorArray[i]);
 455               		.loc 1 179 0
 456 0172 E82F      		mov r30,r24
 457 0174 F0E0      		ldi r31,0
 458 0176 E050      		subi r30,lo8(-(colorArray))
 459 0178 F040      		sbci r31,hi8(-(colorArray))
 460 017a 6081      		ld r22,Z
 461 017c 6093 0000 		sts colorMode,r22
 462 0180 00C0      		rjmp .L26
 463               	.L23:
 181:Menu.c        ****         colorMode=WHITE+128;
 464               		.loc 1 181 0
 465 0182 8730      		cpi r24,lo8(7)
 466 0184 01F4      		brne .L24
 467               	.LVL44:
 468               	.LBB48:
 469               	.LBB49:
 182:Menu.c        ****         EEPROM_write(EE_COLOR,128);
 470               		.loc 1 182 0
 471 0186 87E8      		ldi r24,lo8(-121)
 472               	.LVL45:
 473 0188 8093 0000 		sts colorMode,r24
 183:Menu.c        ****     }else if(i==8){//cycle all
 474               		.loc 1 183 0
 475 018c 60E8      		ldi r22,lo8(-128)
 476 018e 00C0      		rjmp .L26
 477               	.LVL46:
 478               	.L24:
 479               	.LBE49:
 480               	.LBE48:
 184:Menu.c        ****         colorMode=WHITE+64;
 481               		.loc 1 184 0
 482 0190 8830      		cpi r24,lo8(8)
 483 0192 01F4      		brne .L22
 185:Menu.c        ****         EEPROM_write(EE_COLOR,64);
 484               		.loc 1 185 0
 485 0194 87E4      		ldi r24,lo8(71)
 486               	.LVL47:
 487 0196 8093 0000 		sts colorMode,r24
 186:Menu.c        ****     }
 488               		.loc 1 186 0
 489 019a 60E4      		ldi r22,lo8(64)
 490               	.L26:
 491 019c 80E0      		ldi r24,0
 492 019e 00C0      		rjmp EEPROM_write
 493               	.LVL48:
 494               	.L22:
 495 01a0 0895      		ret
 496               		.cfi_endproc
 497               	.LFE13:
 499               	.global	MsetNightMode
 501               	MsetNightMode:
 502               	.LFB15:
 200:Menu.c        ****     if(i<3)EEPROM_write(EE_NIGHTMODE,i);
 503               		.loc 1 200 0
 504               		.cfi_startproc
 505               	.LVL49:
 506               	/* prologue: function */
 507               	/* frame size = 0 */
 508               	/* stack size = 0 */
 509               	.L__stack_usage = 0
 201:Menu.c        **** }
 510               		.loc 1 201 0
 511 01a2 8330      		cpi r24,lo8(3)
 512 01a4 00F4      		brsh .L27
 201:Menu.c        **** }
 513               		.loc 1 201 0 is_stmt 0 discriminator 1
 514 01a6 682F      		mov r22,r24
 515 01a8 81E0      		ldi r24,lo8(1)
 516               	.LVL50:
 517 01aa 00C0      		rjmp EEPROM_write
 518               	.LVL51:
 519               	.L27:
 520 01ac 0895      		ret
 521               		.cfi_endproc
 522               	.LFE15:
 524               	.global	MsetNightOff
 526               	MsetNightOff:
 527               	.LFB17:
 207:Menu.c        ****     EEPROM_write(EE_OFFHOUR,12+i);
 528               		.loc 1 207 0 is_stmt 1
 529               		.cfi_startproc
 530               	.LVL52:
 531               	/* prologue: function */
 532               	/* frame size = 0 */
 533               	/* stack size = 0 */
 534               	.L__stack_usage = 0
 208:Menu.c        **** }
 535               		.loc 1 208 0
 536 01ae 6CE0      		ldi r22,lo8(12)
 537 01b0 680F      		add r22,r24
 538 01b2 83E0      		ldi r24,lo8(3)
 539               	.LVL53:
 540 01b4 00C0      		rjmp EEPROM_write
 541               	.LVL54:
 542               		.cfi_endproc
 543               	.LFE17:
 545               	.global	MsetNightOn
 547               	MsetNightOn:
 548               	.LFB18:
 210:Menu.c        ****     EEPROM_write(EE_ONHOUR,1+i);
 549               		.loc 1 210 0
 550               		.cfi_startproc
 551               	.LVL55:
 552               	/* prologue: function */
 553               	/* frame size = 0 */
 554               	/* stack size = 0 */
 555               	.L__stack_usage = 0
 211:Menu.c        **** }
 556               		.loc 1 211 0
 557 01b6 61E0      		ldi r22,lo8(1)
 558 01b8 680F      		add r22,r24
 559 01ba 82E0      		ldi r24,lo8(2)
 560               	.LVL56:
 561 01bc 00C0      		rjmp EEPROM_write
 562               	.LVL57:
 563               		.cfi_endproc
 564               	.LFE18:
 566               	.global	MsetEventMode
 568               	MsetEventMode:
 569               	.LFB23:
 225:Menu.c        ****     if(i<2)EEPROM_write(EE_EVENT,1-i);//1 for active
 570               		.loc 1 225 0
 571               		.cfi_startproc
 572               	.LVL58:
 573               	/* prologue: function */
 574               	/* frame size = 0 */
 575               	/* stack size = 0 */
 576               	.L__stack_usage = 0
 226:Menu.c        **** }
 577               		.loc 1 226 0
 578 01be 8230      		cpi r24,lo8(2)
 579 01c0 00F4      		brsh .L31
 580               	.LVL59:
 581               	.LBB52:
 582               	.LBB53:
 583 01c2 61E0      		ldi r22,lo8(1)
 584 01c4 681B      		sub r22,r24
 585 01c6 85E0      		ldi r24,lo8(5)
 586               	.LVL60:
 587 01c8 00C0      		rjmp EEPROM_write
 588               	.LVL61:
 589               	.L31:
 590 01ca 0895      		ret
 591               	.LBE53:
 592               	.LBE52:
 593               		.cfi_endproc
 594               	.LFE23:
 596               	.global	Mreset
 598               	Mreset:
 599               	.LFB24:
 228:Menu.c        ****     if(i<1){
 600               		.loc 1 228 0
 601               		.cfi_startproc
 602               	.LVL62:
 603               	/* prologue: function */
 604               	/* frame size = 0 */
 605               	/* stack size = 0 */
 606               	.L__stack_usage = 0
 229:Menu.c        ****         MsetMode(1);
 607               		.loc 1 229 0
 608 01cc 8111      		cpse r24,__zero_reg__
 609 01ce 00C0      		rjmp .L33
 610               	.LVL63:
 611               	.LBB60:
 612               	.LBB61:
 613               	.LBB62:
 614               	.LBB63:
 615               	.LBB64:
 163:Menu.c        ****         if(i==2)TCCR1B&=~(1<<CS10);
 616               		.loc 1 163 0
 617 01d0 8EB5      		in r24,0x2e
 618               	.LVL64:
 619 01d2 8560      		ori r24,lo8(5)
 620 01d4 8EBD      		out 0x2e,r24
 165:Menu.c        ****         EEPROM_write(EE_MODE,i);
 621               		.loc 1 165 0
 622 01d6 81E0      		ldi r24,lo8(1)
 623 01d8 8093 0000 		sts mode,r24
 166:Menu.c        ****     }
 624               		.loc 1 166 0
 625 01dc 61E0      		ldi r22,lo8(1)
 626 01de 84E0      		ldi r24,lo8(4)
 627 01e0 00D0      		rcall EEPROM_write
 628               	.LVL65:
 629               	.LBE64:
 630               	.LBE63:
 631               	.LBE62:
 231:Menu.c        ****         EEPROM_write(EE_NIGHTMODE,1);
 632               		.loc 1 231 0
 633 01e2 80E0      		ldi r24,0
 634 01e4 00D0      		rcall MsetColorMode
 635               	.LVL66:
 232:Menu.c        ****         EEPROM_write(EE_OFFHOUR,12+10);
 636               		.loc 1 232 0
 637 01e6 61E0      		ldi r22,lo8(1)
 638 01e8 81E0      		ldi r24,lo8(1)
 639 01ea 00D0      		rcall EEPROM_write
 640               	.LVL67:
 233:Menu.c        ****         EEPROM_write(EE_ONHOUR,1+8);
 641               		.loc 1 233 0
 642 01ec 66E1      		ldi r22,lo8(22)
 643 01ee 83E0      		ldi r24,lo8(3)
 644 01f0 00D0      		rcall EEPROM_write
 645               	.LVL68:
 234:Menu.c        ****         TCCR1B|=(1<<CS12)|(1<<CS10);
 646               		.loc 1 234 0
 647 01f2 69E0      		ldi r22,lo8(9)
 648 01f4 82E0      		ldi r24,lo8(2)
 649 01f6 00D0      		rcall EEPROM_write
 650               	.LVL69:
 235:Menu.c        ****     }
 651               		.loc 1 235 0
 652 01f8 8EB5      		in r24,0x2e
 653 01fa 8560      		ori r24,lo8(5)
 654 01fc 8EBD      		out 0x2e,r24
 655               	.LVL70:
 656               	.L33:
 657 01fe 0895      		ret
 658               	.LBE61:
 659               	.LBE60:
 660               		.cfi_endproc
 661               	.LFE24:
 663               	.global	EEPROM_read
 665               	EEPROM_read:
 666               	.LFB9:
  23:Menu.c        ****     while(EECR & (1<<EEPE));
 667               		.loc 1 23 0
 668               		.cfi_startproc
 669               	/* prologue: function */
 670               	/* frame size = 0 */
 671               	/* stack size = 0 */
 672               	.L__stack_usage = 0
 673               	.LVL71:
 674               	.L36:
  24:Menu.c        ****     EEAR = addr;
 675               		.loc 1 24 0 discriminator 1
 676 0200 E199      		sbic 0x1c,1
 677 0202 00C0      		rjmp .L36
  25:Menu.c        ****     EECR |= (1<<EERE);
 678               		.loc 1 25 0
 679 0204 90E0      		ldi r25,0
 680 0206 9FBB      		out 0x1e+1,r25
 681 0208 8EBB      		out 0x1e,r24
  26:Menu.c        ****     return EEDR;
 682               		.loc 1 26 0
 683 020a E09A      		sbi 0x1c,0
  27:Menu.c        **** }
 684               		.loc 1 27 0
 685 020c 8DB3      		in r24,0x1d
 686               	.LVL72:
  28:Menu.c        **** 
 687               		.loc 1 28 0
 688 020e 0895      		ret
 689               		.cfi_endproc
 690               	.LFE9:
 692               	.global	Minit
 694               	Minit:
 695               	.LFB10:
  30:Menu.c        ****     colorMode=EEPROM_read(EE_COLOR);
 696               		.loc 1 30 0
 697               		.cfi_startproc
 698               	/* prologue: function */
 699               	/* frame size = 0 */
 700               	/* stack size = 0 */
 701               	.L__stack_usage = 0
  31:Menu.c        ****     mode=EEPROM_read(EE_MODE);
 702               		.loc 1 31 0
 703 0210 80E0      		ldi r24,0
 704 0212 00D0      		rcall EEPROM_read
 705               	.LVL73:
 706 0214 8093 0000 		sts colorMode,r24
  32:Menu.c        ****     MsetMode(EEPROM_read(EE_MODE));
 707               		.loc 1 32 0
 708 0218 84E0      		ldi r24,lo8(4)
 709 021a 00D0      		rcall EEPROM_read
 710               	.LVL74:
 711 021c 8093 0000 		sts mode,r24
  33:Menu.c        **** }
 712               		.loc 1 33 0
 713 0220 84E0      		ldi r24,lo8(4)
 714 0222 00D0      		rcall EEPROM_read
 715               	.LVL75:
 716 0224 00C0      		rjmp MsetMode
 717               	.LVL76:
 718               		.cfi_endproc
 719               	.LFE10:
 721               	.global	getMode
 723               	getMode:
 724               	.LFB12:
 169:Menu.c        ****     if(mode==2){
 725               		.loc 1 169 0
 726               		.cfi_startproc
 727               	/* prologue: function */
 728               	/* frame size = 0 */
 729               	/* stack size = 0 */
 730               	.L__stack_usage = 0
 170:Menu.c        ****         mode=1;
 731               		.loc 1 170 0
 732 0226 8091 0000 		lds r24,mode
 733 022a 8230      		cpi r24,lo8(2)
 734 022c 01F4      		brne .L40
 171:Menu.c        ****     }else if(mode==1){
 735               		.loc 1 171 0
 736 022e 81E0      		ldi r24,lo8(1)
 737 0230 00C0      		rjmp .L42
 738               	.L40:
 172:Menu.c        ****         mode=2;
 739               		.loc 1 172 0
 740 0232 8130      		cpi r24,lo8(1)
 741 0234 01F4      		brne .L41
 173:Menu.c        ****     }
 742               		.loc 1 173 0
 743 0236 82E0      		ldi r24,lo8(2)
 744               	.L42:
 745 0238 8093 0000 		sts mode,r24
 746               	.L41:
 176:Menu.c        **** void MsetColorMode(uint8_t i){
 747               		.loc 1 176 0
 748 023c 8091 0000 		lds r24,mode
 749 0240 0895      		ret
 750               		.cfi_endproc
 751               	.LFE12:
 753               	.global	getColor
 755               	getColor:
 756               	.LFB14:
 189:Menu.c        ****     if(colorMode>127){//cycle single
 757               		.loc 1 189 0
 758               		.cfi_startproc
 759               	/* prologue: function */
 760               	/* frame size = 0 */
 761               	/* stack size = 0 */
 762               	.L__stack_usage = 0
 190:Menu.c        ****         if(colorMode>134)colorMode=128;
 763               		.loc 1 190 0
 764 0242 8091 0000 		lds r24,colorMode
 765 0246 87FF      		sbrs r24,7
 766 0248 00C0      		rjmp .L44
 191:Menu.c        ****         colorMode++;
 767               		.loc 1 191 0
 768 024a 8738      		cpi r24,lo8(-121)
 769 024c 00F0      		brlo .L45
 191:Menu.c        ****         colorMode++;
 770               		.loc 1 191 0 is_stmt 0 discriminator 1
 771 024e 80E8      		ldi r24,lo8(-128)
 772 0250 8093 0000 		sts colorMode,r24
 773               	.L45:
 192:Menu.c        ****         return colorArray[colorMode-129];
 774               		.loc 1 192 0 is_stmt 1
 775 0254 E091 0000 		lds r30,colorMode
 776 0258 EF5F      		subi r30,lo8(-(1))
 777 025a E093 0000 		sts colorMode,r30
 193:Menu.c        ****     }else if(colorMode>63){//cycle all
 778               		.loc 1 193 0
 779 025e F0E0      		ldi r31,0
 780 0260 E050      		subi r30,lo8(-(colorArray-129))
 781 0262 F040      		sbci r31,hi8(-(colorArray-129))
 782 0264 8081      		ld r24,Z
 783 0266 0895      		ret
 784               	.L44:
 194:Menu.c        ****         return RED;
 785               		.loc 1 194 0
 786 0268 8034      		cpi r24,lo8(64)
 787 026a 00F0      		brlo .L46
 195:Menu.c        ****     }else{//fixed
 788               		.loc 1 195 0
 789 026c 84E0      		ldi r24,lo8(4)
 790               	.L46:
 199:Menu.c        **** void MsetNightMode(uint8_t i){
 791               		.loc 1 199 0
 792 026e 0895      		ret
 793               		.cfi_endproc
 794               	.LFE14:
 796               	.global	isInAllowedTime
 798               	isInAllowedTime:
 799               	.LFB16:
 203:Menu.c        ****     if(EEPROM_read(EE_NIGHTMODE))return (h>=EEPROM_read(EE_ONHOUR) && h<=EEPROM_read(EE_OFFHOUR));
 800               		.loc 1 203 0
 801               		.cfi_startproc
 802               	.LVL77:
 803 0270 CF93      		push r28
 804               	.LCFI0:
 805               		.cfi_def_cfa_offset 3
 806               		.cfi_offset 28, -2
 807               	/* prologue: function */
 808               	/* frame size = 0 */
 809               	/* stack size = 1 */
 810               	.L__stack_usage = 1
 811 0272 C82F      		mov r28,r24
 204:Menu.c        ****     return 1;
 812               		.loc 1 204 0
 813 0274 81E0      		ldi r24,lo8(1)
 814               	.LVL78:
 815 0276 00D0      		rcall EEPROM_read
 816               	.LVL79:
 817 0278 8823      		tst r24
 818 027a 01F0      		breq .L52
 204:Menu.c        ****     return 1;
 819               		.loc 1 204 0 is_stmt 0 discriminator 1
 820 027c 82E0      		ldi r24,lo8(2)
 821 027e 00D0      		rcall EEPROM_read
 822               	.LVL80:
 823 0280 C817      		cp r28,r24
 824 0282 00F0      		brlo .L53
 204:Menu.c        ****     return 1;
 825               		.loc 1 204 0 discriminator 2
 826 0284 83E0      		ldi r24,lo8(3)
 827 0286 00D0      		rcall EEPROM_read
 828               	.LVL81:
 829 0288 91E0      		ldi r25,lo8(1)
 830 028a 8C17      		cp r24,r28
 831 028c 00F4      		brsh .L51
 832 028e 90E0      		ldi r25,0
 833               	.L51:
 834 0290 892F      		mov r24,r25
 835 0292 00C0      		rjmp .L49
 836               	.L53:
 204:Menu.c        ****     return 1;
 837               		.loc 1 204 0
 838 0294 80E0      		ldi r24,0
 839 0296 00C0      		rjmp .L49
 840               	.L52:
 205:Menu.c        **** }
 841               		.loc 1 205 0 is_stmt 1
 842 0298 81E0      		ldi r24,lo8(1)
 843               	.L49:
 844               	/* epilogue start */
 206:Menu.c        **** void MsetNightOff(uint8_t i){
 845               		.loc 1 206 0
 846 029a CF91      		pop r28
 847               	.LVL82:
 848 029c 0895      		ret
 849               		.cfi_endproc
 850               	.LFE16:
 852               	.global	colorMode
 853               		.section .bss
 856               	colorMode:
 857 0000 00        		.zero	1
 858               	.global	mode
 859               		.data
 862               	mode:
 863 0000 01        		.byte	1
 864               	.global	M1rainbow
 865               		.section	.rodata
 868               	M1rainbow:
 869 0000 33        		.byte	51
 870 0001 0000      		.word	gs(MsetRainbow)
 871 0003 07        		.byte	7
 872 0004 0000      		.word	0
 873 0006 08        		.byte	8
 874 0007 0000      		.word	0
 875 0009 0F        		.byte	15
 876 000a 0000      		.word	M0main
 877               	.global	M1reset
 880               	M1reset:
 881 000c 42        		.byte	66
 882 000d 0000      		.word	gs(Mreset)
 883 000f 12        		.byte	18
 884 0010 0000      		.word	0
 885 0012 0F        		.byte	15
 886 0013 0000      		.word	M0main
 887               	.global	M1eventMode
 890               	M1eventMode:
 891 0015 13        		.byte	19
 892 0016 0000      		.word	gs(MsetEventMode)
 893 0018 07        		.byte	7
 894 0019 0000      		.word	0
 895 001b 08        		.byte	8
 896 001c 0000      		.word	0
 897 001e 0F        		.byte	15
 898 001f 0000      		.word	M0main
 899               	.global	M2setminpm
 902               	M2setminpm:
 903 0021 24        		.byte	36
 904 0022 0000      		.word	gs(MsetMinpm)
 905 0024 05        		.byte	5
 906 0025 0000      		.word	0
 907 0027 0B        		.byte	11
 908 0028 0000      		.word	0
 909 002a 01        		.byte	1
 910 002b 0000      		.word	0
 911 002d 0F        		.byte	15
 912 002e 0000      		.word	M1setTime
 913               	.global	M2setminam
 916               	M2setminam:
 917 0030 24        		.byte	36
 918 0031 0000      		.word	gs(MsetMinam)
 919 0033 05        		.byte	5
 920 0034 0000      		.word	0
 921 0036 0B        		.byte	11
 922 0037 0000      		.word	0
 923 0039 01        		.byte	1
 924 003a 0000      		.word	0
 925 003c 0F        		.byte	15
 926 003d 0000      		.word	M1setTime
 927               	.global	M2sethourpm
 930               	M2sethourpm:
 931 003f 4C        		.byte	76
 932 0040 0000      		.word	gs(MsetHourpm)
 933 0042 07        		.byte	7
 934 0043 0000      		.word	0
 935 0045 08        		.byte	8
 936 0046 0000      		.word	0
 937 0048 0A        		.byte	10
 938 0049 0000      		.word	0
 939 004b 0E        		.byte	14
 940 004c 0000      		.word	0
 941 004e 00        		.byte	0
 942 004f 0000      		.word	0
 943 0051 04        		.byte	4
 944 0052 0000      		.word	0
 945 0054 11        		.byte	17
 946 0055 0000      		.word	0
 947 0057 02        		.byte	2
 948 0058 0000      		.word	0
 949 005a 0C        		.byte	12
 950 005b 0000      		.word	0
 951 005d 06        		.byte	6
 952 005e 0000      		.word	0
 953 0060 10        		.byte	16
 954 0061 0000      		.word	0
 955 0063 0F        		.byte	15
 956 0064 0000      		.word	M1setTime
 957               	.global	M2sethouram
 960               	M2sethouram:
 961 0066 4D        		.byte	77
 962 0067 0000      		.word	gs(MsetHouram)
 963 0069 07        		.byte	7
 964 006a 0000      		.word	0
 965 006c 08        		.byte	8
 966 006d 0000      		.word	0
 967 006f 0A        		.byte	10
 968 0070 0000      		.word	0
 969 0072 0E        		.byte	14
 970 0073 0000      		.word	0
 971 0075 00        		.byte	0
 972 0076 0000      		.word	0
 973 0078 04        		.byte	4
 974 0079 0000      		.word	0
 975 007b 11        		.byte	17
 976 007c 0000      		.word	0
 977 007e 02        		.byte	2
 978 007f 0000      		.word	0
 979 0081 0C        		.byte	12
 980 0082 0000      		.word	0
 981 0084 06        		.byte	6
 982 0085 0000      		.word	0
 983 0087 10        		.byte	16
 984 0088 0000      		.word	0
 985 008a 0D        		.byte	13
 986 008b 0000      		.word	0
 987 008d 0F        		.byte	15
 988 008e 0000      		.word	M1setTime
 989               	.global	M1setTime
 992               	M1setTime:
 993 0090 65        		.byte	101
 994 0091 0000      		.word	0
 995 0093 07        		.byte	7
 996 0094 0000      		.word	M2sethouram
 997 0096 08        		.byte	8
 998 0097 0000      		.word	M2sethourpm
 999 0099 0A        		.byte	10
 1000 009a 0000      		.word	M2setminam
 1001 009c 0E        		.byte	14
 1002 009d 0000      		.word	M2setminpm
 1003 009f 0F        		.byte	15
 1004 00a0 0000      		.word	M0main
 1005               	.global	M3onhour
 1008               	M3onhour:
 1009 00a2 5C        		.byte	92
 1010 00a3 0000      		.word	gs(MsetNightOn)
 1011 00a5 07        		.byte	7
 1012 00a6 0000      		.word	0
 1013 00a8 08        		.byte	8
 1014 00a9 0000      		.word	0
 1015 00ab 0A        		.byte	10
 1016 00ac 0000      		.word	0
 1017 00ae 0E        		.byte	14
 1018 00af 0000      		.word	0
 1019 00b1 00        		.byte	0
 1020 00b2 0000      		.word	0
 1021 00b4 04        		.byte	4
 1022 00b5 0000      		.word	0
 1023 00b7 11        		.byte	17
 1024 00b8 0000      		.word	0
 1025 00ba 02        		.byte	2
 1026 00bb 0000      		.word	0
 1027 00bd 0C        		.byte	12
 1028 00be 0000      		.word	0
 1029 00c0 06        		.byte	6
 1030 00c1 0000      		.word	0
 1031 00c3 10        		.byte	16
 1032 00c4 0000      		.word	0
 1033 00c6 0F        		.byte	15
 1034 00c7 0000      		.word	M1nightmode
 1035               	.global	M2offhour
 1038               	M2offhour:
 1039 00c9 4C        		.byte	76
 1040 00ca 0000      		.word	gs(MsetNightOff)
 1041 00cc 07        		.byte	7
 1042 00cd 0000      		.word	M3onhour
 1043 00cf 08        		.byte	8
 1044 00d0 0000      		.word	M3onhour
 1045 00d2 0A        		.byte	10
 1046 00d3 0000      		.word	M3onhour
 1047 00d5 0E        		.byte	14
 1048 00d6 0000      		.word	M3onhour
 1049 00d8 00        		.byte	0
 1050 00d9 0000      		.word	M3onhour
 1051 00db 04        		.byte	4
 1052 00dc 0000      		.word	M3onhour
 1053 00de 11        		.byte	17
 1054 00df 0000      		.word	M3onhour
 1055 00e1 02        		.byte	2
 1056 00e2 0000      		.word	M3onhour
 1057 00e4 0C        		.byte	12
 1058 00e5 0000      		.word	M3onhour
 1059 00e7 06        		.byte	6
 1060 00e8 0000      		.word	M3onhour
 1061 00ea 10        		.byte	16
 1062 00eb 0000      		.word	M3onhour
 1063 00ed 0F        		.byte	15
 1064 00ee 0000      		.word	M1nightmode
 1065               	.global	M1nightmode
 1068               	M1nightmode:
 1069 00f0 34        		.byte	52
 1070 00f1 0000      		.word	gs(MsetNightMode)
 1071 00f3 07        		.byte	7
 1072 00f4 0000      		.word	0
 1073 00f6 08        		.byte	8
 1074 00f7 0000      		.word	M2offhour
 1075 00f9 0A        		.byte	10
 1076 00fa 0000      		.word	M2offhour
 1077 00fc 0F        		.byte	15
 1078 00fd 0000      		.word	M0main
 1079               	.global	M1cmode
 1082               	M1cmode:
 1083 00ff 2A        		.byte	42
 1084 0100 0000      		.word	gs(MsetColorMode)
 1085 0102 07        		.byte	7
 1086 0103 0000      		.word	0
 1087 0105 08        		.byte	8
 1088 0106 0000      		.word	0
 1089 0108 0A        		.byte	10
 1090 0109 0000      		.word	0
 1091 010b 0E        		.byte	14
 1092 010c 0000      		.word	0
 1093 010e 00        		.byte	0
 1094 010f 0000      		.word	0
 1095 0111 04        		.byte	4
 1096 0112 0000      		.word	0
 1097 0114 11        		.byte	17
 1098 0115 0000      		.word	0
 1099 0117 02        		.byte	2
 1100 0118 0000      		.word	0
 1101 011a 0C        		.byte	12
 1102 011b 0000      		.word	0
 1103 011d 0F        		.byte	15
 1104 011e 0000      		.word	M0main
 1105               	.global	M1mode
 1108               	M1mode:
 1109 0120 15        		.byte	21
 1110 0121 0000      		.word	gs(MsetMode)
 1111 0123 07        		.byte	7
 1112 0124 0000      		.word	0
 1113 0126 08        		.byte	8
 1114 0127 0000      		.word	0
 1115 0129 0A        		.byte	10
 1116 012a 0000      		.word	0
 1117 012c 0E        		.byte	14
 1118 012d 0000      		.word	0
 1119 012f 0F        		.byte	15
 1120 0130 0000      		.word	M0main
 1121               	.global	M0main
 1124               	M0main:
 1125 0132 08        		.byte	8
 1126 0133 0000      		.word	0
 1127 0135 07        		.byte	7
 1128 0136 0000      		.word	M1mode
 1129 0138 08        		.byte	8
 1130 0139 0000      		.word	M1cmode
 1131 013b 0A        		.byte	10
 1132 013c 0000      		.word	M1nightmode
 1133 013e 0E        		.byte	14
 1134 013f 0000      		.word	M1setTime
 1135 0141 00        		.byte	0
 1136 0142 0000      		.word	M1eventMode
 1137 0144 04        		.byte	4
 1138 0145 0000      		.word	M1reset
 1139 0147 11        		.byte	17
 1140 0148 0000      		.word	M1rainbow
 1141 014a 0F        		.byte	15
 1142 014b 0000      		.word	0
 1143               		.comm	USI_I2C_Master_State,1,1
 1144               		.comm	currentTime,5,1
 1147               	colorArray:
 1148 014d 07        		.byte	7
 1149 014e 03        		.byte	3
 1150 014f 01        		.byte	1
 1151 0150 05        		.byte	5
 1152 0151 04        		.byte	4
 1153 0152 06        		.byte	6
 1154 0153 02        		.byte	2
 1155               		.text
 1156               	.Letext0:
 1157               		.file 3 "/usr/lib/avr/include/stdint.h"
 1158               		.file 4 "RTC.h"
 1159               		.file 5 "Menu.h"
 1160               		.file 6 "Led.h"
 1161               		.file 7 "defines.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Menu.c
     /tmp/cciPbcjr.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cciPbcjr.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cciPbcjr.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cciPbcjr.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cciPbcjr.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cciPbcjr.s:12     .text:0000000000000000 MsetHouram
     /tmp/cciPbcjr.s:37     .text:000000000000000a MsetHourpm
     /tmp/cciPbcjr.s:61     .text:0000000000000014 MsetRainbow
     /tmp/cciPbcjr.s:862    .data:0000000000000000 mode
     /tmp/cciPbcjr.s:239    .text:00000000000000e4 MsetMinam
     /tmp/cciPbcjr.s:270    .text:00000000000000f2 MsetMinpm
     /tmp/cciPbcjr.s:302    .text:0000000000000102 findNextEntry
     /tmp/cciPbcjr.s:338    .text:0000000000000122 getSubMenu
     /tmp/cciPbcjr.s:369    .text:000000000000013a EEPROM_write
     /tmp/cciPbcjr.s:400    .text:000000000000014e MsetMode
     /tmp/cciPbcjr.s:443    .text:000000000000016e MsetColorMode
     /tmp/cciPbcjr.s:1147   .rodata:000000000000014d colorArray
     /tmp/cciPbcjr.s:856    .bss:0000000000000000 colorMode
     /tmp/cciPbcjr.s:501    .text:00000000000001a2 MsetNightMode
     /tmp/cciPbcjr.s:526    .text:00000000000001ae MsetNightOff
     /tmp/cciPbcjr.s:547    .text:00000000000001b6 MsetNightOn
     /tmp/cciPbcjr.s:568    .text:00000000000001be MsetEventMode
     /tmp/cciPbcjr.s:598    .text:00000000000001cc Mreset
     /tmp/cciPbcjr.s:665    .text:0000000000000200 EEPROM_read
     /tmp/cciPbcjr.s:694    .text:0000000000000210 Minit
     /tmp/cciPbcjr.s:723    .text:0000000000000226 getMode
     /tmp/cciPbcjr.s:755    .text:0000000000000242 getColor
     /tmp/cciPbcjr.s:798    .text:0000000000000270 isInAllowedTime
     /tmp/cciPbcjr.s:868    .rodata:0000000000000000 M1rainbow
     /tmp/cciPbcjr.s:1124   .rodata:0000000000000132 M0main
     /tmp/cciPbcjr.s:880    .rodata:000000000000000c M1reset
     /tmp/cciPbcjr.s:890    .rodata:0000000000000015 M1eventMode
     /tmp/cciPbcjr.s:902    .rodata:0000000000000021 M2setminpm
     /tmp/cciPbcjr.s:992    .rodata:0000000000000090 M1setTime
     /tmp/cciPbcjr.s:916    .rodata:0000000000000030 M2setminam
     /tmp/cciPbcjr.s:930    .rodata:000000000000003f M2sethourpm
     /tmp/cciPbcjr.s:960    .rodata:0000000000000066 M2sethouram
     /tmp/cciPbcjr.s:1008   .rodata:00000000000000a2 M3onhour
     /tmp/cciPbcjr.s:1068   .rodata:00000000000000f0 M1nightmode
     /tmp/cciPbcjr.s:1038   .rodata:00000000000000c9 M2offhour
     /tmp/cciPbcjr.s:1082   .rodata:00000000000000ff M1cmode
     /tmp/cciPbcjr.s:1108   .rodata:0000000000000120 M1mode
                            *COM*:0000000000000001 USI_I2C_Master_State
                            *COM*:0000000000000005 currentTime

UNDEFINED SYMBOLS
RTC_setHour
sendRawData
__mulqi3
RTC_setMin
__mulhi3
__do_copy_data
__do_clear_bss
