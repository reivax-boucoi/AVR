   1               		.file	"Menu.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	MsetHouram
  12               	MsetHouram:
  13               	.LFB19:
  14               		.file 1 "Menu.c"
   1:Menu.c        **** #include "Menu.h"
   2:Menu.c        **** 
   3:Menu.c        **** uint8_t mode=1;//0: hour only, 1-2: hour+temp, 3: temp only, >=4:Rainbow !
   4:Menu.c        **** uint8_t colorMode=0;
   5:Menu.c        **** 
   6:Menu.c        **** uint8_t findNextEntry(Menu* m,uint8_t index){
   7:Menu.c        ****     if((index+2)>(m->nb_optn%16))return 0;
   8:Menu.c        ****     return index+1;
   9:Menu.c        **** }
  10:Menu.c        **** 
  11:Menu.c        **** Menu* getSubMenu(Menu* m,uint8_t index){
  12:Menu.c        ****     if(m->sub[index].submenu==0)return 0;//if executed NULL, return blank menu (==exit setup)
  13:Menu.c        ****     return m->sub[index].submenu;
  14:Menu.c        **** }
  15:Menu.c        **** void EEPROM_write(uint8_t addr, uint8_t data){
  16:Menu.c        ****     while(EECR & (1<<EEPE));
  17:Menu.c        ****     EECR = (0<<EEPM1)|(0<<EEPM0);
  18:Menu.c        ****     EEAR = addr;
  19:Menu.c        ****     EEDR = data;
  20:Menu.c        ****     EECR |= (1<<EEMPE);
  21:Menu.c        ****     EECR |= (1<<EEPE);
  22:Menu.c        **** }
  23:Menu.c        **** uint8_t EEPROM_read(uint8_t addr){
  24:Menu.c        ****     while(EECR & (1<<EEPE));
  25:Menu.c        ****     EEAR = addr;
  26:Menu.c        ****     EECR |= (1<<EERE);
  27:Menu.c        ****     return EEDR;
  28:Menu.c        **** }
  29:Menu.c        **** 
  30:Menu.c        **** void Minit(void){
  31:Menu.c        ****     colorMode=EEPROM_read(EE_COLOR);
  32:Menu.c        ****     mode=EEPROM_read(EE_MODE);
  33:Menu.c        ****     MsetMode(EEPROM_read(EE_MODE));
  34:Menu.c        **** }
  35:Menu.c        **** const Menu M0main={8,0,{//WHITE
  36:Menu.c        ****     {7,&M1mode},
  37:Menu.c        ****     {8,&M1cmode},
  38:Menu.c        ****     {10,&M1nightmode},
  39:Menu.c        ****     {14,&M1setTime},
  40:Menu.c        ****     {0,&M1eventMode},
  41:Menu.c        ****     {4,&M1reset},
  42:Menu.c        ****     {17,&M1rainbow},
  43:Menu.c        ****     {HEURE,0}//exit      
  44:Menu.c        **** }};
  45:Menu.c        **** const Menu M1mode={5+16,MsetMode,{//CYAN
  46:Menu.c        ****     {7,0},//Hour only
  47:Menu.c        ****     {8,0},//Hour + temp (slow)
  48:Menu.c        ****     {10,0},//Hour + temp (fast)
  49:Menu.c        ****     {14,0},//temp only
  50:Menu.c        ****     {HEURE,&M0main}//return    
  51:Menu.c        **** }};
  52:Menu.c        **** const Menu M1cmode={10+32,MsetColorMode,{//BLUE
  53:Menu.c        ****     {7,0},//fixed WHITE 1
  54:Menu.c        ****     {8,0},//fixed CYAN 2
  55:Menu.c        ****     {10,0},//fixed BLUE 3
  56:Menu.c        ****     {14,0},//fixed MAGENTA 4
  57:Menu.c        ****     {0,0},//fixed RED 5
  58:Menu.c        ****     {4,0},//fixed YELLOW 6
  59:Menu.c        ****     {17,0},//fixed GREEN 7
  60:Menu.c        ****     {2,0},// cycle single 8
  61:Menu.c        ****     {12,0},// cycle all 9
  62:Menu.c        ****     {HEURE,&M0main}//return    
  63:Menu.c        **** }};
  64:Menu.c        **** const Menu M1nightmode={4+48,MsetNightMode,{//MAGENTA
  65:Menu.c        ****     {7,0},//none
  66:Menu.c        ****     {8,&M2offhour},//Half brightness
  67:Menu.c        ****     {10,&M2offhour},//Off completely
  68:Menu.c        ****     {HEURE,&M0main}//return
  69:Menu.c        **** }};
  70:Menu.c        **** const Menu M2offhour={12+64,MsetNightOff,{//RED
  71:Menu.c        ****     {7,&M3onhour},//heures
  72:Menu.c        ****     {8,&M3onhour},
  73:Menu.c        ****     {10,&M3onhour},
  74:Menu.c        ****     {14,&M3onhour},
  75:Menu.c        ****     {0,&M3onhour},
  76:Menu.c        ****     {4,&M3onhour},
  77:Menu.c        ****     {17,&M3onhour},
  78:Menu.c        ****     {2,&M3onhour},
  79:Menu.c        ****     {12,&M3onhour},
  80:Menu.c        ****     {6,&M3onhour},
  81:Menu.c        ****     {16,&M3onhour},
  82:Menu.c        ****     {HEURE,&M1nightmode}//return
  83:Menu.c        **** }};
  84:Menu.c        **** const Menu M3onhour={12+80,MsetNightOn,{//YELLOW
  85:Menu.c        ****     {7,0},//heures
  86:Menu.c        ****     {8,0},
  87:Menu.c        ****     {10,0},
  88:Menu.c        ****     {14,0},
  89:Menu.c        ****     {0,0},
  90:Menu.c        ****     {4,0},
  91:Menu.c        ****     {17,0},
  92:Menu.c        ****     {2,0},
  93:Menu.c        ****     {12,0},
  94:Menu.c        ****     {6,0},
  95:Menu.c        ****     {16,0},
  96:Menu.c        ****     {HEURE,&M1nightmode}//return
  97:Menu.c        **** }};
  98:Menu.c        **** const Menu M1setTime={5+96,0,{//GREEN
  99:Menu.c        ****     {7,&M2sethouram},//hour am
 100:Menu.c        ****     {8,&M2sethourpm},//hour pm
 101:Menu.c        ****     {10,&M2setminam},//min am
 102:Menu.c        ****     {14,&M2setminpm},//min pm
 103:Menu.c        ****     {HEURE,&M0main}//return
 104:Menu.c        **** }};
 105:Menu.c        **** const Menu M2sethouram={13+64,MsetHouram,{//RED
 106:Menu.c        ****     {7,0},//heure
 107:Menu.c        ****     {8,0},
 108:Menu.c        ****     {10,0},
 109:Menu.c        ****     {14,0},
 110:Menu.c        ****     {0,0},
 111:Menu.c        ****     {4,0},
 112:Menu.c        ****     {17,0},
 113:Menu.c        ****     {2,0},
 114:Menu.c        ****     {12,0},
 115:Menu.c        ****     {6,0},
 116:Menu.c        ****     {16,0},
 117:Menu.c        ****     {MIDI,0},//midi
 118:Menu.c        ****     {HEURE,&M1setTime}//return
 119:Menu.c        **** }};
 120:Menu.c        **** const Menu M2sethourpm={12+64,MsetHourpm,{//RED
 121:Menu.c        ****     {7,0},//heure
 122:Menu.c        ****     {8,0},
 123:Menu.c        ****     {10,0},
 124:Menu.c        ****     {14,0},
 125:Menu.c        ****     {0,0},
 126:Menu.c        ****     {4,0},
 127:Menu.c        ****     {17,0},
 128:Menu.c        ****     {2,0},
 129:Menu.c        ****     {12,0},
 130:Menu.c        ****     {6,0},
 131:Menu.c        ****     {16,0},
 132:Menu.c        ****     {HEURE,&M1setTime}//return
 133:Menu.c        **** }};
 134:Menu.c        **** const Menu M2setminam={4+32,MsetMinam,{//BLUE
 135:Menu.c        ****     {DIX,0},//dix
 136:Menu.c        ****     {VINGT,0},//vingt
 137:Menu.c        ****     {ETDEMIE,0},//1/2
 138:Menu.c        ****     {HEURE,&M1setTime}//return
 139:Menu.c        **** }};
 140:Menu.c        **** const Menu M2setminpm={4+32,MsetMinpm,{//BLUE
 141:Menu.c        ****     {DIX,0},//dix
 142:Menu.c        ****     {VINGT,0},//vingt
 143:Menu.c        ****     {ETDEMIE,0},//1/2
 144:Menu.c        ****     {HEURE,&M1setTime}//return
 145:Menu.c        **** }};
 146:Menu.c        **** const Menu M1eventMode={3+16,MsetEventMode,{//CYAN
 147:Menu.c        ****     {7,0},//Event on
 148:Menu.c        ****     {8,0},//Event off
 149:Menu.c        ****     {HEURE,&M0main}//return
 150:Menu.c        **** }};
 151:Menu.c        **** const Menu M1reset={2+64,Mreset,{//RED
 152:Menu.c        ****     {ILEST,0},//yes
 153:Menu.c        ****     {HEURE,&M0main}//return
 154:Menu.c        **** }};
 155:Menu.c        **** const Menu M1rainbow={3+48,MsetRainbow,{//MAGENTA
 156:Menu.c        ****     {7,0},//Rainbow on
 157:Menu.c        ****     {8,0},//Rainbow off
 158:Menu.c        ****     {HEURE,&M0main}//return
 159:Menu.c        **** }};
 160:Menu.c        **** 
 161:Menu.c        **** void MsetMode(uint8_t i){
 162:Menu.c        ****    if(i<4){
 163:Menu.c        ****         TCCR1B|=(1<<CS12)|(1<<CS10);
 164:Menu.c        ****         if(i==2)TCCR1B&=~(1<<CS10);
 165:Menu.c        ****         mode=i;
 166:Menu.c        ****         EEPROM_write(EE_MODE,i);
 167:Menu.c        ****     }
 168:Menu.c        **** }
 169:Menu.c        **** uint8_t getMode(void){
 170:Menu.c        ****     if(mode==2){
 171:Menu.c        ****         mode=1;
 172:Menu.c        ****     }else if(mode==1){
 173:Menu.c        ****         mode=2;
 174:Menu.c        ****     }
 175:Menu.c        ****     if(colorMode>63 && colorMode<128){
 176:Menu.c        ****         colorMode=((colorMode-64+1)%7)+64;
 177:Menu.c        ****     }
 178:Menu.c        ****     return mode;
 179:Menu.c        **** }
 180:Menu.c        **** void MsetColorMode(uint8_t i){
 181:Menu.c        ****     if(i<7){
 182:Menu.c        ****         colorMode=colorArray[i];//fixed
 183:Menu.c        ****         EEPROM_write(EE_COLOR,colorArray[i]);
 184:Menu.c        ****     }else if(i==7){//cycle single
 185:Menu.c        ****         colorMode=WHITE+128;
 186:Menu.c        ****         EEPROM_write(EE_COLOR,128);
 187:Menu.c        ****     }else if(i==8){//cycle all
 188:Menu.c        ****         colorMode=WHITE+64;
 189:Menu.c        ****         EEPROM_write(EE_COLOR,64);
 190:Menu.c        ****     }
 191:Menu.c        **** }
 192:Menu.c        **** uint8_t getColor(void){
 193:Menu.c        ****     if(colorMode>127){//cycle single
 194:Menu.c        ****         if(colorMode>134)colorMode=128;
 195:Menu.c        ****         colorMode++;
 196:Menu.c        ****         return colorArray[colorMode-129];
 197:Menu.c        ****     }else if(colorMode>63){//cycle all
 198:Menu.c        ****         return colorArray[colorMode-64];
 199:Menu.c        ****     }else{//fixed
 200:Menu.c        ****         return colorMode;
 201:Menu.c        ****     }
 202:Menu.c        **** }
 203:Menu.c        **** void MsetNightMode(uint8_t i){
 204:Menu.c        ****     if(i<3)EEPROM_write(EE_NIGHTMODE,i);
 205:Menu.c        **** }
 206:Menu.c        **** uint8_t isInAllowedTime(uint8_t h){
 207:Menu.c        ****     if(EEPROM_read(EE_NIGHTMODE))return (h>=EEPROM_read(EE_ONHOUR) && h<=EEPROM_read(EE_OFFHOUR));
 208:Menu.c        ****     return 1;
 209:Menu.c        **** }
 210:Menu.c        **** void MsetNightOff(uint8_t i){
 211:Menu.c        ****     EEPROM_write(EE_OFFHOUR,12+i);
 212:Menu.c        **** }
 213:Menu.c        **** void MsetNightOn(uint8_t i){
 214:Menu.c        ****     EEPROM_write(EE_ONHOUR,1+i);
 215:Menu.c        **** }
 216:Menu.c        **** void MsetHouram(uint8_t i){
  15               		.loc 1 216 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 217:Menu.c        ****    if(i<12)RTC_setHour(i+1);
  22               		.loc 1 217 0
  23 0000 8C30      		cpi r24,lo8(12)
  24 0002 00F4      		brsh .L1
  25               		.loc 1 217 0 is_stmt 0 discriminator 1
  26 0004 8F5F      		subi r24,lo8(-(1))
  27               	.LVL1:
  28 0006 00C0      		rjmp RTC_setHour
  29               	.LVL2:
  30               	.L1:
  31 0008 0895      		ret
  32               		.cfi_endproc
  33               	.LFE19:
  35               	.global	MsetHourpm
  37               	MsetHourpm:
  38               	.LFB20:
 218:Menu.c        **** }
 219:Menu.c        **** void MsetHourpm(uint8_t i){
  39               		.loc 1 219 0 is_stmt 1
  40               		.cfi_startproc
  41               	.LVL3:
  42               	/* prologue: function */
  43               	/* frame size = 0 */
  44               	/* stack size = 0 */
  45               	.L__stack_usage = 0
 220:Menu.c        ****    if(i<11)RTC_setHour(i+13);    
  46               		.loc 1 220 0
  47 000a 8B30      		cpi r24,lo8(11)
  48 000c 00F4      		brsh .L4
  49               		.loc 1 220 0 is_stmt 0 discriminator 1
  50 000e 835F      		subi r24,lo8(-(13))
  51               	.LVL4:
  52 0010 00C0      		rjmp RTC_setHour
  53               	.LVL5:
  54               	.L4:
  55 0012 0895      		ret
  56               		.cfi_endproc
  57               	.LFE20:
  59               	.global	MsetRainbow
  61               	MsetRainbow:
  62               	.LFB25:
 221:Menu.c        **** }
 222:Menu.c        **** void MsetMinam(uint8_t i){
 223:Menu.c        ****     if(i<3)RTC_setMin((i+1)*10);
 224:Menu.c        ****     }
 225:Menu.c        **** void MsetMinpm(uint8_t i){
 226:Menu.c        ****     if(i<3)RTC_setMin(60-(i+1)*10);
 227:Menu.c        **** }
 228:Menu.c        **** void MsetEventMode(uint8_t i){
 229:Menu.c        ****     if(i<2)EEPROM_write(EE_EVENT,1-i);//1 for active
 230:Menu.c        **** }
 231:Menu.c        **** void Mreset(uint8_t i){
 232:Menu.c        ****     if(i<1){
 233:Menu.c        ****         MsetMode(1);
 234:Menu.c        ****         MsetColorMode(128);
 235:Menu.c        ****         EEPROM_write(EE_NIGHTMODE,1);
 236:Menu.c        ****         EEPROM_write(EE_OFFHOUR,12+10);
 237:Menu.c        ****         EEPROM_write(EE_ONHOUR,1+8);
 238:Menu.c        ****         TCCR1B|=(1<<CS12)|(1<<CS10);
 239:Menu.c        ****     }
 240:Menu.c        **** }
 241:Menu.c        **** 
 242:Menu.c        **** void MsetRainbow(uint8_t i){
  63               		.loc 1 242 0 is_stmt 1
  64               		.cfi_startproc
  65               	.LVL6:
  66               	/* prologue: function */
  67               	/* frame size = 0 */
  68               	/* stack size = 0 */
  69               	.L__stack_usage = 0
 243:Menu.c        ****     if(i<2)mode=4;
  70               		.loc 1 243 0
  71 0014 8230      		cpi r24,lo8(2)
  72 0016 00F4      		brsh .L7
  73               		.loc 1 243 0 is_stmt 0 discriminator 1
  74 0018 84E0      		ldi r24,lo8(4)
  75               	.LVL7:
  76 001a 8093 0000 		sts mode,r24
  77               	.L7:
 244:Menu.c        ****   //  cli();
 245:Menu.c        ****     sendRawData(0b11111100001111111111);//white
  78               		.loc 1 245 0 is_stmt 1
  79 001e 6FEF      		ldi r22,lo8(-1)
  80 0020 73EC      		ldi r23,lo8(-61)
  81 0022 8FE0      		ldi r24,lo8(15)
  82 0024 90E0      		ldi r25,0
  83 0026 00D0      		rcall sendRawData
  84               	.LVL8:
  85               	.LBB22:
  86               	.LBB23:
  87               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  88               		.loc 2 187 0
  89 0028 2FEF      		ldi r18,lo8(1599999)
  90 002a 89E6      		ldi r24,hi8(1599999)
  91 002c 98E1      		ldi r25,hlo8(1599999)
  92 002e 2150      	1:	subi r18,1
  93 0030 8040      		sbci r24,0
  94 0032 9040      		sbci r25,0
  95 0034 01F4      		brne 1b
  96 0036 00C0      		rjmp .
  97 0038 0000      		nop
  98               	.LVL9:
  99               	.LBE23:
 100               	.LBE22:
 246:Menu.c        ****     _delay_ms(500);
 247:Menu.c        ****     sendRawData(0b11000000001111111111);//green
 101               		.loc 1 247 0
 102 003a 6FEF      		ldi r22,lo8(-1)
 103 003c 73E0      		ldi r23,lo8(3)
 104 003e 8CE0      		ldi r24,lo8(12)
 105 0040 90E0      		ldi r25,0
 106 0042 00D0      		rcall sendRawData
 107               	.LVL10:
 108               	.LBB24:
 109               	.LBB25:
 110               		.loc 2 187 0
 111 0044 2FEF      		ldi r18,lo8(1599999)
 112 0046 89E6      		ldi r24,hi8(1599999)
 113 0048 98E1      		ldi r25,hlo8(1599999)
 114 004a 2150      	1:	subi r18,1
 115 004c 8040      		sbci r24,0
 116 004e 9040      		sbci r25,0
 117 0050 01F4      		brne 1b
 118 0052 00C0      		rjmp .
 119 0054 0000      		nop
 120               	.LVL11:
 121               	.LBE25:
 122               	.LBE24:
 248:Menu.c        ****     _delay_ms(500);
 249:Menu.c        ****     sendRawData(0b00001100001111111111);//red
 123               		.loc 1 249 0
 124 0056 8FEF      		ldi r24,lo8(-1)
 125 0058 93EC      		ldi r25,lo8(-61)
 126 005a 00D0      		rcall sendRawData
 127               	.LVL12:
 128               	.LBB26:
 129               	.LBB27:
 130               		.loc 2 187 0
 131 005c 2FEF      		ldi r18,lo8(1599999)
 132 005e 89E6      		ldi r24,hi8(1599999)
 133 0060 98E1      		ldi r25,hlo8(1599999)
 134 0062 2150      	1:	subi r18,1
 135 0064 8040      		sbci r24,0
 136 0066 9040      		sbci r25,0
 137 0068 01F4      		brne 1b
 138 006a 00C0      		rjmp .
 139 006c 0000      		nop
 140               	.LVL13:
 141               	.LBE27:
 142               	.LBE26:
 250:Menu.c        ****     _delay_ms(500);
 251:Menu.c        ****     sendRawData(0b00110000001111111111);//blue
 143               		.loc 1 251 0
 144 006e 6FEF      		ldi r22,lo8(-1)
 145 0070 73E0      		ldi r23,lo8(3)
 146 0072 83E0      		ldi r24,lo8(3)
 147 0074 90E0      		ldi r25,0
 148 0076 00D0      		rcall sendRawData
 149               	.LVL14:
 150               	.LBB28:
 151               	.LBB29:
 152               		.loc 2 187 0
 153 0078 2FEF      		ldi r18,lo8(1599999)
 154 007a 89E6      		ldi r24,hi8(1599999)
 155 007c 98E1      		ldi r25,hlo8(1599999)
 156 007e 2150      	1:	subi r18,1
 157 0080 8040      		sbci r24,0
 158 0082 9040      		sbci r25,0
 159 0084 01F4      		brne 1b
 160 0086 00C0      		rjmp .
 161 0088 0000      		nop
 162               	.LVL15:
 163               	.LBE29:
 164               	.LBE28:
 252:Menu.c        ****     _delay_ms(500);
 253:Menu.c        ****     sendRawData(0b11110000001111111111);//cyan
 165               		.loc 1 253 0
 166 008a 6FEF      		ldi r22,lo8(-1)
 167 008c 73E0      		ldi r23,lo8(3)
 168 008e 8FE0      		ldi r24,lo8(15)
 169 0090 90E0      		ldi r25,0
 170 0092 00D0      		rcall sendRawData
 171               	.LVL16:
 172               	.LBB30:
 173               	.LBB31:
 174               		.loc 2 187 0
 175 0094 2FEF      		ldi r18,lo8(1599999)
 176 0096 89E6      		ldi r24,hi8(1599999)
 177 0098 98E1      		ldi r25,hlo8(1599999)
 178 009a 2150      	1:	subi r18,1
 179 009c 8040      		sbci r24,0
 180 009e 9040      		sbci r25,0
 181 00a0 01F4      		brne 1b
 182 00a2 00C0      		rjmp .
 183 00a4 0000      		nop
 184               	.LVL17:
 185               	.LBE31:
 186               	.LBE30:
 254:Menu.c        ****     _delay_ms(500);
 255:Menu.c        ****     sendRawData(0b00111100001111111111);//magenta
 187               		.loc 1 255 0
 188 00a6 6FEF      		ldi r22,lo8(-1)
 189 00a8 73EC      		ldi r23,lo8(-61)
 190 00aa 83E0      		ldi r24,lo8(3)
 191 00ac 90E0      		ldi r25,0
 192 00ae 00D0      		rcall sendRawData
 193               	.LVL18:
 194               	.LBB32:
 195               	.LBB33:
 196               		.loc 2 187 0
 197 00b0 2FEF      		ldi r18,lo8(1599999)
 198 00b2 89E6      		ldi r24,hi8(1599999)
 199 00b4 98E1      		ldi r25,hlo8(1599999)
 200 00b6 2150      	1:	subi r18,1
 201 00b8 8040      		sbci r24,0
 202 00ba 9040      		sbci r25,0
 203 00bc 01F4      		brne 1b
 204 00be 00C0      		rjmp .
 205 00c0 0000      		nop
 206               	.LVL19:
 207               	.LBE33:
 208               	.LBE32:
 256:Menu.c        ****     _delay_ms(500);
 257:Menu.c        ****     sendRawData(0b11001100001111111111);//yellow
 209               		.loc 1 257 0
 210 00c2 6FEF      		ldi r22,lo8(-1)
 211 00c4 73EC      		ldi r23,lo8(-61)
 212 00c6 8CE0      		ldi r24,lo8(12)
 213 00c8 90E0      		ldi r25,0
 214 00ca 00D0      		rcall sendRawData
 215               	.LVL20:
 216               	.LBB34:
 217               	.LBB35:
 218               		.loc 2 187 0
 219 00cc 2FEF      		ldi r18,lo8(1599999)
 220 00ce 89E6      		ldi r24,hi8(1599999)
 221 00d0 98E1      		ldi r25,hlo8(1599999)
 222 00d2 2150      	1:	subi r18,1
 223 00d4 8040      		sbci r24,0
 224 00d6 9040      		sbci r25,0
 225 00d8 01F4      		brne 1b
 226 00da 00C0      		rjmp .
 227 00dc 0000      		nop
 228               	.LVL21:
 229 00de 0895      		ret
 230               	.LBE35:
 231               	.LBE34:
 232               		.cfi_endproc
 233               	.LFE25:
 235               	.global	MsetMinam
 237               	MsetMinam:
 238               	.LFB21:
 222:Menu.c        ****     if(i<3)RTC_setMin((i+1)*10);
 239               		.loc 1 222 0
 240               		.cfi_startproc
 241               	.LVL22:
 242               	/* prologue: function */
 243               	/* frame size = 0 */
 244               	/* stack size = 0 */
 245               	.L__stack_usage = 0
 223:Menu.c        ****     }
 246               		.loc 1 223 0
 247 00e0 8330      		cpi r24,lo8(3)
 248 00e2 00F4      		brsh .L8
 249               	.LVL23:
 250               	.LBB38:
 251               	.LBB39:
 252 00e4 8F5F      		subi r24,lo8(-(1))
 253               	.LVL24:
 254 00e6 6AE0      		ldi r22,lo8(10)
 255 00e8 00D0      		rcall __mulqi3
 256               	.LVL25:
 257 00ea 00C0      		rjmp RTC_setMin
 258               	.LVL26:
 259               	.L8:
 260 00ec 0895      		ret
 261               	.LBE39:
 262               	.LBE38:
 263               		.cfi_endproc
 264               	.LFE21:
 266               	.global	MsetMinpm
 268               	MsetMinpm:
 269               	.LFB22:
 225:Menu.c        ****     if(i<3)RTC_setMin(60-(i+1)*10);
 270               		.loc 1 225 0
 271               		.cfi_startproc
 272               	.LVL27:
 273               	/* prologue: function */
 274               	/* frame size = 0 */
 275               	/* stack size = 0 */
 276               	.L__stack_usage = 0
 226:Menu.c        **** }
 277               		.loc 1 226 0
 278 00ee 8330      		cpi r24,lo8(3)
 279 00f0 00F4      		brsh .L10
 280               	.LVL28:
 281               	.LBB42:
 282               	.LBB43:
 283 00f2 8F5F      		subi r24,lo8(-(1))
 284               	.LVL29:
 285 00f4 66EF      		ldi r22,lo8(-10)
 286 00f6 00D0      		rcall __mulqi3
 287               	.LVL30:
 288 00f8 845C      		subi r24,lo8(-(60))
 289 00fa 00C0      		rjmp RTC_setMin
 290               	.LVL31:
 291               	.L10:
 292 00fc 0895      		ret
 293               	.LBE43:
 294               	.LBE42:
 295               		.cfi_endproc
 296               	.LFE22:
 298               	.global	findNextEntry
 300               	findNextEntry:
 301               	.LFB6:
   6:Menu.c        ****     if((index+2)>(m->nb_optn%16))return 0;
 302               		.loc 1 6 0
 303               		.cfi_startproc
 304               	.LVL32:
 305               	/* prologue: function */
 306               	/* frame size = 0 */
 307               	/* stack size = 0 */
 308               	.L__stack_usage = 0
   7:Menu.c        ****     return index+1;
 309               		.loc 1 7 0
 310 00fe 262F      		mov r18,r22
 311 0100 30E0      		ldi r19,0
 312 0102 2F5F      		subi r18,-1
 313 0104 3F4F      		sbci r19,-1
 314 0106 FC01      		movw r30,r24
 315 0108 8081      		ld r24,Z
 316               	.LVL33:
 317 010a 8F70      		andi r24,lo8(15)
 318 010c 90E0      		ldi r25,0
 319 010e 2817      		cp r18,r24
 320 0110 3907      		cpc r19,r25
 321 0112 04F4      		brge .L14
   8:Menu.c        **** }
 322               		.loc 1 8 0
 323 0114 81E0      		ldi r24,lo8(1)
 324 0116 860F      		add r24,r22
 325 0118 0895      		ret
 326               	.L14:
   7:Menu.c        ****     return index+1;
 327               		.loc 1 7 0
 328 011a 80E0      		ldi r24,0
   9:Menu.c        **** 
 329               		.loc 1 9 0
 330 011c 0895      		ret
 331               		.cfi_endproc
 332               	.LFE6:
 334               	.global	getSubMenu
 336               	getSubMenu:
 337               	.LFB7:
  11:Menu.c        ****     if(m->sub[index].submenu==0)return 0;//if executed NULL, return blank menu (==exit setup)
 338               		.loc 1 11 0
 339               		.cfi_startproc
 340               	.LVL34:
 341               	/* prologue: function */
 342               	/* frame size = 0 */
 343               	/* stack size = 0 */
 344               	.L__stack_usage = 0
 345 011e 9C01      		movw r18,r24
  12:Menu.c        ****     return m->sub[index].submenu;
 346               		.loc 1 12 0
 347 0120 862F      		mov r24,r22
 348               	.LVL35:
 349 0122 90E0      		ldi r25,0
 350 0124 63E0      		ldi r22,lo8(3)
 351 0126 70E0      		ldi r23,0
 352               	.LVL36:
 353 0128 00D0      		rcall __mulhi3
 354               	.LVL37:
 355 012a 820F      		add r24,r18
 356 012c 931F      		adc r25,r19
  14:Menu.c        **** void EEPROM_write(uint8_t addr, uint8_t data){
 357               		.loc 1 14 0
 358 012e FC01      		movw r30,r24
 359 0130 8481      		ldd r24,Z+4
 360 0132 9581      		ldd r25,Z+5
 361 0134 0895      		ret
 362               		.cfi_endproc
 363               	.LFE7:
 365               	.global	EEPROM_write
 367               	EEPROM_write:
 368               	.LFB8:
  15:Menu.c        ****     while(EECR & (1<<EEPE));
 369               		.loc 1 15 0
 370               		.cfi_startproc
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 0 */
 374               	.L__stack_usage = 0
 375               	.LVL38:
 376               	.L17:
  16:Menu.c        ****     EECR = (0<<EEPM1)|(0<<EEPM0);
 377               		.loc 1 16 0 discriminator 1
 378 0136 E199      		sbic 0x1c,1
 379 0138 00C0      		rjmp .L17
  17:Menu.c        ****     EEAR = addr;
 380               		.loc 1 17 0
 381 013a 1CBA      		out 0x1c,__zero_reg__
  18:Menu.c        ****     EEDR = data;
 382               		.loc 1 18 0
 383 013c 90E0      		ldi r25,0
 384 013e 9FBB      		out 0x1e+1,r25
 385 0140 8EBB      		out 0x1e,r24
  19:Menu.c        ****     EECR |= (1<<EEMPE);
 386               		.loc 1 19 0
 387 0142 6DBB      		out 0x1d,r22
  20:Menu.c        ****     EECR |= (1<<EEPE);
 388               		.loc 1 20 0
 389 0144 E29A      		sbi 0x1c,2
  21:Menu.c        **** }
 390               		.loc 1 21 0
 391 0146 E19A      		sbi 0x1c,1
 392 0148 0895      		ret
 393               		.cfi_endproc
 394               	.LFE8:
 396               	.global	MsetMode
 398               	MsetMode:
 399               	.LFB11:
 161:Menu.c        ****    if(i<4){
 400               		.loc 1 161 0
 401               		.cfi_startproc
 402               	.LVL39:
 403               	/* prologue: function */
 404               	/* frame size = 0 */
 405               	/* stack size = 0 */
 406               	.L__stack_usage = 0
 162:Menu.c        ****         TCCR1B|=(1<<CS12)|(1<<CS10);
 407               		.loc 1 162 0
 408 014a 8430      		cpi r24,lo8(4)
 409 014c 00F4      		brsh .L19
 410               	.LVL40:
 411               	.LBB46:
 412               	.LBB47:
 163:Menu.c        ****         if(i==2)TCCR1B&=~(1<<CS10);
 413               		.loc 1 163 0
 414 014e 9EB5      		in r25,0x2e
 415 0150 9560      		ori r25,lo8(5)
 416 0152 9EBD      		out 0x2e,r25
 164:Menu.c        ****         mode=i;
 417               		.loc 1 164 0
 418 0154 8230      		cpi r24,lo8(2)
 419 0156 01F4      		brne .L21
 420 0158 9EB5      		in r25,0x2e
 421 015a 9E7F      		andi r25,lo8(-2)
 422 015c 9EBD      		out 0x2e,r25
 423               	.L21:
 165:Menu.c        ****         EEPROM_write(EE_MODE,i);
 424               		.loc 1 165 0
 425 015e 8093 0000 		sts mode,r24
 166:Menu.c        ****     }
 426               		.loc 1 166 0
 427 0162 682F      		mov r22,r24
 428 0164 84E0      		ldi r24,lo8(4)
 429               	.LVL41:
 430 0166 00C0      		rjmp EEPROM_write
 431               	.LVL42:
 432               	.L19:
 433 0168 0895      		ret
 434               	.LBE47:
 435               	.LBE46:
 436               		.cfi_endproc
 437               	.LFE11:
 439               	.global	MsetColorMode
 441               	MsetColorMode:
 442               	.LFB13:
 180:Menu.c        ****     if(i<7){
 443               		.loc 1 180 0
 444               		.cfi_startproc
 445               	.LVL43:
 446               	/* prologue: function */
 447               	/* frame size = 0 */
 448               	/* stack size = 0 */
 449               	.L__stack_usage = 0
 181:Menu.c        ****         colorMode=colorArray[i];//fixed
 450               		.loc 1 181 0
 451 016a 8730      		cpi r24,lo8(7)
 452 016c 00F4      		brsh .L23
 182:Menu.c        ****         EEPROM_write(EE_COLOR,colorArray[i]);
 453               		.loc 1 182 0
 454 016e E82F      		mov r30,r24
 455 0170 F0E0      		ldi r31,0
 456 0172 E050      		subi r30,lo8(-(colorArray))
 457 0174 F040      		sbci r31,hi8(-(colorArray))
 458 0176 6081      		ld r22,Z
 459 0178 6093 0000 		sts colorMode,r22
 460 017c 00C0      		rjmp .L26
 461               	.L23:
 184:Menu.c        ****         colorMode=WHITE+128;
 462               		.loc 1 184 0
 463 017e 8730      		cpi r24,lo8(7)
 464 0180 01F4      		brne .L24
 465               	.LVL44:
 466               	.LBB50:
 467               	.LBB51:
 185:Menu.c        ****         EEPROM_write(EE_COLOR,128);
 468               		.loc 1 185 0
 469 0182 87E8      		ldi r24,lo8(-121)
 470               	.LVL45:
 471 0184 8093 0000 		sts colorMode,r24
 186:Menu.c        ****     }else if(i==8){//cycle all
 472               		.loc 1 186 0
 473 0188 60E8      		ldi r22,lo8(-128)
 474 018a 00C0      		rjmp .L26
 475               	.LVL46:
 476               	.L24:
 477               	.LBE51:
 478               	.LBE50:
 187:Menu.c        ****         colorMode=WHITE+64;
 479               		.loc 1 187 0
 480 018c 8830      		cpi r24,lo8(8)
 481 018e 01F4      		brne .L22
 188:Menu.c        ****         EEPROM_write(EE_COLOR,64);
 482               		.loc 1 188 0
 483 0190 87E4      		ldi r24,lo8(71)
 484               	.LVL47:
 485 0192 8093 0000 		sts colorMode,r24
 189:Menu.c        ****     }
 486               		.loc 1 189 0
 487 0196 60E4      		ldi r22,lo8(64)
 488               	.L26:
 489 0198 80E0      		ldi r24,0
 490 019a 00C0      		rjmp EEPROM_write
 491               	.LVL48:
 492               	.L22:
 493 019c 0895      		ret
 494               		.cfi_endproc
 495               	.LFE13:
 497               	.global	MsetNightMode
 499               	MsetNightMode:
 500               	.LFB15:
 203:Menu.c        ****     if(i<3)EEPROM_write(EE_NIGHTMODE,i);
 501               		.loc 1 203 0
 502               		.cfi_startproc
 503               	.LVL49:
 504               	/* prologue: function */
 505               	/* frame size = 0 */
 506               	/* stack size = 0 */
 507               	.L__stack_usage = 0
 204:Menu.c        **** }
 508               		.loc 1 204 0
 509 019e 8330      		cpi r24,lo8(3)
 510 01a0 00F4      		brsh .L27
 204:Menu.c        **** }
 511               		.loc 1 204 0 is_stmt 0 discriminator 1
 512 01a2 682F      		mov r22,r24
 513 01a4 81E0      		ldi r24,lo8(1)
 514               	.LVL50:
 515 01a6 00C0      		rjmp EEPROM_write
 516               	.LVL51:
 517               	.L27:
 518 01a8 0895      		ret
 519               		.cfi_endproc
 520               	.LFE15:
 522               	.global	MsetNightOff
 524               	MsetNightOff:
 525               	.LFB17:
 210:Menu.c        ****     EEPROM_write(EE_OFFHOUR,12+i);
 526               		.loc 1 210 0 is_stmt 1
 527               		.cfi_startproc
 528               	.LVL52:
 529               	/* prologue: function */
 530               	/* frame size = 0 */
 531               	/* stack size = 0 */
 532               	.L__stack_usage = 0
 211:Menu.c        **** }
 533               		.loc 1 211 0
 534 01aa 6CE0      		ldi r22,lo8(12)
 535 01ac 680F      		add r22,r24
 536 01ae 83E0      		ldi r24,lo8(3)
 537               	.LVL53:
 538 01b0 00C0      		rjmp EEPROM_write
 539               	.LVL54:
 540               		.cfi_endproc
 541               	.LFE17:
 543               	.global	MsetNightOn
 545               	MsetNightOn:
 546               	.LFB18:
 213:Menu.c        ****     EEPROM_write(EE_ONHOUR,1+i);
 547               		.loc 1 213 0
 548               		.cfi_startproc
 549               	.LVL55:
 550               	/* prologue: function */
 551               	/* frame size = 0 */
 552               	/* stack size = 0 */
 553               	.L__stack_usage = 0
 214:Menu.c        **** }
 554               		.loc 1 214 0
 555 01b2 61E0      		ldi r22,lo8(1)
 556 01b4 680F      		add r22,r24
 557 01b6 82E0      		ldi r24,lo8(2)
 558               	.LVL56:
 559 01b8 00C0      		rjmp EEPROM_write
 560               	.LVL57:
 561               		.cfi_endproc
 562               	.LFE18:
 564               	.global	MsetEventMode
 566               	MsetEventMode:
 567               	.LFB23:
 228:Menu.c        ****     if(i<2)EEPROM_write(EE_EVENT,1-i);//1 for active
 568               		.loc 1 228 0
 569               		.cfi_startproc
 570               	.LVL58:
 571               	/* prologue: function */
 572               	/* frame size = 0 */
 573               	/* stack size = 0 */
 574               	.L__stack_usage = 0
 229:Menu.c        **** }
 575               		.loc 1 229 0
 576 01ba 8230      		cpi r24,lo8(2)
 577 01bc 00F4      		brsh .L31
 578               	.LVL59:
 579               	.LBB54:
 580               	.LBB55:
 581 01be 61E0      		ldi r22,lo8(1)
 582 01c0 681B      		sub r22,r24
 583 01c2 85E0      		ldi r24,lo8(5)
 584               	.LVL60:
 585 01c4 00C0      		rjmp EEPROM_write
 586               	.LVL61:
 587               	.L31:
 588 01c6 0895      		ret
 589               	.LBE55:
 590               	.LBE54:
 591               		.cfi_endproc
 592               	.LFE23:
 594               	.global	Mreset
 596               	Mreset:
 597               	.LFB24:
 231:Menu.c        ****     if(i<1){
 598               		.loc 1 231 0
 599               		.cfi_startproc
 600               	.LVL62:
 601               	/* prologue: function */
 602               	/* frame size = 0 */
 603               	/* stack size = 0 */
 604               	.L__stack_usage = 0
 232:Menu.c        ****         MsetMode(1);
 605               		.loc 1 232 0
 606 01c8 8111      		cpse r24,__zero_reg__
 607 01ca 00C0      		rjmp .L33
 608               	.LVL63:
 609               	.LBB62:
 610               	.LBB63:
 611               	.LBB64:
 612               	.LBB65:
 613               	.LBB66:
 163:Menu.c        ****         if(i==2)TCCR1B&=~(1<<CS10);
 614               		.loc 1 163 0
 615 01cc 8EB5      		in r24,0x2e
 616               	.LVL64:
 617 01ce 8560      		ori r24,lo8(5)
 618 01d0 8EBD      		out 0x2e,r24
 165:Menu.c        ****         EEPROM_write(EE_MODE,i);
 619               		.loc 1 165 0
 620 01d2 81E0      		ldi r24,lo8(1)
 621 01d4 8093 0000 		sts mode,r24
 166:Menu.c        ****     }
 622               		.loc 1 166 0
 623 01d8 61E0      		ldi r22,lo8(1)
 624 01da 84E0      		ldi r24,lo8(4)
 625 01dc 00D0      		rcall EEPROM_write
 626               	.LVL65:
 627               	.LBE66:
 628               	.LBE65:
 629               	.LBE64:
 235:Menu.c        ****         EEPROM_write(EE_OFFHOUR,12+10);
 630               		.loc 1 235 0
 631 01de 61E0      		ldi r22,lo8(1)
 632 01e0 81E0      		ldi r24,lo8(1)
 633 01e2 00D0      		rcall EEPROM_write
 634               	.LVL66:
 236:Menu.c        ****         EEPROM_write(EE_ONHOUR,1+8);
 635               		.loc 1 236 0
 636 01e4 66E1      		ldi r22,lo8(22)
 637 01e6 83E0      		ldi r24,lo8(3)
 638 01e8 00D0      		rcall EEPROM_write
 639               	.LVL67:
 237:Menu.c        ****         TCCR1B|=(1<<CS12)|(1<<CS10);
 640               		.loc 1 237 0
 641 01ea 69E0      		ldi r22,lo8(9)
 642 01ec 82E0      		ldi r24,lo8(2)
 643 01ee 00D0      		rcall EEPROM_write
 644               	.LVL68:
 238:Menu.c        ****     }
 645               		.loc 1 238 0
 646 01f0 8EB5      		in r24,0x2e
 647 01f2 8560      		ori r24,lo8(5)
 648 01f4 8EBD      		out 0x2e,r24
 649               	.LVL69:
 650               	.L33:
 651 01f6 0895      		ret
 652               	.LBE63:
 653               	.LBE62:
 654               		.cfi_endproc
 655               	.LFE24:
 657               	.global	EEPROM_read
 659               	EEPROM_read:
 660               	.LFB9:
  23:Menu.c        ****     while(EECR & (1<<EEPE));
 661               		.loc 1 23 0
 662               		.cfi_startproc
 663               	/* prologue: function */
 664               	/* frame size = 0 */
 665               	/* stack size = 0 */
 666               	.L__stack_usage = 0
 667               	.LVL70:
 668               	.L36:
  24:Menu.c        ****     EEAR = addr;
 669               		.loc 1 24 0 discriminator 1
 670 01f8 E199      		sbic 0x1c,1
 671 01fa 00C0      		rjmp .L36
  25:Menu.c        ****     EECR |= (1<<EERE);
 672               		.loc 1 25 0
 673 01fc 90E0      		ldi r25,0
 674 01fe 9FBB      		out 0x1e+1,r25
 675 0200 8EBB      		out 0x1e,r24
  26:Menu.c        ****     return EEDR;
 676               		.loc 1 26 0
 677 0202 E09A      		sbi 0x1c,0
  27:Menu.c        **** }
 678               		.loc 1 27 0
 679 0204 8DB3      		in r24,0x1d
 680               	.LVL71:
  28:Menu.c        **** 
 681               		.loc 1 28 0
 682 0206 0895      		ret
 683               		.cfi_endproc
 684               	.LFE9:
 686               	.global	Minit
 688               	Minit:
 689               	.LFB10:
  30:Menu.c        ****     colorMode=EEPROM_read(EE_COLOR);
 690               		.loc 1 30 0
 691               		.cfi_startproc
 692               	/* prologue: function */
 693               	/* frame size = 0 */
 694               	/* stack size = 0 */
 695               	.L__stack_usage = 0
  31:Menu.c        ****     mode=EEPROM_read(EE_MODE);
 696               		.loc 1 31 0
 697 0208 80E0      		ldi r24,0
 698 020a 00D0      		rcall EEPROM_read
 699               	.LVL72:
 700 020c 8093 0000 		sts colorMode,r24
  32:Menu.c        ****     MsetMode(EEPROM_read(EE_MODE));
 701               		.loc 1 32 0
 702 0210 84E0      		ldi r24,lo8(4)
 703 0212 00D0      		rcall EEPROM_read
 704               	.LVL73:
 705 0214 8093 0000 		sts mode,r24
  33:Menu.c        **** }
 706               		.loc 1 33 0
 707 0218 84E0      		ldi r24,lo8(4)
 708 021a 00D0      		rcall EEPROM_read
 709               	.LVL74:
 710 021c 00C0      		rjmp MsetMode
 711               	.LVL75:
 712               		.cfi_endproc
 713               	.LFE10:
 715               	.global	getMode
 717               	getMode:
 718               	.LFB12:
 169:Menu.c        ****     if(mode==2){
 719               		.loc 1 169 0
 720               		.cfi_startproc
 721               	/* prologue: function */
 722               	/* frame size = 0 */
 723               	/* stack size = 0 */
 724               	.L__stack_usage = 0
 170:Menu.c        ****         mode=1;
 725               		.loc 1 170 0
 726 021e 8091 0000 		lds r24,mode
 727 0222 8230      		cpi r24,lo8(2)
 728 0224 01F4      		brne .L40
 171:Menu.c        ****     }else if(mode==1){
 729               		.loc 1 171 0
 730 0226 81E0      		ldi r24,lo8(1)
 731 0228 00C0      		rjmp .L43
 732               	.L40:
 172:Menu.c        ****         mode=2;
 733               		.loc 1 172 0
 734 022a 8130      		cpi r24,lo8(1)
 735 022c 01F4      		brne .L41
 173:Menu.c        ****     }
 736               		.loc 1 173 0
 737 022e 82E0      		ldi r24,lo8(2)
 738               	.L43:
 739 0230 8093 0000 		sts mode,r24
 740               	.L41:
 175:Menu.c        ****         colorMode=((colorMode-64+1)%7)+64;
 741               		.loc 1 175 0
 742 0234 8091 0000 		lds r24,colorMode
 743 0238 90EC      		ldi r25,lo8(-64)
 744 023a 980F      		add r25,r24
 745 023c 9034      		cpi r25,lo8(64)
 746 023e 00F4      		brsh .L42
 176:Menu.c        ****     }
 747               		.loc 1 176 0
 748 0240 90E0      		ldi r25,0
 749 0242 CF97      		sbiw r24,63
 750 0244 67E0      		ldi r22,lo8(7)
 751 0246 70E0      		ldi r23,0
 752 0248 00D0      		rcall __divmodhi4
 753 024a 805C      		subi r24,lo8(-(64))
 754 024c 8093 0000 		sts colorMode,r24
 755               	.L42:
 179:Menu.c        **** void MsetColorMode(uint8_t i){
 756               		.loc 1 179 0
 757 0250 8091 0000 		lds r24,mode
 758 0254 0895      		ret
 759               		.cfi_endproc
 760               	.LFE12:
 762               	.global	getColor
 764               	getColor:
 765               	.LFB14:
 192:Menu.c        ****     if(colorMode>127){//cycle single
 766               		.loc 1 192 0
 767               		.cfi_startproc
 768               	/* prologue: function */
 769               	/* frame size = 0 */
 770               	/* stack size = 0 */
 771               	.L__stack_usage = 0
 193:Menu.c        ****         if(colorMode>134)colorMode=128;
 772               		.loc 1 193 0
 773 0256 8091 0000 		lds r24,colorMode
 774 025a 87FF      		sbrs r24,7
 775 025c 00C0      		rjmp .L45
 194:Menu.c        ****         colorMode++;
 776               		.loc 1 194 0
 777 025e 8738      		cpi r24,lo8(-121)
 778 0260 00F0      		brlo .L46
 194:Menu.c        ****         colorMode++;
 779               		.loc 1 194 0 is_stmt 0 discriminator 1
 780 0262 80E8      		ldi r24,lo8(-128)
 781 0264 8093 0000 		sts colorMode,r24
 782               	.L46:
 195:Menu.c        ****         return colorArray[colorMode-129];
 783               		.loc 1 195 0 is_stmt 1
 784 0268 E091 0000 		lds r30,colorMode
 785 026c EF5F      		subi r30,lo8(-(1))
 786 026e E093 0000 		sts colorMode,r30
 196:Menu.c        ****     }else if(colorMode>63){//cycle all
 787               		.loc 1 196 0
 788 0272 F0E0      		ldi r31,0
 789 0274 E050      		subi r30,lo8(-(colorArray-129))
 790 0276 F040      		sbci r31,hi8(-(colorArray-129))
 791 0278 00C0      		rjmp .L48
 792               	.L45:
 197:Menu.c        ****         return colorArray[colorMode-64];
 793               		.loc 1 197 0
 794 027a 8034      		cpi r24,lo8(64)
 795 027c 00F0      		brlo .L47
 198:Menu.c        ****     }else{//fixed
 796               		.loc 1 198 0
 797 027e E82F      		mov r30,r24
 798 0280 F0E0      		ldi r31,0
 799 0282 E050      		subi r30,lo8(-(colorArray-64))
 800 0284 F040      		sbci r31,hi8(-(colorArray-64))
 801               	.L48:
 802 0286 8081      		ld r24,Z
 803               	.L47:
 202:Menu.c        **** void MsetNightMode(uint8_t i){
 804               		.loc 1 202 0
 805 0288 0895      		ret
 806               		.cfi_endproc
 807               	.LFE14:
 809               	.global	isInAllowedTime
 811               	isInAllowedTime:
 812               	.LFB16:
 206:Menu.c        ****     if(EEPROM_read(EE_NIGHTMODE))return (h>=EEPROM_read(EE_ONHOUR) && h<=EEPROM_read(EE_OFFHOUR));
 813               		.loc 1 206 0
 814               		.cfi_startproc
 815               	.LVL76:
 816 028a CF93      		push r28
 817               	.LCFI0:
 818               		.cfi_def_cfa_offset 3
 819               		.cfi_offset 28, -2
 820               	/* prologue: function */
 821               	/* frame size = 0 */
 822               	/* stack size = 1 */
 823               	.L__stack_usage = 1
 824 028c C82F      		mov r28,r24
 207:Menu.c        ****     return 1;
 825               		.loc 1 207 0
 826 028e 81E0      		ldi r24,lo8(1)
 827               	.LVL77:
 828 0290 00D0      		rcall EEPROM_read
 829               	.LVL78:
 830 0292 8823      		tst r24
 831 0294 01F0      		breq .L53
 207:Menu.c        ****     return 1;
 832               		.loc 1 207 0 is_stmt 0 discriminator 1
 833 0296 82E0      		ldi r24,lo8(2)
 834 0298 00D0      		rcall EEPROM_read
 835               	.LVL79:
 836 029a C817      		cp r28,r24
 837 029c 00F0      		brlo .L54
 207:Menu.c        ****     return 1;
 838               		.loc 1 207 0 discriminator 2
 839 029e 83E0      		ldi r24,lo8(3)
 840 02a0 00D0      		rcall EEPROM_read
 841               	.LVL80:
 842 02a2 91E0      		ldi r25,lo8(1)
 843 02a4 8C17      		cp r24,r28
 844 02a6 00F4      		brsh .L52
 845 02a8 90E0      		ldi r25,0
 846               	.L52:
 847 02aa 892F      		mov r24,r25
 848 02ac 00C0      		rjmp .L50
 849               	.L54:
 207:Menu.c        ****     return 1;
 850               		.loc 1 207 0
 851 02ae 80E0      		ldi r24,0
 852 02b0 00C0      		rjmp .L50
 853               	.L53:
 208:Menu.c        **** }
 854               		.loc 1 208 0 is_stmt 1
 855 02b2 81E0      		ldi r24,lo8(1)
 856               	.L50:
 857               	/* epilogue start */
 209:Menu.c        **** void MsetNightOff(uint8_t i){
 858               		.loc 1 209 0
 859 02b4 CF91      		pop r28
 860               	.LVL81:
 861 02b6 0895      		ret
 862               		.cfi_endproc
 863               	.LFE16:
 865               	.global	colorMode
 866               		.section .bss
 869               	colorMode:
 870 0000 00        		.zero	1
 871               	.global	mode
 872               		.data
 875               	mode:
 876 0000 01        		.byte	1
 877               	.global	M1rainbow
 878               		.section	.rodata
 881               	M1rainbow:
 882 0000 33        		.byte	51
 883 0001 0000      		.word	gs(MsetRainbow)
 884 0003 07        		.byte	7
 885 0004 0000      		.word	0
 886 0006 08        		.byte	8
 887 0007 0000      		.word	0
 888 0009 0F        		.byte	15
 889 000a 0000      		.word	M0main
 890               	.global	M1reset
 893               	M1reset:
 894 000c 42        		.byte	66
 895 000d 0000      		.word	gs(Mreset)
 896 000f 12        		.byte	18
 897 0010 0000      		.word	0
 898 0012 0F        		.byte	15
 899 0013 0000      		.word	M0main
 900               	.global	M1eventMode
 903               	M1eventMode:
 904 0015 13        		.byte	19
 905 0016 0000      		.word	gs(MsetEventMode)
 906 0018 07        		.byte	7
 907 0019 0000      		.word	0
 908 001b 08        		.byte	8
 909 001c 0000      		.word	0
 910 001e 0F        		.byte	15
 911 001f 0000      		.word	M0main
 912               	.global	M2setminpm
 915               	M2setminpm:
 916 0021 24        		.byte	36
 917 0022 0000      		.word	gs(MsetMinpm)
 918 0024 05        		.byte	5
 919 0025 0000      		.word	0
 920 0027 0B        		.byte	11
 921 0028 0000      		.word	0
 922 002a 01        		.byte	1
 923 002b 0000      		.word	0
 924 002d 0F        		.byte	15
 925 002e 0000      		.word	M1setTime
 926               	.global	M2setminam
 929               	M2setminam:
 930 0030 24        		.byte	36
 931 0031 0000      		.word	gs(MsetMinam)
 932 0033 05        		.byte	5
 933 0034 0000      		.word	0
 934 0036 0B        		.byte	11
 935 0037 0000      		.word	0
 936 0039 01        		.byte	1
 937 003a 0000      		.word	0
 938 003c 0F        		.byte	15
 939 003d 0000      		.word	M1setTime
 940               	.global	M2sethourpm
 943               	M2sethourpm:
 944 003f 4C        		.byte	76
 945 0040 0000      		.word	gs(MsetHourpm)
 946 0042 07        		.byte	7
 947 0043 0000      		.word	0
 948 0045 08        		.byte	8
 949 0046 0000      		.word	0
 950 0048 0A        		.byte	10
 951 0049 0000      		.word	0
 952 004b 0E        		.byte	14
 953 004c 0000      		.word	0
 954 004e 00        		.byte	0
 955 004f 0000      		.word	0
 956 0051 04        		.byte	4
 957 0052 0000      		.word	0
 958 0054 11        		.byte	17
 959 0055 0000      		.word	0
 960 0057 02        		.byte	2
 961 0058 0000      		.word	0
 962 005a 0C        		.byte	12
 963 005b 0000      		.word	0
 964 005d 06        		.byte	6
 965 005e 0000      		.word	0
 966 0060 10        		.byte	16
 967 0061 0000      		.word	0
 968 0063 0F        		.byte	15
 969 0064 0000      		.word	M1setTime
 970               	.global	M2sethouram
 973               	M2sethouram:
 974 0066 4D        		.byte	77
 975 0067 0000      		.word	gs(MsetHouram)
 976 0069 07        		.byte	7
 977 006a 0000      		.word	0
 978 006c 08        		.byte	8
 979 006d 0000      		.word	0
 980 006f 0A        		.byte	10
 981 0070 0000      		.word	0
 982 0072 0E        		.byte	14
 983 0073 0000      		.word	0
 984 0075 00        		.byte	0
 985 0076 0000      		.word	0
 986 0078 04        		.byte	4
 987 0079 0000      		.word	0
 988 007b 11        		.byte	17
 989 007c 0000      		.word	0
 990 007e 02        		.byte	2
 991 007f 0000      		.word	0
 992 0081 0C        		.byte	12
 993 0082 0000      		.word	0
 994 0084 06        		.byte	6
 995 0085 0000      		.word	0
 996 0087 10        		.byte	16
 997 0088 0000      		.word	0
 998 008a 0D        		.byte	13
 999 008b 0000      		.word	0
 1000 008d 0F        		.byte	15
 1001 008e 0000      		.word	M1setTime
 1002               	.global	M1setTime
 1005               	M1setTime:
 1006 0090 65        		.byte	101
 1007 0091 0000      		.word	0
 1008 0093 07        		.byte	7
 1009 0094 0000      		.word	M2sethouram
 1010 0096 08        		.byte	8
 1011 0097 0000      		.word	M2sethourpm
 1012 0099 0A        		.byte	10
 1013 009a 0000      		.word	M2setminam
 1014 009c 0E        		.byte	14
 1015 009d 0000      		.word	M2setminpm
 1016 009f 0F        		.byte	15
 1017 00a0 0000      		.word	M0main
 1018               	.global	M3onhour
 1021               	M3onhour:
 1022 00a2 5C        		.byte	92
 1023 00a3 0000      		.word	gs(MsetNightOn)
 1024 00a5 07        		.byte	7
 1025 00a6 0000      		.word	0
 1026 00a8 08        		.byte	8
 1027 00a9 0000      		.word	0
 1028 00ab 0A        		.byte	10
 1029 00ac 0000      		.word	0
 1030 00ae 0E        		.byte	14
 1031 00af 0000      		.word	0
 1032 00b1 00        		.byte	0
 1033 00b2 0000      		.word	0
 1034 00b4 04        		.byte	4
 1035 00b5 0000      		.word	0
 1036 00b7 11        		.byte	17
 1037 00b8 0000      		.word	0
 1038 00ba 02        		.byte	2
 1039 00bb 0000      		.word	0
 1040 00bd 0C        		.byte	12
 1041 00be 0000      		.word	0
 1042 00c0 06        		.byte	6
 1043 00c1 0000      		.word	0
 1044 00c3 10        		.byte	16
 1045 00c4 0000      		.word	0
 1046 00c6 0F        		.byte	15
 1047 00c7 0000      		.word	M1nightmode
 1048               	.global	M2offhour
 1051               	M2offhour:
 1052 00c9 4C        		.byte	76
 1053 00ca 0000      		.word	gs(MsetNightOff)
 1054 00cc 07        		.byte	7
 1055 00cd 0000      		.word	M3onhour
 1056 00cf 08        		.byte	8
 1057 00d0 0000      		.word	M3onhour
 1058 00d2 0A        		.byte	10
 1059 00d3 0000      		.word	M3onhour
 1060 00d5 0E        		.byte	14
 1061 00d6 0000      		.word	M3onhour
 1062 00d8 00        		.byte	0
 1063 00d9 0000      		.word	M3onhour
 1064 00db 04        		.byte	4
 1065 00dc 0000      		.word	M3onhour
 1066 00de 11        		.byte	17
 1067 00df 0000      		.word	M3onhour
 1068 00e1 02        		.byte	2
 1069 00e2 0000      		.word	M3onhour
 1070 00e4 0C        		.byte	12
 1071 00e5 0000      		.word	M3onhour
 1072 00e7 06        		.byte	6
 1073 00e8 0000      		.word	M3onhour
 1074 00ea 10        		.byte	16
 1075 00eb 0000      		.word	M3onhour
 1076 00ed 0F        		.byte	15
 1077 00ee 0000      		.word	M1nightmode
 1078               	.global	M1nightmode
 1081               	M1nightmode:
 1082 00f0 34        		.byte	52
 1083 00f1 0000      		.word	gs(MsetNightMode)
 1084 00f3 07        		.byte	7
 1085 00f4 0000      		.word	0
 1086 00f6 08        		.byte	8
 1087 00f7 0000      		.word	M2offhour
 1088 00f9 0A        		.byte	10
 1089 00fa 0000      		.word	M2offhour
 1090 00fc 0F        		.byte	15
 1091 00fd 0000      		.word	M0main
 1092               	.global	M1cmode
 1095               	M1cmode:
 1096 00ff 2A        		.byte	42
 1097 0100 0000      		.word	gs(MsetColorMode)
 1098 0102 07        		.byte	7
 1099 0103 0000      		.word	0
 1100 0105 08        		.byte	8
 1101 0106 0000      		.word	0
 1102 0108 0A        		.byte	10
 1103 0109 0000      		.word	0
 1104 010b 0E        		.byte	14
 1105 010c 0000      		.word	0
 1106 010e 00        		.byte	0
 1107 010f 0000      		.word	0
 1108 0111 04        		.byte	4
 1109 0112 0000      		.word	0
 1110 0114 11        		.byte	17
 1111 0115 0000      		.word	0
 1112 0117 02        		.byte	2
 1113 0118 0000      		.word	0
 1114 011a 0C        		.byte	12
 1115 011b 0000      		.word	0
 1116 011d 0F        		.byte	15
 1117 011e 0000      		.word	M0main
 1118               	.global	M1mode
 1121               	M1mode:
 1122 0120 15        		.byte	21
 1123 0121 0000      		.word	gs(MsetMode)
 1124 0123 07        		.byte	7
 1125 0124 0000      		.word	0
 1126 0126 08        		.byte	8
 1127 0127 0000      		.word	0
 1128 0129 0A        		.byte	10
 1129 012a 0000      		.word	0
 1130 012c 0E        		.byte	14
 1131 012d 0000      		.word	0
 1132 012f 0F        		.byte	15
 1133 0130 0000      		.word	M0main
 1134               	.global	M0main
 1137               	M0main:
 1138 0132 08        		.byte	8
 1139 0133 0000      		.word	0
 1140 0135 07        		.byte	7
 1141 0136 0000      		.word	M1mode
 1142 0138 08        		.byte	8
 1143 0139 0000      		.word	M1cmode
 1144 013b 0A        		.byte	10
 1145 013c 0000      		.word	M1nightmode
 1146 013e 0E        		.byte	14
 1147 013f 0000      		.word	M1setTime
 1148 0141 00        		.byte	0
 1149 0142 0000      		.word	M1eventMode
 1150 0144 04        		.byte	4
 1151 0145 0000      		.word	M1reset
 1152 0147 11        		.byte	17
 1153 0148 0000      		.word	M1rainbow
 1154 014a 0F        		.byte	15
 1155 014b 0000      		.word	0
 1156               		.comm	USI_I2C_Master_State,1,1
 1157               		.comm	currentTime,5,1
 1160               	colorArray:
 1161 014d 07        		.byte	7
 1162 014e 03        		.byte	3
 1163 014f 01        		.byte	1
 1164 0150 05        		.byte	5
 1165 0151 04        		.byte	4
 1166 0152 06        		.byte	6
 1167 0153 02        		.byte	2
 1168               		.text
 1169               	.Letext0:
 1170               		.file 3 "/usr/lib/avr/include/stdint.h"
 1171               		.file 4 "RTC.h"
 1172               		.file 5 "Menu.h"
 1173               		.file 6 "defines.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Menu.c
     /tmp/ccTs0AkT.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccTs0AkT.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccTs0AkT.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccTs0AkT.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccTs0AkT.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccTs0AkT.s:12     .text:0000000000000000 MsetHouram
     /tmp/ccTs0AkT.s:37     .text:000000000000000a MsetHourpm
     /tmp/ccTs0AkT.s:61     .text:0000000000000014 MsetRainbow
     /tmp/ccTs0AkT.s:875    .data:0000000000000000 mode
     /tmp/ccTs0AkT.s:237    .text:00000000000000e0 MsetMinam
     /tmp/ccTs0AkT.s:268    .text:00000000000000ee MsetMinpm
     /tmp/ccTs0AkT.s:300    .text:00000000000000fe findNextEntry
     /tmp/ccTs0AkT.s:336    .text:000000000000011e getSubMenu
     /tmp/ccTs0AkT.s:367    .text:0000000000000136 EEPROM_write
     /tmp/ccTs0AkT.s:398    .text:000000000000014a MsetMode
     /tmp/ccTs0AkT.s:441    .text:000000000000016a MsetColorMode
     /tmp/ccTs0AkT.s:1160   .rodata:000000000000014d colorArray
     /tmp/ccTs0AkT.s:869    .bss:0000000000000000 colorMode
     /tmp/ccTs0AkT.s:499    .text:000000000000019e MsetNightMode
     /tmp/ccTs0AkT.s:524    .text:00000000000001aa MsetNightOff
     /tmp/ccTs0AkT.s:545    .text:00000000000001b2 MsetNightOn
     /tmp/ccTs0AkT.s:566    .text:00000000000001ba MsetEventMode
     /tmp/ccTs0AkT.s:596    .text:00000000000001c8 Mreset
     /tmp/ccTs0AkT.s:659    .text:00000000000001f8 EEPROM_read
     /tmp/ccTs0AkT.s:688    .text:0000000000000208 Minit
     /tmp/ccTs0AkT.s:717    .text:000000000000021e getMode
     /tmp/ccTs0AkT.s:764    .text:0000000000000256 getColor
     /tmp/ccTs0AkT.s:811    .text:000000000000028a isInAllowedTime
     /tmp/ccTs0AkT.s:881    .rodata:0000000000000000 M1rainbow
     /tmp/ccTs0AkT.s:1137   .rodata:0000000000000132 M0main
     /tmp/ccTs0AkT.s:893    .rodata:000000000000000c M1reset
     /tmp/ccTs0AkT.s:903    .rodata:0000000000000015 M1eventMode
     /tmp/ccTs0AkT.s:915    .rodata:0000000000000021 M2setminpm
     /tmp/ccTs0AkT.s:1005   .rodata:0000000000000090 M1setTime
     /tmp/ccTs0AkT.s:929    .rodata:0000000000000030 M2setminam
     /tmp/ccTs0AkT.s:943    .rodata:000000000000003f M2sethourpm
     /tmp/ccTs0AkT.s:973    .rodata:0000000000000066 M2sethouram
     /tmp/ccTs0AkT.s:1021   .rodata:00000000000000a2 M3onhour
     /tmp/ccTs0AkT.s:1081   .rodata:00000000000000f0 M1nightmode
     /tmp/ccTs0AkT.s:1051   .rodata:00000000000000c9 M2offhour
     /tmp/ccTs0AkT.s:1095   .rodata:00000000000000ff M1cmode
     /tmp/ccTs0AkT.s:1121   .rodata:0000000000000120 M1mode
                            *COM*:0000000000000001 USI_I2C_Master_State
                            *COM*:0000000000000005 currentTime

UNDEFINED SYMBOLS
RTC_setHour
sendRawData
__mulqi3
RTC_setMin
__mulhi3
__divmodhi4
__do_copy_data
__do_clear_bss
