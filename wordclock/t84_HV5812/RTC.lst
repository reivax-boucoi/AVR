   1               		.file	"RTC.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	setCurrentTime
  12               	setCurrentTime:
  13               	.LFB6:
  14               		.file 1 "RTC.c"
   1:RTC.c         **** #include "RTC.h" 
   2:RTC.c         **** 
   3:RTC.c         **** void setCurrentTime(uint8_t hour,uint8_t min,uint8_t monthDay,uint8_t month){
  15               		.loc 1 3 77
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
   4:RTC.c         **** 	currentTime.hour=hour;
  22               		.loc 1 4 2
  23               		.loc 1 4 18 is_stmt 0
  24 0000 E0E0      		ldi r30,lo8(currentTime)
  25 0002 F0E0      		ldi r31,hi8(currentTime)
  26 0004 8083      		st Z,r24
   5:RTC.c         **** 	currentTime.min=min;
  27               		.loc 1 5 2 is_stmt 1
  28               		.loc 1 5 17 is_stmt 0
  29 0006 6183      		std Z+1,r22
   6:RTC.c         **** 	currentTime.monthDay=monthDay;
  30               		.loc 1 6 2 is_stmt 1
  31               		.loc 1 6 22 is_stmt 0
  32 0008 4283      		std Z+2,r20
   7:RTC.c         **** 	currentTime.month=month;
  33               		.loc 1 7 2 is_stmt 1
  34               		.loc 1 7 19 is_stmt 0
  35 000a 2383      		std Z+3,r18
  36               	/* epilogue start */
   8:RTC.c         **** }
  37               		.loc 1 8 1
  38 000c 0895      		ret
  39               		.cfi_endproc
  40               	.LFE6:
  42               	.global	minquad
  44               	minquad:
  45               	.LFB7:
   9:RTC.c         **** 
  10:RTC.c         **** uint8_t minquad(uint8_t min){
  46               		.loc 1 10 29 is_stmt 1
  47               		.cfi_startproc
  48               	.LVL1:
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
  11:RTC.c         **** 	if(min > 5){
  53               		.loc 1 11 2
  54               		.loc 1 11 4 is_stmt 0
  55 000e 8630      		cpi r24,lo8(6)
  56 0010 00F0      		brlo .L9
  12:RTC.c         **** 		if(min > 15){
  57               		.loc 1 12 3 is_stmt 1
  58               		.loc 1 12 5 is_stmt 0
  59 0012 8031      		cpi r24,lo8(16)
  60 0014 00F0      		brlo .L5
  13:RTC.c         **** 			if(min > 25){
  61               		.loc 1 13 4 is_stmt 1
  62               		.loc 1 13 6 is_stmt 0
  63 0016 8A31      		cpi r24,lo8(26)
  64 0018 00F0      		brlo .L6
  14:RTC.c         **** 				if(min > 35){
  65               		.loc 1 14 5 is_stmt 1
  66               		.loc 1 14 7 is_stmt 0
  67 001a 8432      		cpi r24,lo8(36)
  68 001c 00F0      		brlo .L7
  15:RTC.c         **** 					if(min > 45){
  69               		.loc 1 15 6 is_stmt 1
  70               		.loc 1 15 8 is_stmt 0
  71 001e 8E32      		cpi r24,lo8(46)
  72 0020 00F0      		brlo .L8
  16:RTC.c         **** 						if(min > 55){
  73               		.loc 1 16 7 is_stmt 1
  74               		.loc 1 16 9 is_stmt 0
  75 0022 8833      		cpi r24,lo8(56)
  76 0024 00F4      		brsh .L9
  17:RTC.c         **** 							return 0;
  18:RTC.c         **** 						}else{return 50;}
  77               		.loc 1 18 20
  78 0026 82E3      		ldi r24,lo8(50)
  79               	.LVL2:
  80 0028 0895      		ret
  81               	.LVL3:
  82               	.L5:
  19:RTC.c         **** 					}else{return 40;}
  20:RTC.c         **** 				}else{return 30;}
  21:RTC.c         **** 			}else{return 20;}
  22:RTC.c         **** 		}else{return 10;}
  83               		.loc 1 22 16
  84 002a 8AE0      		ldi r24,lo8(10)
  85               	.LVL4:
  86 002c 0895      		ret
  87               	.LVL5:
  88               	.L6:
  21:RTC.c         **** 		}else{return 10;}
  89               		.loc 1 21 17
  90 002e 84E1      		ldi r24,lo8(20)
  91               	.LVL6:
  92 0030 0895      		ret
  93               	.LVL7:
  94               	.L7:
  20:RTC.c         **** 			}else{return 20;}
  95               		.loc 1 20 18
  96 0032 8EE1      		ldi r24,lo8(30)
  97               	.LVL8:
  98 0034 0895      		ret
  99               	.LVL9:
 100               	.L8:
  19:RTC.c         **** 					}else{return 40;}
 101               		.loc 1 19 19
 102 0036 88E2      		ldi r24,lo8(40)
 103               	.LVL10:
 104 0038 0895      		ret
 105               	.LVL11:
 106               	.L9:
  23:RTC.c         **** 	}else{return 0;}
 107               		.loc 1 23 15
 108 003a 80E0      		ldi r24,0
 109               	.LVL12:
 110               	/* epilogue start */
  24:RTC.c         **** }
 111               		.loc 1 24 1
 112 003c 0895      		ret
 113               		.cfi_endproc
 114               	.LFE7:
 116               	.global	bcdToDec
 118               	bcdToDec:
 119               	.LFB8:
  25:RTC.c         **** 
  26:RTC.c         **** uint8_t bcdToDec(uint8_t val){
 120               		.loc 1 26 30 is_stmt 1
 121               		.cfi_startproc
 122               	.LVL13:
 123               	/* prologue: function */
 124               	/* frame size = 0 */
 125               	/* stack size = 0 */
 126               	.L__stack_usage = 0
 127 003e 982F      		mov r25,r24
  27:RTC.c         ****   return ((val/16*10) + (val%16));
 128               		.loc 1 27 3
 129               		.loc 1 27 23 is_stmt 0
 130 0040 8295      		swap r24
 131               	.LVL14:
 132 0042 8F70      		andi r24,lo8(15)
 133 0044 6AE0      		ldi r22,lo8(10)
 134 0046 00D0      		rcall __mulqi3
 135               		.loc 1 27 29
 136 0048 9F70      		andi r25,lo8(15)
 137               	.LVL15:
  28:RTC.c         **** }
 138               		.loc 1 28 1
 139 004a 890F      		add r24,r25
 140               	/* epilogue start */
 141 004c 0895      		ret
 142               		.cfi_endproc
 143               	.LFE8:
 145               	.global	i2c_in_transfer
 147               	i2c_in_transfer:
 148               	.LFB12:
  29:RTC.c         **** 
  30:RTC.c         **** uint8_t RTC_readTime(struct Ttime *t){
  31:RTC.c         **** 	uint8_t data[7] = {0};
  32:RTC.c         **** 	if(i2c_read(RTC_addr,7,0x00,data)){
  33:RTC.c         **** 		t->hour = bcdToDec(data[2]);
  34:RTC.c         **** 		t->min = bcdToDec(data[1]);
  35:RTC.c         **** 		t->monthDay = bcdToDec(data[4]);
  36:RTC.c         **** 		t->month = bcdToDec(data[5]);
  37:RTC.c         **** 		return 1;
  38:RTC.c         **** 	}else{
  39:RTC.c         **** 		return 0;
  40:RTC.c         **** 	}
  41:RTC.c         **** }
  42:RTC.c         **** uint8_t i2c_write(uint8_t addr, uint8_t adrs, uint8_t val){ // only supports 1 byte write
  43:RTC.c         **** 	uint8_t i2c_buffer[3];
  44:RTC.c         **** 	uint8_t i2c_buffer_len = 3;
  45:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CWRITE ;
  46:RTC.c         **** 	i2c_buffer[1] = adrs;
  47:RTC.c         **** 	i2c_buffer[2] = val;
  48:RTC.c         **** 	return i2c_in_transmit(i2c_buffer, i2c_buffer_len);
  49:RTC.c         **** }
  50:RTC.c         **** uint8_t i2c_read(uint8_t addr, uint8_t len, uint8_t adrs, uint8_t *buf){
  51:RTC.c         **** 	//set register pointer to adrs
  52:RTC.c         **** 	uint8_t i2c_buffer[len+1];
  53:RTC.c         **** 	uint8_t i2c_buffer_len = 2;
  54:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CWRITE;
  55:RTC.c         **** 	i2c_buffer[1] = adrs;
  56:RTC.c         **** 	i2c_in_transmit(i2c_buffer, i2c_buffer_len);
  57:RTC.c         **** 	//read actual data
  58:RTC.c         **** 	i2c_buffer_len = len+1;
  59:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CREAD;
  60:RTC.c         **** 	if(i2c_in_transmit(i2c_buffer, i2c_buffer_len)){
  61:RTC.c         **** 		uint8_t i;
  62:RTC.c         **** 		for(i=1;i<len+1;i++){ // fetch in buffer
  63:RTC.c         **** 			buf[i-1]=i2c_buffer[i];
  64:RTC.c         **** 		}
  65:RTC.c         **** 		return 1; // provide success check
  66:RTC.c         **** 	}else{
  67:RTC.c         **** 		return 0;
  68:RTC.c         **** 	}
  69:RTC.c         **** }
  70:RTC.c         **** 
  71:RTC.c         **** uint8_t i2c_in_transfer(uint8_t USISR_temp){
 149               		.loc 1 71 44 is_stmt 1
 150               		.cfi_startproc
 151               	.LVL16:
 152               	/* prologue: function */
 153               	/* frame size = 0 */
 154               	/* stack size = 0 */
 155               	.L__stack_usage = 0
  72:RTC.c         **** 	USISR = USISR_temp;								//Set USISR as requested by calling function
 156               		.loc 1 72 2
 157               		.loc 1 72 8 is_stmt 0
 158 004e 8EB9      		out 0xe,r24
  73:RTC.c         **** 	do{
  74:RTC.c         **** 		_delay_us(I2C_TLOW);
  75:RTC.c         **** 		USICR = 0b00101011;								//SCL Positive Edge
 159               		.loc 1 75 9
 160 0050 8BE2      		ldi r24,lo8(43)
 161               	.LVL17:
 162               	.L13:
  73:RTC.c         **** 	do{
 163               		.loc 1 73 2 is_stmt 1
  74:RTC.c         **** 		USICR = 0b00101011;								//SCL Positive Edge
 164               		.loc 1 74 3
 165               	.LBB18:
 166               	.LBB19:
 167               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 168               		.loc 2 257 2
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 169               		.loc 2 261 2
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 170               		.loc 2 262 2
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 171               		.loc 2 263 2
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 172               		.loc 2 273 3
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 173               		.loc 2 276 2
 174 0052 95E0      		ldi r25,lo8(5)
 175 0054 9A95      	1:	dec r25
 176 0056 01F4      		brne 1b
 177 0058 0000      		nop
 178               	.LVL18:
 179               	.LBE19:
 180               	.LBE18:
 181               		.loc 1 75 3
 182               		.loc 1 75 9 is_stmt 0
 183 005a 8DB9      		out 0xd,r24
  76:RTC.c         **** 		while (!(PIN_USI&(1<<PIN_USI_SCL)));		//Wait for SCL to go high
 184               		.loc 1 76 3 is_stmt 1
 185               	.L12:
 186               		.loc 1 76 38 discriminator 1
 187               		.loc 1 76 9 is_stmt 0 discriminator 1
 188 005c CC9B      		sbis 0x19,4
 189 005e 00C0      		rjmp .L12
  77:RTC.c         **** 		_delay_us(I2C_THIGH);
 190               		.loc 1 77 3 is_stmt 1
 191               	.LVL19:
 192               	.LBB20:
 193               	.LBB21:
 257:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 194               		.loc 2 257 2
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 195               		.loc 2 261 2
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 196               		.loc 2 262 2
 263:c:\winavr-20100110\avr\include\util\delay.h **** 
 197               		.loc 2 263 2
 273:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 198               		.loc 2 273 3
 199               		.loc 2 276 2
 200 0060 94E0      		ldi r25,lo8(4)
 201 0062 9A95      	1:	dec r25
 202 0064 01F4      		brne 1b
 203               	.LVL20:
 204               	.LBE21:
 205               	.LBE20:
  78:RTC.c         **** 		USICR = 0b00101011;								//SCL Negative Edge
 206               		.loc 1 78 3
 207               		.loc 1 78 9 is_stmt 0
 208 0066 8DB9      		out 0xd,r24
  79:RTC.c         **** 	}while (!(USISR&(1<<USIOIF)));					//Do until transfer is complete
 209               		.loc 1 79 2
 210 0068 769B      		sbis 0xe,6
 211 006a 00C0      		rjmp .L13
  80:RTC.c         **** 	_delay_us(I2C_TLOW);
 212               		.loc 1 80 2 is_stmt 1
 213               	.LVL21:
 214               	.LBB22:
 215               	.LBB23:
 257:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 216               		.loc 2 257 2
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 217               		.loc 2 261 2
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 218               		.loc 2 262 2
 263:c:\winavr-20100110\avr\include\util\delay.h **** 
 219               		.loc 2 263 2
 273:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 220               		.loc 2 273 3
 221               		.loc 2 276 2
 222 006c 85E0      		ldi r24,lo8(5)
 223 006e 8A95      	1:	dec r24
 224 0070 01F4      		brne 1b
 225 0072 0000      		nop
 226               	.LVL22:
 227               	.LBE23:
 228               	.LBE22:
  81:RTC.c         **** 	return USIDR;
 229               		.loc 1 81 2
 230               		.loc 1 81 9 is_stmt 0
 231 0074 8FB1      		in r24,0xf
 232               	/* epilogue start */
  82:RTC.c         **** }
 233               		.loc 1 82 1
 234 0076 0895      		ret
 235               		.cfi_endproc
 236               	.LFE12:
 238               	.global	i2c_in_transmit
 240               	i2c_in_transmit:
 241               	.LFB13:
  83:RTC.c         **** uint8_t i2c_in_transmit(uint8_t *msg, uint8_t msg_size){
 242               		.loc 1 83 56 is_stmt 1
 243               		.cfi_startproc
 244               	.LVL23:
 245 0078 EF92      		push r14
 246               	.LCFI0:
 247               		.cfi_def_cfa_offset 3
 248               		.cfi_offset 14, -2
 249 007a FF92      		push r15
 250               	.LCFI1:
 251               		.cfi_def_cfa_offset 4
 252               		.cfi_offset 15, -3
 253 007c 0F93      		push r16
 254               	.LCFI2:
 255               		.cfi_def_cfa_offset 5
 256               		.cfi_offset 16, -4
 257 007e 1F93      		push r17
 258               	.LCFI3:
 259               		.cfi_def_cfa_offset 6
 260               		.cfi_offset 17, -5
 261 0080 CF93      		push r28
 262               	.LCFI4:
 263               		.cfi_def_cfa_offset 7
 264               		.cfi_offset 28, -6
 265 0082 DF93      		push r29
 266               	.LCFI5:
 267               		.cfi_def_cfa_offset 8
 268               		.cfi_offset 29, -7
 269               	/* prologue: function */
 270               	/* frame size = 0 */
 271               	/* stack size = 6 */
 272               	.L__stack_usage = 6
 273 0084 EC01      		movw r28,r24
 274 0086 162F      		mov r17,r22
  84:RTC.c         **** 	USI_I2C_Master_State = USI_ADDRESS;
 275               		.loc 1 84 2
 276               		.loc 1 84 23 is_stmt 0
 277 0088 1092 0000 		sts USI_I2C_Master_State,__zero_reg__
  85:RTC.c         **** 
  86:RTC.c         **** 	//   Start Condition
  87:RTC.c         **** 	PORT_USI |=  (1 << PORT_USI_SCL); 						//Setting input makes line pull high
 278               		.loc 1 87 2 is_stmt 1
 279               		.loc 1 87 11 is_stmt 0
 280 008c DC9A      		sbi 0x1b,4
  88:RTC.c         **** 	while (!(PIN_USI & (1<<PIN_USI_SCL)));		//Wait for SCL to go high
 281               		.loc 1 88 2 is_stmt 1
 282               	.L19:
 283               		.loc 1 88 39 discriminator 1
 284               		.loc 1 88 8 is_stmt 0 discriminator 1
 285 008e CC9B      		sbis 0x19,4
 286 0090 00C0      		rjmp .L19
  89:RTC.c         **** 
  90:RTC.c         **** 	#ifdef I2C_FAST_MODE
  91:RTC.c         **** 		_delay_us(I2C_THIGH);
 287               		.loc 1 91 3 is_stmt 1
 288               	.LVL24:
 289               	.LBB24:
 290               	.LBB25:
 257:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 291               		.loc 2 257 2
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 292               		.loc 2 261 2
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 293               		.loc 2 262 2
 263:c:\winavr-20100110\avr\include\util\delay.h **** 
 294               		.loc 2 263 2
 273:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 295               		.loc 2 273 3
 296               		.loc 2 276 2
 297 0092 84E0      		ldi r24,lo8(4)
 298 0094 8A95      	1:	dec r24
 299 0096 01F4      		brne 1b
 300               	.LVL25:
 301               	.LBE25:
 302               	.LBE24:
  92:RTC.c         **** 	#else
  93:RTC.c         **** 		_delay_us(I2C_TLOW);
  94:RTC.c         **** 	#endif
  95:RTC.c         **** 	DDR_USI |=  (1 << PORT_USI_SDA);
 303               		.loc 1 95 2
 304               		.loc 1 95 10 is_stmt 0
 305 0098 D69A      		sbi 0x1a,6
  96:RTC.c         **** 	DDR_USI |=  (1 << PORT_USI_SCL);
 306               		.loc 1 96 2 is_stmt 1
 307               		.loc 1 96 10 is_stmt 0
 308 009a D49A      		sbi 0x1a,4
  97:RTC.c         **** 	PORT_USI &= ~(1 << PORT_USI_SDA);
 309               		.loc 1 97 2 is_stmt 1
 310               		.loc 1 97 11 is_stmt 0
 311 009c DE98      		cbi 0x1b,6
  98:RTC.c         **** 	_delay_us(I2C_THIGH);;
 312               		.loc 1 98 2 is_stmt 1
 313               	.LVL26:
 314               	.LBB26:
 315               	.LBB27:
 257:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 316               		.loc 2 257 2
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 317               		.loc 2 261 2
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 318               		.loc 2 262 2
 263:c:\winavr-20100110\avr\include\util\delay.h **** 
 319               		.loc 2 263 2
 273:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 320               		.loc 2 273 3
 321               		.loc 2 276 2
 322 009e 84E0      		ldi r24,lo8(4)
 323 00a0 8A95      	1:	dec r24
 324 00a2 01F4      		brne 1b
 325               	.LVL27:
 326               	.LBE27:
 327               	.LBE26:
 328               		.loc 1 98 23
  99:RTC.c         **** 	PORT_USI &= ~(1 << PORT_USI_SCL);
 329               		.loc 1 99 2
 330               		.loc 1 99 11 is_stmt 0
 331 00a4 DC98      		cbi 0x1b,4
 100:RTC.c         **** 	_delay_us(I2C_TLOW);
 332               		.loc 1 100 2 is_stmt 1
 333               	.LVL28:
 334               	.LBB28:
 335               	.LBB29:
 257:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 336               		.loc 2 257 2
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 337               		.loc 2 261 2
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 338               		.loc 2 262 2
 263:c:\winavr-20100110\avr\include\util\delay.h **** 
 339               		.loc 2 263 2
 273:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 340               		.loc 2 273 3
 341               		.loc 2 276 2
 342 00a6 85E0      		ldi r24,lo8(5)
 343 00a8 8A95      	1:	dec r24
 344 00aa 01F4      		brne 1b
 345 00ac 0000      		nop
 346               	.LVL29:
 347               	.LBE29:
 348               	.LBE28:
 101:RTC.c         **** 	PORT_USI |=  (1 << PORT_USI_SDA);
 349               		.loc 1 101 2
 350               		.loc 1 101 11 is_stmt 0
 351 00ae DE9A      		sbi 0x1b,6
 102:RTC.c         **** 	
 103:RTC.c         **** 	do{
 104:RTC.c         **** 		switch(USI_I2C_Master_State){
 105:RTC.c         **** 			case USI_ADDRESS:
 106:RTC.c         **** 				if(!(*msg & 0x01)){
 107:RTC.c         **** 					USI_I2C_Master_State = USI_WRITE;
 108:RTC.c         **** 				}else{
 109:RTC.c         **** 					USI_I2C_Master_State = USI_READ;
 352               		.loc 1 109 27
 353 00b0 02E0      		ldi r16,lo8(2)
 107:RTC.c         **** 				}else{
 354               		.loc 1 107 27
 355 00b2 FF24      		clr r15
 356 00b4 F394      		inc r15
 110:RTC.c         **** 				}//no break so goes to Write
 111:RTC.c         **** 				
 112:RTC.c         **** 			case USI_WRITE:
 113:RTC.c         **** 				PORT_USI &= ~(1 << PORT_USI_SCL);
 114:RTC.c         **** 				USIDR = *(msg);				//Load data			
 115:RTC.c         **** 				msg++;						//Increment buffer pointer
 116:RTC.c         **** 				i2c_in_transfer(0b11110000 | (0x00<<USICNT0));
 117:RTC.c         **** 				DDR_USI &= ~(1 << PORT_USI_SDA);
 118:RTC.c         **** 				if(i2c_in_transfer(0b11110000 | (0x0E<<USICNT0)) & 0x01){
 119:RTC.c         **** 					PORT_USI |=  (1 << PORT_USI_SCL);
 120:RTC.c         **** 					PORT_USI |=  (1 << PORT_USI_SDA);
 121:RTC.c         **** 					return 0;
 122:RTC.c         **** 				}
 123:RTC.c         **** 				DDR_USI |=  (1 << PORT_USI_SDA);
 124:RTC.c         **** 				break;
 125:RTC.c         **** 
 126:RTC.c         **** 			case USI_READ:
 127:RTC.c         **** 				DDR_USI &= ~(1 << PORT_USI_SDA);
 128:RTC.c         **** 				(*msg) = i2c_in_transfer(0b11110000 | (0x00<<USICNT0));			
 129:RTC.c         **** 				msg++;
 130:RTC.c         **** 				DDR_USI |=  (1 << PORT_USI_SDA);				
 131:RTC.c         **** 				if(msg_size == 1){
 132:RTC.c         **** 					USIDR = 0xFF;			//Load NACK to end transmission
 357               		.loc 1 132 12
 358 00b6 EE24      		clr r14
 359 00b8 EA94      		dec r14
 360               	.LVL30:
 361               	.L29:
 103:RTC.c         **** 		switch(USI_I2C_Master_State){
 362               		.loc 1 103 2 is_stmt 1
 104:RTC.c         **** 			case USI_ADDRESS:
 363               		.loc 1 104 3
 364 00ba 8091 0000 		lds r24,USI_I2C_Master_State
 365 00be 8130      		cpi r24,lo8(1)
 366 00c0 01F0      		breq .L20
 367 00c2 8823      		tst r24
 368 00c4 01F0      		breq .L21
 369 00c6 8230      		cpi r24,lo8(2)
 370 00c8 01F0      		breq .L22
 371               	.L23:
 133:RTC.c         **** 				}else{
 134:RTC.c         **** 					USIDR = 0x00;			//Load ACK
 135:RTC.c         **** 				}
 136:RTC.c         **** 				i2c_in_transfer(0b11110000 | (0x0E<<USICNT0));
 137:RTC.c         **** 				break;
 138:RTC.c         **** 		}
 139:RTC.c         **** 	}while(--msg_size);
 372               		.loc 1 139 2 is_stmt 0
 373 00ca 1150      		subi r17,lo8(-(-1))
 374               	.LVL31:
 375 00cc 01F4      		brne .L29
 140:RTC.c         **** 	
 141:RTC.c         **** 	//Stop Condition
 142:RTC.c         **** 	PORT_USI &= ~(1 << PORT_USI_SDA);           				// Pull SDA low.
 376               		.loc 1 142 2 is_stmt 1
 377               		.loc 1 142 11 is_stmt 0
 378 00ce DE98      		cbi 0x1b,6
 143:RTC.c         **** 	_delay_us(I2C_TLOW);
 379               		.loc 1 143 2 is_stmt 1
 380               	.LVL32:
 381               	.LBB30:
 382               	.LBB31:
 257:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 383               		.loc 2 257 2
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 384               		.loc 2 261 2
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 385               		.loc 2 262 2
 263:c:\winavr-20100110\avr\include\util\delay.h **** 
 386               		.loc 2 263 2
 273:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 387               		.loc 2 273 3
 388               		.loc 2 276 2
 389 00d0 85E0      		ldi r24,lo8(5)
 390 00d2 8A95      	1:	dec r24
 391 00d4 01F4      		brne 1b
 392 00d6 0000      		nop
 393               	.LVL33:
 394               	.LBE31:
 395               	.LBE30:
 144:RTC.c         **** 	DDR_USI &= ~(1 << PORT_USI_SCL);            				// Release SCL.
 396               		.loc 1 144 2
 397               		.loc 1 144 10 is_stmt 0
 398 00d8 D498      		cbi 0x1a,4
 145:RTC.c         **** 	while( !(PIN_USI & (1<<PIN_USI_SCL)) );  	// Wait for SCL to go high.  
 399               		.loc 1 145 2 is_stmt 1
 400               	.L30:
 401               		.loc 1 145 40 discriminator 1
 402               		.loc 1 145 7 is_stmt 0 discriminator 1
 403 00da CC9B      		sbis 0x19,4
 404 00dc 00C0      		rjmp .L30
 146:RTC.c         **** 	_delay_us(I2C_THIGH);
 405               		.loc 1 146 2 is_stmt 1
 406               	.LVL34:
 407               	.LBB32:
 408               	.LBB33:
 257:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 409               		.loc 2 257 2
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 410               		.loc 2 261 2
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 411               		.loc 2 262 2
 263:c:\winavr-20100110\avr\include\util\delay.h **** 
 412               		.loc 2 263 2
 273:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 413               		.loc 2 273 3
 414               		.loc 2 276 2
 415 00de 84E0      		ldi r24,lo8(4)
 416 00e0 8A95      	1:	dec r24
 417 00e2 01F4      		brne 1b
 418               	.LVL35:
 419               	.LBE33:
 420               	.LBE32:
 147:RTC.c         **** 	DDR_USI &= ~(1 << PORT_USI_SDA);            				// Release SDA.
 421               		.loc 1 147 2
 422               		.loc 1 147 10 is_stmt 0
 423 00e4 D698      		cbi 0x1a,6
 148:RTC.c         **** 	while( !(PIN_USI & (1<<PIN_USI_SDA)) );  	// Wait for SDA to go high. 
 424               		.loc 1 148 2 is_stmt 1
 425               	.L31:
 426               		.loc 1 148 40 discriminator 1
 427               		.loc 1 148 7 is_stmt 0 discriminator 1
 428 00e6 CE9B      		sbis 0x19,6
 429 00e8 00C0      		rjmp .L31
 149:RTC.c         **** 	return 1;
 430               		.loc 1 149 9
 431 00ea 81E0      		ldi r24,lo8(1)
 432 00ec 00C0      		rjmp .L18
 433               	.L21:
 106:RTC.c         **** 					USI_I2C_Master_State = USI_WRITE;
 434               		.loc 1 106 5 is_stmt 1
 106:RTC.c         **** 					USI_I2C_Master_State = USI_WRITE;
 435               		.loc 1 106 7 is_stmt 0
 436 00ee 8881      		ld r24,Y
 437 00f0 80FD      		sbrc r24,0
 438 00f2 00C0      		rjmp .L24
 107:RTC.c         **** 				}else{
 439               		.loc 1 107 6 is_stmt 1
 107:RTC.c         **** 				}else{
 440               		.loc 1 107 27 is_stmt 0
 441 00f4 F092 0000 		sts USI_I2C_Master_State,r15
 442               	.L20:
 113:RTC.c         **** 				USIDR = *(msg);				//Load data			
 443               		.loc 1 113 5 is_stmt 1
 113:RTC.c         **** 				USIDR = *(msg);				//Load data			
 444               		.loc 1 113 14 is_stmt 0
 445 00f8 DC98      		cbi 0x1b,4
 114:RTC.c         **** 				msg++;						//Increment buffer pointer
 446               		.loc 1 114 5 is_stmt 1
 114:RTC.c         **** 				msg++;						//Increment buffer pointer
 447               		.loc 1 114 13 is_stmt 0
 448 00fa 8991      		ld r24,Y+
 449               	.LVL36:
 114:RTC.c         **** 				msg++;						//Increment buffer pointer
 450               		.loc 1 114 11
 451 00fc 8FB9      		out 0xf,r24
 115:RTC.c         **** 				i2c_in_transfer(0b11110000 | (0x00<<USICNT0));
 452               		.loc 1 115 5 is_stmt 1
 453               	.LVL37:
 116:RTC.c         **** 				DDR_USI &= ~(1 << PORT_USI_SDA);
 454               		.loc 1 116 5
 455 00fe 80EF      		ldi r24,lo8(-16)
 456 0100 00D0      		rcall i2c_in_transfer
 457               	.LVL38:
 117:RTC.c         **** 				if(i2c_in_transfer(0b11110000 | (0x0E<<USICNT0)) & 0x01){
 458               		.loc 1 117 5
 117:RTC.c         **** 				if(i2c_in_transfer(0b11110000 | (0x0E<<USICNT0)) & 0x01){
 459               		.loc 1 117 13 is_stmt 0
 460 0102 D698      		cbi 0x1a,6
 118:RTC.c         **** 					PORT_USI |=  (1 << PORT_USI_SCL);
 461               		.loc 1 118 5 is_stmt 1
 118:RTC.c         **** 					PORT_USI |=  (1 << PORT_USI_SCL);
 462               		.loc 1 118 8 is_stmt 0
 463 0104 8EEF      		ldi r24,lo8(-2)
 464 0106 00D0      		rcall i2c_in_transfer
 465               	.LVL39:
 118:RTC.c         **** 					PORT_USI |=  (1 << PORT_USI_SCL);
 466               		.loc 1 118 7
 467 0108 80FF      		sbrs r24,0
 468 010a 00C0      		rjmp .L25
 119:RTC.c         **** 					PORT_USI |=  (1 << PORT_USI_SDA);
 469               		.loc 1 119 6 is_stmt 1
 119:RTC.c         **** 					PORT_USI |=  (1 << PORT_USI_SDA);
 470               		.loc 1 119 15 is_stmt 0
 471 010c DC9A      		sbi 0x1b,4
 120:RTC.c         **** 					return 0;
 472               		.loc 1 120 6 is_stmt 1
 120:RTC.c         **** 					return 0;
 473               		.loc 1 120 15 is_stmt 0
 474 010e DE9A      		sbi 0x1b,6
 121:RTC.c         **** 				}
 475               		.loc 1 121 6 is_stmt 1
 121:RTC.c         **** 				}
 476               		.loc 1 121 13 is_stmt 0
 477 0110 80E0      		ldi r24,0
 478               	.L18:
 479               	/* epilogue start */
 150:RTC.c         **** }...
 480               		.loc 1 150 1
 481 0112 DF91      		pop r29
 482 0114 CF91      		pop r28
 483               	.LVL40:
 484 0116 1F91      		pop r17
 485               	.LVL41:
 486 0118 0F91      		pop r16
 487 011a FF90      		pop r15
 488 011c EF90      		pop r14
 489 011e 0895      		ret
 490               	.LVL42:
 491               	.L24:
 109:RTC.c         **** 					USI_I2C_Master_State = USI_READ;
 492               		.loc 1 109 6 is_stmt 1
 109:RTC.c         **** 					USI_I2C_Master_State = USI_READ;
 493               		.loc 1 109 27 is_stmt 0
 494 0120 0093 0000 		sts USI_I2C_Master_State,r16
 495 0124 00C0      		rjmp .L20
 496               	.L25:
 123:RTC.c         **** 				DDR_USI |=  (1 << PORT_USI_SDA);
 497               		.loc 1 123 5 is_stmt 1
 123:RTC.c         **** 				DDR_USI |=  (1 << PORT_USI_SDA);
 498               		.loc 1 123 13 is_stmt 0
 499 0126 D69A      		sbi 0x1a,6
 124:RTC.c         **** 				break;
 500               		.loc 1 124 5 is_stmt 1
 501 0128 00C0      		rjmp .L23
 502               	.L22:
 127:RTC.c         **** 				DDR_USI &= ~(1 << PORT_USI_SDA);
 503               		.loc 1 127 5
 127:RTC.c         **** 				DDR_USI &= ~(1 << PORT_USI_SDA);
 504               		.loc 1 127 13 is_stmt 0
 505 012a D698      		cbi 0x1a,6
 128:RTC.c         **** 				(*msg) = i2c_in_transfer(0b11110000 | (0x00<<USICNT0));			
 506               		.loc 1 128 5 is_stmt 1
 128:RTC.c         **** 				(*msg) = i2c_in_transfer(0b11110000 | (0x00<<USICNT0));			
 507               		.loc 1 128 14 is_stmt 0
 508 012c 80EF      		ldi r24,lo8(-16)
 509 012e 00D0      		rcall i2c_in_transfer
 510               	.LVL43:
 128:RTC.c         **** 				(*msg) = i2c_in_transfer(0b11110000 | (0x00<<USICNT0));			
 511               		.loc 1 128 12
 512 0130 8993      		st Y+,r24
 513               	.LVL44:
 129:RTC.c         **** 				msg++;
 514               		.loc 1 129 5 is_stmt 1
 130:RTC.c         **** 				DDR_USI |=  (1 << PORT_USI_SDA);				
 515               		.loc 1 130 5
 130:RTC.c         **** 				DDR_USI |=  (1 << PORT_USI_SDA);				
 516               		.loc 1 130 13 is_stmt 0
 517 0132 D69A      		sbi 0x1a,6
 131:RTC.c         **** 				if(msg_size == 1){
 518               		.loc 1 131 5 is_stmt 1
 131:RTC.c         **** 				if(msg_size == 1){
 519               		.loc 1 131 7 is_stmt 0
 520 0134 1130      		cpi r17,lo8(1)
 521 0136 01F4      		brne .L27
 132:RTC.c         **** 					USIDR = 0xFF;			//Load NACK to end transmission
 522               		.loc 1 132 6 is_stmt 1
 132:RTC.c         **** 					USIDR = 0xFF;			//Load NACK to end transmission
 523               		.loc 1 132 12 is_stmt 0
 524 0138 EFB8      		out 0xf,r14
 525               	.L28:
 136:RTC.c         **** 				i2c_in_transfer(0b11110000 | (0x0E<<USICNT0));
 526               		.loc 1 136 5 is_stmt 1
 527 013a 8EEF      		ldi r24,lo8(-2)
 528 013c 00D0      		rcall i2c_in_transfer
 529               	.LVL45:
 137:RTC.c         **** 				break;
 530               		.loc 1 137 5
 531 013e 00C0      		rjmp .L23
 532               	.L27:
 134:RTC.c         **** 					USIDR = 0x00;			//Load ACK
 533               		.loc 1 134 6
 134:RTC.c         **** 					USIDR = 0x00;			//Load ACK
 534               		.loc 1 134 12 is_stmt 0
 535 0140 1FB8      		out 0xf,__zero_reg__
 536 0142 00C0      		rjmp .L28
 537               		.cfi_endproc
 538               	.LFE13:
 540               	.global	i2c_write
 542               	i2c_write:
 543               	.LFB10:
  42:RTC.c         **** uint8_t i2c_write(uint8_t addr, uint8_t adrs, uint8_t val){ // only supports 1 byte write
 544               		.loc 1 42 59 is_stmt 1
 545               		.cfi_startproc
 546               	.LVL46:
 547 0144 CF93      		push r28
 548               	.LCFI6:
 549               		.cfi_def_cfa_offset 3
 550               		.cfi_offset 28, -2
 551 0146 DF93      		push r29
 552               	.LCFI7:
 553               		.cfi_def_cfa_offset 4
 554               		.cfi_offset 29, -3
 555 0148 00D0      		rcall .
 556 014a 0F92      		push __tmp_reg__
 557               	.LCFI8:
 558               		.cfi_def_cfa_offset 7
 559 014c CDB7      		in r28,__SP_L__
 560 014e DEB7      		in r29,__SP_H__
 561               	.LCFI9:
 562               		.cfi_def_cfa_register 28
 563               	/* prologue: function */
 564               	/* frame size = 3 */
 565               	/* stack size = 5 */
 566               	.L__stack_usage = 5
  43:RTC.c         **** 	uint8_t i2c_buffer[3];
 567               		.loc 1 43 2
  44:RTC.c         **** 	uint8_t i2c_buffer_len = 3;
 568               		.loc 1 44 2
 569               	.LVL47:
  45:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CWRITE ;
 570               		.loc 1 45 2
  45:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CWRITE ;
 571               		.loc 1 45 30 is_stmt 0
 572 0150 880F      		lsl r24
 573               	.LVL48:
  45:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CWRITE ;
 574               		.loc 1 45 16
 575 0152 8983      		std Y+1,r24
  46:RTC.c         **** 	i2c_buffer[1] = adrs;
 576               		.loc 1 46 2 is_stmt 1
  46:RTC.c         **** 	i2c_buffer[1] = adrs;
 577               		.loc 1 46 16 is_stmt 0
 578 0154 6A83      		std Y+2,r22
  47:RTC.c         **** 	i2c_buffer[2] = val;
 579               		.loc 1 47 2 is_stmt 1
  47:RTC.c         **** 	i2c_buffer[2] = val;
 580               		.loc 1 47 16 is_stmt 0
 581 0156 4B83      		std Y+3,r20
  48:RTC.c         **** 	return i2c_in_transmit(i2c_buffer, i2c_buffer_len);
 582               		.loc 1 48 2 is_stmt 1
  48:RTC.c         **** 	return i2c_in_transmit(i2c_buffer, i2c_buffer_len);
 583               		.loc 1 48 9 is_stmt 0
 584 0158 63E0      		ldi r22,lo8(3)
 585               	.LVL49:
 586 015a CE01      		movw r24,r28
 587 015c 0196      		adiw r24,1
 588 015e 00D0      		rcall i2c_in_transmit
 589               	.LVL50:
 590               	/* epilogue start */
  49:RTC.c         **** }
 591               		.loc 1 49 1
 592 0160 0F90      		pop __tmp_reg__
 593 0162 0F90      		pop __tmp_reg__
 594 0164 0F90      		pop __tmp_reg__
 595 0166 DF91      		pop r29
 596 0168 CF91      		pop r28
 597 016a 0895      		ret
 598               		.cfi_endproc
 599               	.LFE10:
 601               	.global	i2c_read
 603               	i2c_read:
 604               	.LFB11:
  50:RTC.c         **** uint8_t i2c_read(uint8_t addr, uint8_t len, uint8_t adrs, uint8_t *buf){
 605               		.loc 1 50 72 is_stmt 1
 606               		.cfi_startproc
 607               	.LVL51:
 608 016c AF92      		push r10
 609               	.LCFI10:
 610               		.cfi_def_cfa_offset 3
 611               		.cfi_offset 10, -2
 612 016e BF92      		push r11
 613               	.LCFI11:
 614               		.cfi_def_cfa_offset 4
 615               		.cfi_offset 11, -3
 616 0170 CF92      		push r12
 617               	.LCFI12:
 618               		.cfi_def_cfa_offset 5
 619               		.cfi_offset 12, -4
 620 0172 DF92      		push r13
 621               	.LCFI13:
 622               		.cfi_def_cfa_offset 6
 623               		.cfi_offset 13, -5
 624 0174 EF92      		push r14
 625               	.LCFI14:
 626               		.cfi_def_cfa_offset 7
 627               		.cfi_offset 14, -6
 628 0176 FF92      		push r15
 629               	.LCFI15:
 630               		.cfi_def_cfa_offset 8
 631               		.cfi_offset 15, -7
 632 0178 0F93      		push r16
 633               	.LCFI16:
 634               		.cfi_def_cfa_offset 9
 635               		.cfi_offset 16, -8
 636 017a 1F93      		push r17
 637               	.LCFI17:
 638               		.cfi_def_cfa_offset 10
 639               		.cfi_offset 17, -9
 640 017c CF93      		push r28
 641               	.LCFI18:
 642               		.cfi_def_cfa_offset 11
 643               		.cfi_offset 28, -10
 644 017e DF93      		push r29
 645               	.LCFI19:
 646               		.cfi_def_cfa_offset 12
 647               		.cfi_offset 29, -11
 648 0180 CDB7      		in r28,__SP_L__
 649 0182 DEB7      		in r29,__SP_H__
 650               	.LCFI20:
 651               		.cfi_def_cfa_register 28
 652               	/* prologue: function */
 653               	/* frame size = 0 */
 654               	/* stack size = 10 */
 655               	.L__stack_usage = 10
 656 0184 182F      		mov r17,r24
 657 0186 062F      		mov r16,r22
 658 0188 5901      		movw r10,r18
  69:RTC.c         **** }
 659               		.loc 1 69 1 is_stmt 0
 660 018a CDB6      		in r12,__SP_L__
 661 018c DEB6      		in r13,__SP_H__
  52:RTC.c         **** 	uint8_t i2c_buffer[len+1];
 662               		.loc 1 52 2 is_stmt 1
 663               	.LVL52:
  52:RTC.c         **** 	uint8_t i2c_buffer[len+1];
 664               		.loc 1 52 24 is_stmt 0
 665 018e 862F      		mov r24,r22
 666               	.LVL53:
 667 0190 90E0      		ldi r25,0
 668 0192 0196      		adiw r24,1
  52:RTC.c         **** 	uint8_t i2c_buffer[len+1];
 669               		.loc 1 52 10
 670 0194 2DB7      		in r18,__SP_L__
 671 0196 3EB7      		in r19,__SP_H__
 672               	.LVL54:
 673 0198 281B      		sub r18,r24
 674 019a 390B      		sbc r19,r25
 675 019c 0FB6      		in __tmp_reg__,__SREG__
 676 019e F894      		cli
 677 01a0 3EBF      		out __SP_H__,r19
 678 01a2 0FBE      		out __SREG__,__tmp_reg__
 679 01a4 2DBF      		out __SP_L__,r18
 680 01a6 8DB7      		in r24,__SP_L__
 681 01a8 9EB7      		in r25,__SP_H__
 682 01aa 0196      		adiw r24,1
 683 01ac 7C01      		movw r14,r24
 684               	.LVL55:
  53:RTC.c         **** 	uint8_t i2c_buffer_len = 2;
 685               		.loc 1 53 2 is_stmt 1
  54:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CWRITE;
 686               		.loc 1 54 2
  54:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CWRITE;
 687               		.loc 1 54 30 is_stmt 0
 688 01ae 812F      		mov r24,r17
 689 01b0 880F      		lsl r24
  54:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CWRITE;
 690               		.loc 1 54 16
 691 01b2 ADB7      		in r26,__SP_L__
 692 01b4 BEB7      		in r27,__SP_H__
 693 01b6 1196      		adiw r26,1
 694 01b8 8C93      		st X,r24
  55:RTC.c         **** 	i2c_buffer[1] = adrs;
 695               		.loc 1 55 2 is_stmt 1
  55:RTC.c         **** 	i2c_buffer[1] = adrs;
 696               		.loc 1 55 16 is_stmt 0
 697 01ba F701      		movw r30,r14
 698 01bc 4183      		std Z+1,r20
  56:RTC.c         **** 	i2c_in_transmit(i2c_buffer, i2c_buffer_len);
 699               		.loc 1 56 2 is_stmt 1
 700 01be 62E0      		ldi r22,lo8(2)
 701               	.LVL56:
 702 01c0 C701      		movw r24,r14
 703 01c2 00D0      		rcall i2c_in_transmit
 704               	.LVL57:
  58:RTC.c         **** 	i2c_buffer_len = len+1;
 705               		.loc 1 58 2
  59:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CREAD;
 706               		.loc 1 59 2
  59:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CREAD;
 707               		.loc 1 59 24 is_stmt 0
 708 01c4 110F      		lsl r17
 709               	.LVL58:
  59:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CREAD;
 710               		.loc 1 59 30
 711 01c6 1160      		ori r17,lo8(1)
  59:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CREAD;
 712               		.loc 1 59 16
 713 01c8 D701      		movw r26,r14
 714 01ca 1C93      		st X,r17
  60:RTC.c         **** 	if(i2c_in_transmit(i2c_buffer, i2c_buffer_len)){
 715               		.loc 1 60 2 is_stmt 1
  58:RTC.c         **** 	i2c_buffer_len = len+1;
 716               		.loc 1 58 17 is_stmt 0
 717 01cc 61E0      		ldi r22,lo8(1)
 718 01ce 600F      		add r22,r16
 719               	.LVL59:
  60:RTC.c         **** 	if(i2c_in_transmit(i2c_buffer, i2c_buffer_len)){
 720               		.loc 1 60 5
 721 01d0 C701      		movw r24,r14
 722 01d2 00D0      		rcall i2c_in_transmit
 723               	.LVL60:
  60:RTC.c         **** 	if(i2c_in_transmit(i2c_buffer, i2c_buffer_len)){
 724               		.loc 1 60 4
 725 01d4 8111      		cpse r24,__zero_reg__
 726 01d6 00C0      		rjmp .L47
 727               	.L43:
  69:RTC.c         **** }
 728               		.loc 1 69 1
 729 01d8 0FB6      		in __tmp_reg__,__SREG__
 730 01da F894      		cli
 731 01dc DEBE      		out __SP_H__,r13
 732 01de 0FBE      		out __SREG__,__tmp_reg__
 733 01e0 CDBE      		out __SP_L__,r12
 734               	/* epilogue start */
 735 01e2 DF91      		pop r29
 736 01e4 CF91      		pop r28
 737 01e6 1F91      		pop r17
 738 01e8 0F91      		pop r16
 739               	.LVL61:
 740 01ea FF90      		pop r15
 741 01ec EF90      		pop r14
 742               	.LVL62:
 743 01ee DF90      		pop r13
 744 01f0 CF90      		pop r12
 745 01f2 BF90      		pop r11
 746 01f4 AF90      		pop r10
 747               	.LVL63:
 748 01f6 0895      		ret
 749               	.LVL64:
 750               	.L46:
 751               	.LBB34:
  63:RTC.c         **** 			buf[i-1]=i2c_buffer[i];
 752               		.loc 1 63 4 is_stmt 1 discriminator 3
  63:RTC.c         **** 			buf[i-1]=i2c_buffer[i];
 753               		.loc 1 63 7 is_stmt 0 discriminator 3
 754 01f8 282F      		mov r18,r24
 755 01fa 30E0      		ldi r19,0
  63:RTC.c         **** 			buf[i-1]=i2c_buffer[i];
 756               		.loc 1 63 12 discriminator 3
 757 01fc F501      		movw r30,r10
 758 01fe E20F      		add r30,r18
 759 0200 F31F      		adc r31,r19
 760 0202 3197      		sbiw r30,1
  63:RTC.c         **** 			buf[i-1]=i2c_buffer[i];
 761               		.loc 1 63 23 discriminator 3
 762 0204 2E0D      		add r18,r14
 763 0206 3F1D      		adc r19,r15
  63:RTC.c         **** 			buf[i-1]=i2c_buffer[i];
 764               		.loc 1 63 12 discriminator 3
 765 0208 D901      		movw r26,r18
 766 020a 9C91      		ld r25,X
 767 020c 9083      		st Z,r25
  62:RTC.c         **** 		for(i=1;i<len+1;i++){ // fetch in buffer
 768               		.loc 1 62 20 discriminator 3
 769 020e 8F5F      		subi r24,lo8(-(1))
 770               	.LVL65:
 771               	.L44:
  62:RTC.c         **** 		for(i=1;i<len+1;i++){ // fetch in buffer
 772               		.loc 1 62 3 discriminator 1
 773 0210 0817      		cp r16,r24
 774 0212 00F4      		brsh .L46
  65:RTC.c         **** 		return 1; // provide success check
 775               		.loc 1 65 10
 776 0214 81E0      		ldi r24,lo8(1)
 777               	.LVL66:
 778 0216 00C0      		rjmp .L43
 779               	.L47:
  62:RTC.c         **** 		for(i=1;i<len+1;i++){ // fetch in buffer
 780               		.loc 1 62 8
 781 0218 81E0      		ldi r24,lo8(1)
 782 021a 00C0      		rjmp .L44
 783               	.LBE34:
 784               		.cfi_endproc
 785               	.LFE11:
 787               	.global	RTC_readTime
 789               	RTC_readTime:
 790               	.LFB9:
  30:RTC.c         **** uint8_t RTC_readTime(struct Ttime *t){
 791               		.loc 1 30 38 is_stmt 1
 792               		.cfi_startproc
 793               	.LVL67:
 794 021c 0F93      		push r16
 795               	.LCFI21:
 796               		.cfi_def_cfa_offset 3
 797               		.cfi_offset 16, -2
 798 021e 1F93      		push r17
 799               	.LCFI22:
 800               		.cfi_def_cfa_offset 4
 801               		.cfi_offset 17, -3
 802 0220 CF93      		push r28
 803               	.LCFI23:
 804               		.cfi_def_cfa_offset 5
 805               		.cfi_offset 28, -4
 806 0222 DF93      		push r29
 807               	.LCFI24:
 808               		.cfi_def_cfa_offset 6
 809               		.cfi_offset 29, -5
 810 0224 00D0      		rcall .
 811 0226 00D0      		rcall .
 812 0228 00D0      		rcall .
 813 022a 0F92      		push __tmp_reg__
 814               	.LCFI25:
 815               		.cfi_def_cfa_offset 13
 816 022c CDB7      		in r28,__SP_L__
 817 022e DEB7      		in r29,__SP_H__
 818               	.LCFI26:
 819               		.cfi_def_cfa_register 28
 820               	/* prologue: function */
 821               	/* frame size = 7 */
 822               	/* stack size = 11 */
 823               	.L__stack_usage = 11
 824 0230 8C01      		movw r16,r24
  31:RTC.c         **** 	uint8_t data[7] = {0};
 825               		.loc 1 31 2
  31:RTC.c         **** 	uint8_t data[7] = {0};
 826               		.loc 1 31 10 is_stmt 0
 827 0232 9E01      		movw r18,r28
 828 0234 2F5F      		subi r18,-1
 829 0236 3F4F      		sbci r19,-1
 830 0238 87E0      		ldi r24,lo8(7)
 831               	.LVL68:
 832 023a F901      		movw r30,r18
 833               		0:
 834 023c 1192      		st Z+,__zero_reg__
 835 023e 8A95      		dec r24
 836 0240 01F4      		brne 0b
  32:RTC.c         **** 	if(i2c_read(RTC_addr,7,0x00,data)){
 837               		.loc 1 32 2 is_stmt 1
  32:RTC.c         **** 	if(i2c_read(RTC_addr,7,0x00,data)){
 838               		.loc 1 32 5 is_stmt 0
 839 0242 40E0      		ldi r20,0
 840 0244 67E0      		ldi r22,lo8(7)
 841 0246 88E6      		ldi r24,lo8(104)
 842 0248 00D0      		rcall i2c_read
 843               	.LVL69:
  32:RTC.c         **** 	if(i2c_read(RTC_addr,7,0x00,data)){
 844               		.loc 1 32 4
 845 024a 8823      		tst r24
 846 024c 01F0      		breq .L48
  33:RTC.c         **** 		t->hour = bcdToDec(data[2]);
 847               		.loc 1 33 3 is_stmt 1
  33:RTC.c         **** 		t->hour = bcdToDec(data[2]);
 848               		.loc 1 33 13 is_stmt 0
 849 024e 8B81      		ldd r24,Y+3
 850 0250 00D0      		rcall bcdToDec
 851               	.LVL70:
  33:RTC.c         **** 		t->hour = bcdToDec(data[2]);
 852               		.loc 1 33 11
 853 0252 F801      		movw r30,r16
 854 0254 8083      		st Z,r24
  34:RTC.c         **** 		t->min = bcdToDec(data[1]);
 855               		.loc 1 34 3 is_stmt 1
  34:RTC.c         **** 		t->min = bcdToDec(data[1]);
 856               		.loc 1 34 12 is_stmt 0
 857 0256 8A81      		ldd r24,Y+2
 858 0258 00D0      		rcall bcdToDec
 859               	.LVL71:
  34:RTC.c         **** 		t->min = bcdToDec(data[1]);
 860               		.loc 1 34 10
 861 025a F801      		movw r30,r16
 862 025c 8183      		std Z+1,r24
  35:RTC.c         **** 		t->monthDay = bcdToDec(data[4]);
 863               		.loc 1 35 3 is_stmt 1
  35:RTC.c         **** 		t->monthDay = bcdToDec(data[4]);
 864               		.loc 1 35 17 is_stmt 0
 865 025e 8D81      		ldd r24,Y+5
 866 0260 00D0      		rcall bcdToDec
 867               	.LVL72:
  35:RTC.c         **** 		t->monthDay = bcdToDec(data[4]);
 868               		.loc 1 35 15
 869 0262 F801      		movw r30,r16
 870 0264 8283      		std Z+2,r24
  36:RTC.c         **** 		t->month = bcdToDec(data[5]);
 871               		.loc 1 36 3 is_stmt 1
  36:RTC.c         **** 		t->month = bcdToDec(data[5]);
 872               		.loc 1 36 14 is_stmt 0
 873 0266 8E81      		ldd r24,Y+6
 874 0268 00D0      		rcall bcdToDec
 875               	.LVL73:
  36:RTC.c         **** 		t->month = bcdToDec(data[5]);
 876               		.loc 1 36 12
 877 026a F801      		movw r30,r16
 878 026c 8383      		std Z+3,r24
  37:RTC.c         **** 		return 1;
 879               		.loc 1 37 3 is_stmt 1
  37:RTC.c         **** 		return 1;
 880               		.loc 1 37 10 is_stmt 0
 881 026e 81E0      		ldi r24,lo8(1)
 882               	.L48:
 883               	/* epilogue start */
  41:RTC.c         **** }
 884               		.loc 1 41 1
 885 0270 2796      		adiw r28,7
 886 0272 0FB6      		in __tmp_reg__,__SREG__
 887 0274 F894      		cli
 888 0276 DEBF      		out __SP_H__,r29
 889 0278 0FBE      		out __SREG__,__tmp_reg__
 890 027a CDBF      		out __SP_L__,r28
 891 027c DF91      		pop r29
 892 027e CF91      		pop r28
 893 0280 1F91      		pop r17
 894 0282 0F91      		pop r16
 895               	.LVL74:
 896 0284 0895      		ret
 897               		.cfi_endproc
 898               	.LFE9:
 900               		.comm	USI_I2C_Master_State,1,1
 901               		.comm	currentTime,5,1
 902               	.Letext0:
 903               		.file 3 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 904               		.file 4 "RTC.h"
DEFINED SYMBOLS
                            *ABS*:00000000 RTC.c
C:\Users\User\AppData\Local\Temp\ccG3zSEd.s:2      *ABS*:0000003e __SP_H__
C:\Users\User\AppData\Local\Temp\ccG3zSEd.s:3      *ABS*:0000003d __SP_L__
C:\Users\User\AppData\Local\Temp\ccG3zSEd.s:4      *ABS*:0000003f __SREG__
C:\Users\User\AppData\Local\Temp\ccG3zSEd.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\User\AppData\Local\Temp\ccG3zSEd.s:6      *ABS*:00000001 __zero_reg__
C:\Users\User\AppData\Local\Temp\ccG3zSEd.s:12     .text:00000000 setCurrentTime
                            *COM*:00000005 currentTime
C:\Users\User\AppData\Local\Temp\ccG3zSEd.s:44     .text:0000000e minquad
C:\Users\User\AppData\Local\Temp\ccG3zSEd.s:118    .text:0000003e bcdToDec
C:\Users\User\AppData\Local\Temp\ccG3zSEd.s:147    .text:0000004e i2c_in_transfer
C:\Users\User\AppData\Local\Temp\ccG3zSEd.s:240    .text:00000078 i2c_in_transmit
                            *COM*:00000001 USI_I2C_Master_State
C:\Users\User\AppData\Local\Temp\ccG3zSEd.s:542    .text:00000144 i2c_write
C:\Users\User\AppData\Local\Temp\ccG3zSEd.s:603    .text:0000016c i2c_read
C:\Users\User\AppData\Local\Temp\ccG3zSEd.s:789    .text:0000021c RTC_readTime

UNDEFINED SYMBOLS
__mulqi3
__do_clear_bss
