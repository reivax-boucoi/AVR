   1               		.file	"RTC.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	setCurrentTime
  12               	setCurrentTime:
  13               	.LFB6:
  14               		.file 1 "RTC.c"
   1:RTC.c         **** #include "RTC.h" 
   2:RTC.c         **** 
   3:RTC.c         **** void setCurrentTime(uint8_t hour,uint8_t min,uint8_t monthDay,uint8_t month){
  15               		.loc 1 3 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
   4:RTC.c         **** 	currentTime.hour=hour;
  22               		.loc 1 4 0
  23 0000 E0E0      		ldi r30,lo8(currentTime)
  24 0002 F0E0      		ldi r31,hi8(currentTime)
  25 0004 8083      		st Z,r24
   5:RTC.c         **** 	currentTime.min=min;
  26               		.loc 1 5 0
  27 0006 6183      		std Z+1,r22
   6:RTC.c         **** 	currentTime.monthDay=monthDay;
  28               		.loc 1 6 0
  29 0008 4283      		std Z+2,r20
   7:RTC.c         **** 	currentTime.month=month;
  30               		.loc 1 7 0
  31 000a 2383      		std Z+3,r18
  32 000c 0895      		ret
  33               		.cfi_endproc
  34               	.LFE6:
  36               	.global	minquad
  38               	minquad:
  39               	.LFB7:
   8:RTC.c         **** }
   9:RTC.c         **** 
  10:RTC.c         **** uint8_t minquad(uint8_t min){
  40               		.loc 1 10 0
  41               		.cfi_startproc
  42               	.LVL1:
  43               	/* prologue: function */
  44               	/* frame size = 0 */
  45               	/* stack size = 0 */
  46               	.L__stack_usage = 0
  11:RTC.c         **** 	if(min > 5){
  47               		.loc 1 11 0
  48 000e 8630      		cpi r24,lo8(6)
  49 0010 00F0      		brlo .L9
  12:RTC.c         **** 		if(min > 15){
  50               		.loc 1 12 0
  51 0012 8031      		cpi r24,lo8(16)
  52 0014 00F0      		brlo .L5
  13:RTC.c         **** 			if(min > 25){
  53               		.loc 1 13 0
  54 0016 8A31      		cpi r24,lo8(26)
  55 0018 00F0      		brlo .L6
  14:RTC.c         **** 				if(min > 35){
  56               		.loc 1 14 0
  57 001a 8432      		cpi r24,lo8(36)
  58 001c 00F0      		brlo .L7
  15:RTC.c         **** 					if(min > 45){
  59               		.loc 1 15 0
  60 001e 8E32      		cpi r24,lo8(46)
  61 0020 00F0      		brlo .L8
  16:RTC.c         **** 						if(min > 55){
  62               		.loc 1 16 0
  63 0022 8833      		cpi r24,lo8(56)
  64 0024 00F4      		brsh .L9
  17:RTC.c         **** 							return 0;
  18:RTC.c         **** 						}else{return 50;}
  65               		.loc 1 18 0
  66 0026 82E3      		ldi r24,lo8(50)
  67               	.LVL2:
  68 0028 0895      		ret
  69               	.LVL3:
  70               	.L5:
  19:RTC.c         **** 					}else{return 40;}
  20:RTC.c         **** 				}else{return 30;}
  21:RTC.c         **** 			}else{return 20;}
  22:RTC.c         **** 		}else{return 10;}
  71               		.loc 1 22 0
  72 002a 8AE0      		ldi r24,lo8(10)
  73               	.LVL4:
  74 002c 0895      		ret
  75               	.LVL5:
  76               	.L6:
  21:RTC.c         **** 		}else{return 10;}
  77               		.loc 1 21 0
  78 002e 84E1      		ldi r24,lo8(20)
  79               	.LVL6:
  80 0030 0895      		ret
  81               	.LVL7:
  82               	.L7:
  20:RTC.c         **** 			}else{return 20;}
  83               		.loc 1 20 0
  84 0032 8EE1      		ldi r24,lo8(30)
  85               	.LVL8:
  86 0034 0895      		ret
  87               	.LVL9:
  88               	.L8:
  19:RTC.c         **** 					}else{return 40;}
  89               		.loc 1 19 0
  90 0036 88E2      		ldi r24,lo8(40)
  91               	.LVL10:
  92 0038 0895      		ret
  93               	.LVL11:
  94               	.L9:
  23:RTC.c         **** 	}else{return 0;}
  95               		.loc 1 23 0
  96 003a 80E0      		ldi r24,0
  97               	.LVL12:
  24:RTC.c         **** }
  98               		.loc 1 24 0
  99 003c 0895      		ret
 100               		.cfi_endproc
 101               	.LFE7:
 103               	.global	bcdToDec
 105               	bcdToDec:
 106               	.LFB8:
  25:RTC.c         **** 
  26:RTC.c         **** uint8_t bcdToDec(uint8_t val){
 107               		.loc 1 26 0
 108               		.cfi_startproc
 109               	.LVL13:
 110               	/* prologue: function */
 111               	/* frame size = 0 */
 112               	/* stack size = 0 */
 113               	.L__stack_usage = 0
 114 003e 982F      		mov r25,r24
  27:RTC.c         ****   return ((val/16*10) + (val%16));
 115               		.loc 1 27 0
 116 0040 8295      		swap r24
 117               	.LVL14:
 118 0042 8F70      		andi r24,lo8(15)
 119 0044 6AE0      		ldi r22,lo8(10)
 120 0046 00D0      		rcall __mulqi3
 121 0048 9F70      		andi r25,lo8(15)
 122               	.LVL15:
  28:RTC.c         **** }
 123               		.loc 1 28 0
 124 004a 890F      		add r24,r25
 125 004c 0895      		ret
 126               		.cfi_endproc
 127               	.LFE8:
 129               	.global	i2c_in_transfer
 131               	i2c_in_transfer:
 132               	.LFB12:
  29:RTC.c         **** 
  30:RTC.c         **** uint8_t RTC_readTime(struct Ttime *t){
  31:RTC.c         **** 	uint8_t data[7] = {0};
  32:RTC.c         **** 	if(i2c_read(RTC_addr,7,0x00,data)){
  33:RTC.c         **** 		t->hour = bcdToDec(data[2]);
  34:RTC.c         **** 		t->min = bcdToDec(data[1]);
  35:RTC.c         **** 		t->monthDay = bcdToDec(data[4]);
  36:RTC.c         **** 		t->month = bcdToDec(data[5]);
  37:RTC.c         **** 		return 1;
  38:RTC.c         **** 	}else{
  39:RTC.c         **** 		return 0;
  40:RTC.c         **** 	}
  41:RTC.c         **** }
  42:RTC.c         **** uint8_t i2c_write(uint8_t addr, uint8_t adrs, uint8_t val){ // only supports 1 byte write
  43:RTC.c         **** 	uint8_t i2c_buffer[3];
  44:RTC.c         **** 	uint8_t i2c_buffer_len = 3;
  45:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CWRITE ;
  46:RTC.c         **** 	i2c_buffer[1] = adrs;
  47:RTC.c         **** 	i2c_buffer[2] = val;
  48:RTC.c         **** 	return i2c_in_transmit(i2c_buffer, i2c_buffer_len);
  49:RTC.c         **** }
  50:RTC.c         **** uint8_t i2c_read(uint8_t addr, uint8_t len, uint8_t adrs, uint8_t *buf){
  51:RTC.c         **** 	//set register pointer to adrs
  52:RTC.c         **** 	uint8_t i2c_buffer[len+1];
  53:RTC.c         **** 	uint8_t i2c_buffer_len = 2;
  54:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CWRITE;
  55:RTC.c         **** 	i2c_buffer[1] = adrs;
  56:RTC.c         **** 	i2c_in_transmit(i2c_buffer, i2c_buffer_len);
  57:RTC.c         **** 	//read actual data
  58:RTC.c         **** 	i2c_buffer_len = len+1;
  59:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CREAD;
  60:RTC.c         **** 	if(i2c_in_transmit(i2c_buffer, i2c_buffer_len)){
  61:RTC.c         **** 		uint8_t i;
  62:RTC.c         **** 		for(i=1;i<len+1;i++){ // fetch in buffer
  63:RTC.c         **** 			buf[i-1]=i2c_buffer[i];
  64:RTC.c         **** 		}
  65:RTC.c         **** 		return 1; // provide success check
  66:RTC.c         **** 	}else{
  67:RTC.c         **** 		return 0;
  68:RTC.c         **** 	}
  69:RTC.c         **** }
  70:RTC.c         **** 
  71:RTC.c         **** uint8_t i2c_in_transfer(uint8_t USISR_temp){
 133               		.loc 1 71 0
 134               		.cfi_startproc
 135               	.LVL16:
 136               	/* prologue: function */
 137               	/* frame size = 0 */
 138               	/* stack size = 0 */
 139               	.L__stack_usage = 0
  72:RTC.c         **** 	USISR = USISR_temp;								//Set USISR as requested by calling function
 140               		.loc 1 72 0
 141 004e 8EB9      		out 0xe,r24
  73:RTC.c         **** 	do{
  74:RTC.c         **** 		_delay_us(I2C_TLOW);
  75:RTC.c         **** 		USICR = 0b00101011;								//SCL Positive Edge
 142               		.loc 1 75 0
 143 0050 8BE2      		ldi r24,lo8(43)
 144               	.LVL17:
 145               	.L14:
 146               	.LBB18:
 147               	.LBB19:
 148               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 149               		.loc 2 276 0
 150 0052 95E0      		ldi r25,lo8(5)
 151 0054 9A95      	1:	dec r25
 152 0056 01F4      		brne 1b
 153 0058 0000      		nop
 154               	.LVL18:
 155               	.LBE19:
 156               	.LBE18:
 157               		.loc 1 75 0
 158 005a 8DB9      		out 0xd,r24
 159               	.L13:
  76:RTC.c         **** 		while (!(PIN_USI&(1<<PIN_USI_SCL)));		//Wait for SCL to go high
 160               		.loc 1 76 0 discriminator 1
 161 005c CC9B      		sbis 0x19,4
 162 005e 00C0      		rjmp .L13
 163               	.LVL19:
 164               	.LBB20:
 165               	.LBB21:
 166               		.loc 2 276 0
 167 0060 94E0      		ldi r25,lo8(4)
 168 0062 9A95      	1:	dec r25
 169 0064 01F4      		brne 1b
 170               	.LVL20:
 171               	.LBE21:
 172               	.LBE20:
  77:RTC.c         **** 		_delay_us(I2C_THIGH);
  78:RTC.c         **** 		USICR = 0b00101011;								//SCL Negative Edge
 173               		.loc 1 78 0
 174 0066 8DB9      		out 0xd,r24
  79:RTC.c         **** 	}while (!(USISR&(1<<USIOIF)));					//Do until transfer is complete
 175               		.loc 1 79 0
 176 0068 769B      		sbis 0xe,6
 177 006a 00C0      		rjmp .L14
 178               	.LVL21:
 179               	.LBB22:
 180               	.LBB23:
 181               		.loc 2 276 0
 182 006c 85E0      		ldi r24,lo8(5)
 183 006e 8A95      	1:	dec r24
 184 0070 01F4      		brne 1b
 185 0072 0000      		nop
 186               	.LVL22:
 187               	.LBE23:
 188               	.LBE22:
  80:RTC.c         **** 	_delay_us(I2C_TLOW);
  81:RTC.c         **** 	return USIDR;
 189               		.loc 1 81 0
 190 0074 8FB1      		in r24,0xf
  82:RTC.c         **** }
 191               		.loc 1 82 0
 192 0076 0895      		ret
 193               		.cfi_endproc
 194               	.LFE12:
 196               	.global	i2c_in_transmit
 198               	i2c_in_transmit:
 199               	.LFB13:
  83:RTC.c         **** uint8_t i2c_in_transmit(uint8_t *msg, uint8_t msg_size){
 200               		.loc 1 83 0
 201               		.cfi_startproc
 202               	.LVL23:
 203 0078 EF92      		push r14
 204               	.LCFI0:
 205               		.cfi_def_cfa_offset 3
 206               		.cfi_offset 14, -2
 207 007a FF92      		push r15
 208               	.LCFI1:
 209               		.cfi_def_cfa_offset 4
 210               		.cfi_offset 15, -3
 211 007c 0F93      		push r16
 212               	.LCFI2:
 213               		.cfi_def_cfa_offset 5
 214               		.cfi_offset 16, -4
 215 007e 1F93      		push r17
 216               	.LCFI3:
 217               		.cfi_def_cfa_offset 6
 218               		.cfi_offset 17, -5
 219 0080 CF93      		push r28
 220               	.LCFI4:
 221               		.cfi_def_cfa_offset 7
 222               		.cfi_offset 28, -6
 223 0082 DF93      		push r29
 224               	.LCFI5:
 225               		.cfi_def_cfa_offset 8
 226               		.cfi_offset 29, -7
 227               	/* prologue: function */
 228               	/* frame size = 0 */
 229               	/* stack size = 6 */
 230               	.L__stack_usage = 6
 231 0084 EC01      		movw r28,r24
 232 0086 162F      		mov r17,r22
  84:RTC.c         **** 	USI_I2C_Master_State = USI_ADDRESS;
 233               		.loc 1 84 0
 234 0088 1092 0000 		sts USI_I2C_Master_State,__zero_reg__
  85:RTC.c         **** 
  86:RTC.c         **** 	//   Start Condition
  87:RTC.c         **** 	PORT_USI |=  (1 << PORT_USI_SCL); 						//Setting input makes line pull high
 235               		.loc 1 87 0
 236 008c DC9A      		sbi 0x1b,4
 237               	.L20:
  88:RTC.c         **** 	while (!(PIN_USI & (1<<PIN_USI_SCL)));		//Wait for SCL to go high
 238               		.loc 1 88 0 discriminator 1
 239 008e CC9B      		sbis 0x19,4
 240 0090 00C0      		rjmp .L20
 241               	.LVL24:
 242               	.LBB24:
 243               	.LBB25:
 244               		.loc 2 276 0
 245 0092 84E0      		ldi r24,lo8(4)
 246 0094 8A95      	1:	dec r24
 247 0096 01F4      		brne 1b
 248               	.LVL25:
 249               	.LBE25:
 250               	.LBE24:
  89:RTC.c         **** 
  90:RTC.c         **** 	#ifdef I2C_FAST_MODE
  91:RTC.c         **** 		_delay_us(I2C_THIGH);
  92:RTC.c         **** 	#else
  93:RTC.c         **** 		_delay_us(I2C_TLOW);
  94:RTC.c         **** 	#endif
  95:RTC.c         **** 	DDR_USI |=  (1 << PORT_USI_SDA);
 251               		.loc 1 95 0
 252 0098 D69A      		sbi 0x1a,6
  96:RTC.c         **** 	DDR_USI |=  (1 << PORT_USI_SCL);
 253               		.loc 1 96 0
 254 009a D49A      		sbi 0x1a,4
  97:RTC.c         **** 	PORT_USI &= ~(1 << PORT_USI_SDA);
 255               		.loc 1 97 0
 256 009c DE98      		cbi 0x1b,6
 257               	.LVL26:
 258               	.LBB26:
 259               	.LBB27:
 260               		.loc 2 276 0
 261 009e 84E0      		ldi r24,lo8(4)
 262 00a0 8A95      	1:	dec r24
 263 00a2 01F4      		brne 1b
 264               	.LVL27:
 265               	.LBE27:
 266               	.LBE26:
  98:RTC.c         **** 	_delay_us(I2C_THIGH);;
  99:RTC.c         **** 	PORT_USI &= ~(1 << PORT_USI_SCL);
 267               		.loc 1 99 0
 268 00a4 DC98      		cbi 0x1b,4
 269               	.LVL28:
 270               	.LBB28:
 271               	.LBB29:
 272               		.loc 2 276 0
 273 00a6 85E0      		ldi r24,lo8(5)
 274 00a8 8A95      	1:	dec r24
 275 00aa 01F4      		brne 1b
 276 00ac 0000      		nop
 277               	.LVL29:
 278               	.LBE29:
 279               	.LBE28:
 100:RTC.c         **** 	_delay_us(I2C_TLOW);
 101:RTC.c         **** 	PORT_USI |=  (1 << PORT_USI_SDA);
 280               		.loc 1 101 0
 281 00ae DE9A      		sbi 0x1b,6
 102:RTC.c         **** 	
 103:RTC.c         **** 	do{
 104:RTC.c         **** 		switch(USI_I2C_Master_State){
 105:RTC.c         **** 			case USI_ADDRESS:
 106:RTC.c         **** 				if(!(*msg & 0x01)){
 107:RTC.c         **** 					USI_I2C_Master_State = USI_WRITE;
 108:RTC.c         **** 				}else{
 109:RTC.c         **** 					USI_I2C_Master_State = USI_READ;
 282               		.loc 1 109 0
 283 00b0 02E0      		ldi r16,lo8(2)
 107:RTC.c         **** 				}else{
 284               		.loc 1 107 0
 285 00b2 FF24      		clr r15
 286 00b4 F394      		inc r15
 110:RTC.c         **** 				}//no break so goes to Write
 111:RTC.c         **** 				
 112:RTC.c         **** 			case USI_WRITE:
 113:RTC.c         **** 				PORT_USI &= ~(1 << PORT_USI_SCL);
 114:RTC.c         **** 				USIDR = *(msg);				//Load data			
 115:RTC.c         **** 				msg++;						//Increment buffer pointer
 116:RTC.c         **** 				i2c_in_transfer(0b11110000 | (0x00<<USICNT0));
 117:RTC.c         **** 				DDR_USI &= ~(1 << PORT_USI_SDA);
 118:RTC.c         **** 				if(i2c_in_transfer(0b11110000 | (0x0E<<USICNT0)) & 0x01){
 119:RTC.c         **** 					PORT_USI |=  (1 << PORT_USI_SCL);
 120:RTC.c         **** 					PORT_USI |=  (1 << PORT_USI_SDA);
 121:RTC.c         **** 					return 0;
 122:RTC.c         **** 				}
 123:RTC.c         **** 				DDR_USI |=  (1 << PORT_USI_SDA);
 124:RTC.c         **** 				break;
 125:RTC.c         **** 
 126:RTC.c         **** 			case USI_READ:
 127:RTC.c         **** 				DDR_USI &= ~(1 << PORT_USI_SDA);
 128:RTC.c         **** 				(*msg) = i2c_in_transfer(0b11110000 | (0x00<<USICNT0));			
 129:RTC.c         **** 				msg++;
 130:RTC.c         **** 				DDR_USI |=  (1 << PORT_USI_SDA);				
 131:RTC.c         **** 				if(msg_size == 1){
 132:RTC.c         **** 					USIDR = 0xFF;			//Load NACK to end transmission
 287               		.loc 1 132 0
 288 00b6 EE24      		clr r14
 289 00b8 EA94      		dec r14
 290               	.LVL30:
 291               	.L30:
 104:RTC.c         **** 			case USI_ADDRESS:
 292               		.loc 1 104 0
 293 00ba 8091 0000 		lds r24,USI_I2C_Master_State
 294 00be 8130      		cpi r24,lo8(1)
 295 00c0 01F0      		breq .L22
 296 00c2 00F0      		brlo .L23
 297 00c4 8230      		cpi r24,lo8(2)
 298 00c6 01F0      		breq .L24
 299 00c8 00C0      		rjmp .L21
 300               	.L23:
 106:RTC.c         **** 					USI_I2C_Master_State = USI_WRITE;
 301               		.loc 1 106 0
 302 00ca 8881      		ld r24,Y
 303 00cc 80FD      		sbrc r24,0
 304 00ce 00C0      		rjmp .L25
 107:RTC.c         **** 				}else{
 305               		.loc 1 107 0
 306 00d0 F092 0000 		sts USI_I2C_Master_State,r15
 307 00d4 00C0      		rjmp .L22
 308               	.L25:
 109:RTC.c         **** 				}//no break so goes to Write
 309               		.loc 1 109 0
 310 00d6 0093 0000 		sts USI_I2C_Master_State,r16
 311               	.L22:
 113:RTC.c         **** 				USIDR = *(msg);				//Load data			
 312               		.loc 1 113 0
 313 00da DC98      		cbi 0x1b,4
 114:RTC.c         **** 				msg++;						//Increment buffer pointer
 314               		.loc 1 114 0
 315 00dc 8991      		ld r24,Y+
 316               	.LVL31:
 317 00de 8FB9      		out 0xf,r24
 318               	.LVL32:
 116:RTC.c         **** 				DDR_USI &= ~(1 << PORT_USI_SDA);
 319               		.loc 1 116 0
 320 00e0 80EF      		ldi r24,lo8(-16)
 321 00e2 00D0      		rcall i2c_in_transfer
 322               	.LVL33:
 117:RTC.c         **** 				if(i2c_in_transfer(0b11110000 | (0x0E<<USICNT0)) & 0x01){
 323               		.loc 1 117 0
 324 00e4 D698      		cbi 0x1a,6
 118:RTC.c         **** 					PORT_USI |=  (1 << PORT_USI_SCL);
 325               		.loc 1 118 0
 326 00e6 8EEF      		ldi r24,lo8(-2)
 327 00e8 00D0      		rcall i2c_in_transfer
 328               	.LVL34:
 329 00ea 80FF      		sbrs r24,0
 330 00ec 00C0      		rjmp .L26
 119:RTC.c         **** 					PORT_USI |=  (1 << PORT_USI_SDA);
 331               		.loc 1 119 0
 332 00ee DC9A      		sbi 0x1b,4
 120:RTC.c         **** 					return 0;
 333               		.loc 1 120 0
 334 00f0 DE9A      		sbi 0x1b,6
 121:RTC.c         **** 				}
 335               		.loc 1 121 0
 336 00f2 80E0      		ldi r24,0
 337 00f4 00C0      		rjmp .L27
 338               	.L26:
 123:RTC.c         **** 				break;
 339               		.loc 1 123 0
 340 00f6 D69A      		sbi 0x1a,6
 124:RTC.c         **** 
 341               		.loc 1 124 0
 342 00f8 00C0      		rjmp .L21
 343               	.L24:
 127:RTC.c         **** 				(*msg) = i2c_in_transfer(0b11110000 | (0x00<<USICNT0));			
 344               		.loc 1 127 0
 345 00fa D698      		cbi 0x1a,6
 128:RTC.c         **** 				msg++;
 346               		.loc 1 128 0
 347 00fc 80EF      		ldi r24,lo8(-16)
 348 00fe 00D0      		rcall i2c_in_transfer
 349               	.LVL35:
 350 0100 8993      		st Y+,r24
 351               	.LVL36:
 130:RTC.c         **** 				if(msg_size == 1){
 352               		.loc 1 130 0
 353 0102 D69A      		sbi 0x1a,6
 131:RTC.c         **** 					USIDR = 0xFF;			//Load NACK to end transmission
 354               		.loc 1 131 0
 355 0104 1130      		cpi r17,lo8(1)
 356 0106 01F4      		brne .L28
 357               		.loc 1 132 0
 358 0108 EFB8      		out 0xf,r14
 359 010a 00C0      		rjmp .L29
 360               	.L28:
 133:RTC.c         **** 				}else{
 134:RTC.c         **** 					USIDR = 0x00;			//Load ACK
 361               		.loc 1 134 0
 362 010c 1FB8      		out 0xf,__zero_reg__
 363               	.L29:
 135:RTC.c         **** 				}
 136:RTC.c         **** 				i2c_in_transfer(0b11110000 | (0x0E<<USICNT0));
 364               		.loc 1 136 0
 365 010e 8EEF      		ldi r24,lo8(-2)
 366 0110 00D0      		rcall i2c_in_transfer
 367               	.LVL37:
 368               	.L21:
 137:RTC.c         **** 				break;
 138:RTC.c         **** 		}
 139:RTC.c         **** 	}while(--msg_size);
 369               		.loc 1 139 0
 370 0112 1150      		subi r17,lo8(-(-1))
 371               	.LVL38:
 372 0114 01F4      		brne .L30
 140:RTC.c         **** 	
 141:RTC.c         **** 	//Stop Condition
 142:RTC.c         **** 	PORT_USI &= ~(1 << PORT_USI_SDA);           				// Pull SDA low.
 373               		.loc 1 142 0
 374 0116 DE98      		cbi 0x1b,6
 375               	.LVL39:
 376               	.LBB30:
 377               	.LBB31:
 378               		.loc 2 276 0
 379 0118 85E0      		ldi r24,lo8(5)
 380 011a 8A95      	1:	dec r24
 381 011c 01F4      		brne 1b
 382 011e 0000      		nop
 383               	.LVL40:
 384               	.LBE31:
 385               	.LBE30:
 143:RTC.c         **** 	_delay_us(I2C_TLOW);
 144:RTC.c         **** 	DDR_USI &= ~(1 << PORT_USI_SCL);            				// Release SCL.
 386               		.loc 1 144 0
 387 0120 D498      		cbi 0x1a,4
 388               	.L31:
 145:RTC.c         **** 	while( !(PIN_USI & (1<<PIN_USI_SCL)) );  	// Wait for SCL to go high.  
 389               		.loc 1 145 0 discriminator 1
 390 0122 CC9B      		sbis 0x19,4
 391 0124 00C0      		rjmp .L31
 392               	.LVL41:
 393               	.LBB32:
 394               	.LBB33:
 395               		.loc 2 276 0
 396 0126 84E0      		ldi r24,lo8(4)
 397 0128 8A95      	1:	dec r24
 398 012a 01F4      		brne 1b
 399               	.LVL42:
 400               	.LBE33:
 401               	.LBE32:
 146:RTC.c         **** 	_delay_us(I2C_THIGH);
 147:RTC.c         **** 	DDR_USI &= ~(1 << PORT_USI_SDA);            				// Release SDA.
 402               		.loc 1 147 0
 403 012c D698      		cbi 0x1a,6
 404               	.L32:
 148:RTC.c         **** 	while( !(PIN_USI & (1<<PIN_USI_SDA)) );  	// Wait for SDA to go high. 
 405               		.loc 1 148 0 discriminator 1
 406 012e CE9B      		sbis 0x19,6
 407 0130 00C0      		rjmp .L32
 149:RTC.c         **** 	return 1;
 408               		.loc 1 149 0
 409 0132 81E0      		ldi r24,lo8(1)
 410               	.L27:
 411               	/* epilogue start */
 150:RTC.c         **** }...
 412               		.loc 1 150 0
 413 0134 DF91      		pop r29
 414 0136 CF91      		pop r28
 415               	.LVL43:
 416 0138 1F91      		pop r17
 417               	.LVL44:
 418 013a 0F91      		pop r16
 419 013c FF90      		pop r15
 420 013e EF90      		pop r14
 421 0140 0895      		ret
 422               		.cfi_endproc
 423               	.LFE13:
 425               	.global	i2c_write
 427               	i2c_write:
 428               	.LFB10:
  42:RTC.c         **** uint8_t i2c_write(uint8_t addr, uint8_t adrs, uint8_t val){ // only supports 1 byte write
 429               		.loc 1 42 0
 430               		.cfi_startproc
 431               	.LVL45:
 432 0142 CF93      		push r28
 433               	.LCFI6:
 434               		.cfi_def_cfa_offset 3
 435               		.cfi_offset 28, -2
 436 0144 DF93      		push r29
 437               	.LCFI7:
 438               		.cfi_def_cfa_offset 4
 439               		.cfi_offset 29, -3
 440 0146 00D0      		rcall .
 441 0148 1F92      		push __zero_reg__
 442               	.LCFI8:
 443               		.cfi_def_cfa_offset 7
 444 014a CDB7      		in r28,__SP_L__
 445 014c DEB7      		in r29,__SP_H__
 446               	.LCFI9:
 447               		.cfi_def_cfa_register 28
 448               	/* prologue: function */
 449               	/* frame size = 3 */
 450               	/* stack size = 5 */
 451               	.L__stack_usage = 5
 452               	.LVL46:
  45:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CWRITE ;
 453               		.loc 1 45 0
 454 014e 880F      		lsl r24
 455               	.LVL47:
 456 0150 8983      		std Y+1,r24
  46:RTC.c         **** 	i2c_buffer[1] = adrs;
 457               		.loc 1 46 0
 458 0152 6A83      		std Y+2,r22
  47:RTC.c         **** 	i2c_buffer[2] = val;
 459               		.loc 1 47 0
 460 0154 4B83      		std Y+3,r20
  48:RTC.c         **** 	return i2c_in_transmit(i2c_buffer, i2c_buffer_len);
 461               		.loc 1 48 0
 462 0156 63E0      		ldi r22,lo8(3)
 463               	.LVL48:
 464 0158 CE01      		movw r24,r28
 465 015a 0196      		adiw r24,1
 466 015c 00D0      		rcall i2c_in_transmit
 467               	.LVL49:
 468               	/* epilogue start */
  49:RTC.c         **** }
 469               		.loc 1 49 0
 470 015e 0F90      		pop __tmp_reg__
 471 0160 0F90      		pop __tmp_reg__
 472 0162 0F90      		pop __tmp_reg__
 473 0164 DF91      		pop r29
 474 0166 CF91      		pop r28
 475 0168 0895      		ret
 476               		.cfi_endproc
 477               	.LFE10:
 479               	.global	i2c_read
 481               	i2c_read:
 482               	.LFB11:
  50:RTC.c         **** uint8_t i2c_read(uint8_t addr, uint8_t len, uint8_t adrs, uint8_t *buf){
 483               		.loc 1 50 0
 484               		.cfi_startproc
 485               	.LVL50:
 486 016a 8F92      		push r8
 487               	.LCFI10:
 488               		.cfi_def_cfa_offset 3
 489               		.cfi_offset 8, -2
 490 016c 9F92      		push r9
 491               	.LCFI11:
 492               		.cfi_def_cfa_offset 4
 493               		.cfi_offset 9, -3
 494 016e AF92      		push r10
 495               	.LCFI12:
 496               		.cfi_def_cfa_offset 5
 497               		.cfi_offset 10, -4
 498 0170 BF92      		push r11
 499               	.LCFI13:
 500               		.cfi_def_cfa_offset 6
 501               		.cfi_offset 11, -5
 502 0172 CF92      		push r12
 503               	.LCFI14:
 504               		.cfi_def_cfa_offset 7
 505               		.cfi_offset 12, -6
 506 0174 DF92      		push r13
 507               	.LCFI15:
 508               		.cfi_def_cfa_offset 8
 509               		.cfi_offset 13, -7
 510 0176 EF92      		push r14
 511               	.LCFI16:
 512               		.cfi_def_cfa_offset 9
 513               		.cfi_offset 14, -8
 514 0178 FF92      		push r15
 515               	.LCFI17:
 516               		.cfi_def_cfa_offset 10
 517               		.cfi_offset 15, -9
 518 017a 0F93      		push r16
 519               	.LCFI18:
 520               		.cfi_def_cfa_offset 11
 521               		.cfi_offset 16, -10
 522 017c 1F93      		push r17
 523               	.LCFI19:
 524               		.cfi_def_cfa_offset 12
 525               		.cfi_offset 17, -11
 526 017e CF93      		push r28
 527               	.LCFI20:
 528               		.cfi_def_cfa_offset 13
 529               		.cfi_offset 28, -12
 530 0180 DF93      		push r29
 531               	.LCFI21:
 532               		.cfi_def_cfa_offset 14
 533               		.cfi_offset 29, -13
 534 0182 CDB7      		in r28,__SP_L__
 535 0184 DEB7      		in r29,__SP_H__
 536               	.LCFI22:
 537               		.cfi_def_cfa_register 28
 538               	/* prologue: function */
 539               	/* frame size = 0 */
 540               	/* stack size = 12 */
 541               	.L__stack_usage = 12
 542 0186 182F      		mov r17,r24
 543 0188 062F      		mov r16,r22
 544 018a 4901      		movw r8,r18
  69:RTC.c         **** }
 545               		.loc 1 69 0
 546 018c ADB6      		in r10,__SP_L__
 547 018e BEB6      		in r11,__SP_H__
  52:RTC.c         **** 	uint8_t i2c_buffer[len+1];
 548               		.loc 1 52 0
 549 0190 C62E      		mov r12,r22
 550 0192 D12C      		mov r13,__zero_reg__
 551               	.LVL51:
 552 0194 C601      		movw r24,r12
 553               	.LVL52:
 554 0196 0196      		adiw r24,1
 555 0198 2DB7      		in r18,__SP_L__
 556 019a 3EB7      		in r19,__SP_H__
 557               	.LVL53:
 558 019c 281B      		sub r18,r24
 559 019e 390B      		sbc r19,r25
 560 01a0 0FB6      		in __tmp_reg__,__SREG__
 561 01a2 F894      		cli
 562 01a4 3EBF      		out __SP_H__,r19
 563 01a6 0FBE      		out __SREG__,__tmp_reg__
 564 01a8 2DBF      		out __SP_L__,r18
 565 01aa 8DB7      		in r24,__SP_L__
 566 01ac 9EB7      		in r25,__SP_H__
 567 01ae 0196      		adiw r24,1
 568 01b0 7C01      		movw r14,r24
 569               	.LVL54:
  54:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CWRITE;
 570               		.loc 1 54 0
 571 01b2 812F      		mov r24,r17
 572 01b4 880F      		lsl r24
 573 01b6 EDB7      		in r30,__SP_L__
 574 01b8 FEB7      		in r31,__SP_H__
 575 01ba 8183      		std Z+1,r24
  55:RTC.c         **** 	i2c_buffer[1] = adrs;
 576               		.loc 1 55 0
 577 01bc F701      		movw r30,r14
 578 01be 4183      		std Z+1,r20
  56:RTC.c         **** 	i2c_in_transmit(i2c_buffer, i2c_buffer_len);
 579               		.loc 1 56 0
 580 01c0 62E0      		ldi r22,lo8(2)
 581               	.LVL55:
 582 01c2 C701      		movw r24,r14
 583 01c4 00D0      		rcall i2c_in_transmit
 584               	.LVL56:
  59:RTC.c         **** 	i2c_buffer[0] = (addr << 1) | I2CREAD;
 585               		.loc 1 59 0
 586 01c6 110F      		lsl r17
 587               	.LVL57:
 588 01c8 1160      		ori r17,lo8(1)
 589 01ca F701      		movw r30,r14
 590 01cc 1083      		st Z,r17
  60:RTC.c         **** 	if(i2c_in_transmit(i2c_buffer, i2c_buffer_len)){
 591               		.loc 1 60 0
 592 01ce 61E0      		ldi r22,lo8(1)
 593 01d0 600F      		add r22,r16
 594               	.LVL58:
 595 01d2 C701      		movw r24,r14
 596 01d4 00D0      		rcall i2c_in_transmit
 597               	.LVL59:
 598 01d6 8823      		tst r24
 599 01d8 01F0      		breq .L45
 600 01da 21E0      		ldi r18,lo8(1)
 601               	.L46:
 602               	.LVL60:
 603               	.LBB34:
  62:RTC.c         **** 		for(i=1;i<len+1;i++){ // fetch in buffer
 604               		.loc 1 62 0 discriminator 1
 605 01dc 822F      		mov r24,r18
 606 01de 90E0      		ldi r25,0
 607 01e0 C816      		cp r12,r24
 608 01e2 D906      		cpc r13,r25
 609 01e4 04F0      		brlt .L51
  63:RTC.c         **** 			buf[i-1]=i2c_buffer[i];
 610               		.loc 1 63 0 discriminator 3
 611 01e6 F401      		movw r30,r8
 612 01e8 E80F      		add r30,r24
 613 01ea F91F      		adc r31,r25
 614 01ec 3197      		sbiw r30,1
 615 01ee D701      		movw r26,r14
 616 01f0 A80F      		add r26,r24
 617 01f2 B91F      		adc r27,r25
 618 01f4 8C91      		ld r24,X
 619 01f6 8083      		st Z,r24
  62:RTC.c         **** 		for(i=1;i<len+1;i++){ // fetch in buffer
 620               		.loc 1 62 0 discriminator 3
 621 01f8 2F5F      		subi r18,lo8(-(1))
 622               	.LVL61:
 623 01fa 00C0      		rjmp .L46
 624               	.L51:
  65:RTC.c         **** 		return 1; // provide success check
 625               		.loc 1 65 0
 626 01fc 81E0      		ldi r24,lo8(1)
 627               	.LVL62:
 628               	.L45:
 629               	.LBE34:
  69:RTC.c         **** }
 630               		.loc 1 69 0
 631 01fe 0FB6      		in __tmp_reg__,__SREG__
 632 0200 F894      		cli
 633 0202 BEBE      		out __SP_H__,r11
 634 0204 0FBE      		out __SREG__,__tmp_reg__
 635 0206 ADBE      		out __SP_L__,r10
 636               	/* epilogue start */
 637 0208 DF91      		pop r29
 638 020a CF91      		pop r28
 639 020c 1F91      		pop r17
 640 020e 0F91      		pop r16
 641 0210 FF90      		pop r15
 642 0212 EF90      		pop r14
 643               	.LVL63:
 644 0214 DF90      		pop r13
 645 0216 CF90      		pop r12
 646               	.LVL64:
 647 0218 BF90      		pop r11
 648 021a AF90      		pop r10
 649 021c 9F90      		pop r9
 650 021e 8F90      		pop r8
 651               	.LVL65:
 652 0220 0895      		ret
 653               		.cfi_endproc
 654               	.LFE11:
 656               	.global	RTC_readTime
 658               	RTC_readTime:
 659               	.LFB9:
  30:RTC.c         **** uint8_t RTC_readTime(struct Ttime *t){
 660               		.loc 1 30 0
 661               		.cfi_startproc
 662               	.LVL66:
 663 0222 0F93      		push r16
 664               	.LCFI23:
 665               		.cfi_def_cfa_offset 3
 666               		.cfi_offset 16, -2
 667 0224 1F93      		push r17
 668               	.LCFI24:
 669               		.cfi_def_cfa_offset 4
 670               		.cfi_offset 17, -3
 671 0226 CF93      		push r28
 672               	.LCFI25:
 673               		.cfi_def_cfa_offset 5
 674               		.cfi_offset 28, -4
 675 0228 DF93      		push r29
 676               	.LCFI26:
 677               		.cfi_def_cfa_offset 6
 678               		.cfi_offset 29, -5
 679 022a CDB7      		in r28,__SP_L__
 680 022c DEB7      		in r29,__SP_H__
 681               	.LCFI27:
 682               		.cfi_def_cfa_register 28
 683 022e 2797      		sbiw r28,7
 684               	.LCFI28:
 685               		.cfi_def_cfa_offset 13
 686 0230 0FB6      		in __tmp_reg__,__SREG__
 687 0232 F894      		cli
 688 0234 DEBF      		out __SP_H__,r29
 689 0236 0FBE      		out __SREG__,__tmp_reg__
 690 0238 CDBF      		out __SP_L__,r28
 691               	/* prologue: function */
 692               	/* frame size = 7 */
 693               	/* stack size = 11 */
 694               	.L__stack_usage = 11
 695 023a 8C01      		movw r16,r24
  31:RTC.c         **** 	uint8_t data[7] = {0};
 696               		.loc 1 31 0
 697 023c 9E01      		movw r18,r28
 698 023e 2F5F      		subi r18,-1
 699 0240 3F4F      		sbci r19,-1
 700 0242 87E0      		ldi r24,lo8(7)
 701               	.LVL67:
 702 0244 F901      		movw r30,r18
 703               		0:
 704 0246 1192      		st Z+,__zero_reg__
 705 0248 8A95      		dec r24
 706 024a 01F4      		brne 0b
  32:RTC.c         **** 	if(i2c_read(RTC_addr,7,0x00,data)){
 707               		.loc 1 32 0
 708 024c 40E0      		ldi r20,0
 709 024e 67E0      		ldi r22,lo8(7)
 710 0250 88E6      		ldi r24,lo8(104)
 711 0252 00D0      		rcall i2c_read
 712               	.LVL68:
 713 0254 8823      		tst r24
 714 0256 01F0      		breq .L53
  33:RTC.c         **** 		t->hour = bcdToDec(data[2]);
 715               		.loc 1 33 0
 716 0258 8B81      		ldd r24,Y+3
 717 025a 00D0      		rcall bcdToDec
 718               	.LVL69:
 719 025c F801      		movw r30,r16
 720 025e 8083      		st Z,r24
  34:RTC.c         **** 		t->min = bcdToDec(data[1]);
 721               		.loc 1 34 0
 722 0260 8A81      		ldd r24,Y+2
 723 0262 00D0      		rcall bcdToDec
 724               	.LVL70:
 725 0264 F801      		movw r30,r16
 726 0266 8183      		std Z+1,r24
  35:RTC.c         **** 		t->monthDay = bcdToDec(data[4]);
 727               		.loc 1 35 0
 728 0268 8D81      		ldd r24,Y+5
 729 026a 00D0      		rcall bcdToDec
 730               	.LVL71:
 731 026c F801      		movw r30,r16
 732 026e 8283      		std Z+2,r24
  36:RTC.c         **** 		t->month = bcdToDec(data[5]);
 733               		.loc 1 36 0
 734 0270 8E81      		ldd r24,Y+6
 735 0272 00D0      		rcall bcdToDec
 736               	.LVL72:
 737 0274 F801      		movw r30,r16
 738 0276 8383      		std Z+3,r24
  37:RTC.c         **** 		return 1;
 739               		.loc 1 37 0
 740 0278 81E0      		ldi r24,lo8(1)
 741               	.L53:
 742               	/* epilogue start */
  41:RTC.c         **** }
 743               		.loc 1 41 0
 744 027a 2796      		adiw r28,7
 745 027c 0FB6      		in __tmp_reg__,__SREG__
 746 027e F894      		cli
 747 0280 DEBF      		out __SP_H__,r29
 748 0282 0FBE      		out __SREG__,__tmp_reg__
 749 0284 CDBF      		out __SP_L__,r28
 750 0286 DF91      		pop r29
 751 0288 CF91      		pop r28
 752 028a 1F91      		pop r17
 753 028c 0F91      		pop r16
 754               	.LVL73:
 755 028e 0895      		ret
 756               		.cfi_endproc
 757               	.LFE9:
 759               		.comm	USI_I2C_Master_State,1,1
 760               		.comm	currentTime,5,1
 761               	.Letext0:
 762               		.file 3 "/usr/lib/avr/include/stdint.h"
 763               		.file 4 "RTC.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 RTC.c
     /tmp/ccJGSLWn.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccJGSLWn.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccJGSLWn.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccJGSLWn.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccJGSLWn.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccJGSLWn.s:12     .text:0000000000000000 setCurrentTime
                            *COM*:0000000000000005 currentTime
     /tmp/ccJGSLWn.s:38     .text:000000000000000e minquad
     /tmp/ccJGSLWn.s:105    .text:000000000000003e bcdToDec
     /tmp/ccJGSLWn.s:131    .text:000000000000004e i2c_in_transfer
     /tmp/ccJGSLWn.s:198    .text:0000000000000078 i2c_in_transmit
                            *COM*:0000000000000001 USI_I2C_Master_State
     /tmp/ccJGSLWn.s:427    .text:0000000000000142 i2c_write
     /tmp/ccJGSLWn.s:481    .text:000000000000016a i2c_read
     /tmp/ccJGSLWn.s:658    .text:0000000000000222 RTC_readTime

UNDEFINED SYMBOLS
__mulqi3
__do_clear_bss
