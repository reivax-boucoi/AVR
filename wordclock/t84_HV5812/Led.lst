   1               		.file	"Led.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	ledInit
  12               	ledInit:
  13               	.LFB6:
  14               		.file 1 "Led.c"
   1:Led.c         **** #include "Led.h" 
   2:Led.c         **** 
   3:Led.c         **** static const uint8_t ledMap[11]={7,8,10,14,0,4,17,2,12,6,16};
   4:Led.c         **** 
   5:Led.c         **** 
   6:Led.c         **** void ledInit(Led* leds){
  15               		.loc 1 6 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
   7:Led.c         ****     DDRA |= CLK|DATA|STROBE|LED;
  22               		.loc 1 7 0
  23 0000 2AB3      		in r18,0x1a
  24 0002 2F60      		ori r18,lo8(15)
  25 0004 2ABB      		out 0x1a,r18
   8:Led.c         ****     PORTA &= ~(CLK|DATA|STROBE|LED);
  26               		.loc 1 8 0
  27 0006 2BB3      		in r18,0x1b
  28 0008 207F      		andi r18,lo8(-16)
  29 000a 2BBB      		out 0x1b,r18
  30               	.LVL1:
  31 000c FC01      		movw r30,r24
  32               	.LBB35:
   9:Led.c         ****     
  10:Led.c         ****     for(uint8_t i=0;i<NBLEDS;i++){
  33               		.loc 1 10 0
  34 000e 90E0      		ldi r25,0
  35               	.LVL2:
  36               	.L4:
  11:Led.c         ****         leds[i].row=i%2;//leds[0]=0, leds[1]=1
  37               		.loc 1 11 0
  38 0010 892F      		mov r24,r25
  39 0012 8170      		andi r24,lo8(1)
  40 0014 8183      		std Z+1,r24
  12:Led.c         ****         if(i<10){
  41               		.loc 1 12 0
  42 0016 9A30      		cpi r25,lo8(10)
  43 0018 00F4      		brsh .L2
  13:Led.c         ****             leds[i].col=i;//0-9
  44               		.loc 1 13 0
  45 001a 9083      		st Z,r25
  46 001c 00C0      		rjmp .L3
  47               	.L2:
  14:Led.c         ****         }else{
  15:Led.c         ****             leds[i].col=i-9;//1-9
  48               		.loc 1 15 0
  49 001e 87EF      		ldi r24,lo8(-9)
  50 0020 890F      		add r24,r25
  51 0022 8083      		st Z,r24
  52               	.L3:
  16:Led.c         ****         }
  17:Led.c         ****         leds[i].c=BLACK;
  53               		.loc 1 17 0 discriminator 2
  54 0024 1282      		std Z+2,__zero_reg__
  10:Led.c         ****         leds[i].row=i%2;//leds[0]=0, leds[1]=1
  55               		.loc 1 10 0 discriminator 2
  56 0026 9F5F      		subi r25,lo8(-(1))
  57               	.LVL3:
  58 0028 3396      		adiw r30,3
  59 002a 9331      		cpi r25,lo8(19)
  60 002c 01F4      		brne .L4
  61               	/* epilogue start */
  62               	.LBE35:
  18:Led.c         ****     }
  19:Led.c         **** }
  63               		.loc 1 19 0
  64 002e 0895      		ret
  65               		.cfi_endproc
  66               	.LFE6:
  68               	.global	getDataByColor
  70               	getDataByColor:
  71               	.LFB7:
  20:Led.c         **** 
  21:Led.c         **** uint32_t getDataByColor(uint8_t c, uint8_t mode, Led* leds){
  72               		.loc 1 21 0
  73               		.cfi_startproc
  74               	.LVL4:
  75 0030 0F93      		push r16
  76               	.LCFI0:
  77               		.cfi_def_cfa_offset 3
  78               		.cfi_offset 16, -2
  79 0032 1F93      		push r17
  80               	.LCFI1:
  81               		.cfi_def_cfa_offset 4
  82               		.cfi_offset 17, -3
  83 0034 CF93      		push r28
  84               	.LCFI2:
  85               		.cfi_def_cfa_offset 5
  86               		.cfi_offset 28, -4
  87 0036 DF93      		push r29
  88               	.LCFI3:
  89               		.cfi_def_cfa_offset 6
  90               		.cfi_offset 29, -5
  91               	/* prologue: function */
  92               	/* frame size = 0 */
  93               	/* stack size = 4 */
  94               	.L__stack_usage = 4
  95 0038 C82F      		mov r28,r24
  96 003a D62F      		mov r29,r22
  97 003c FA01      		movw r30,r20
  98               	.LVL5:
  99 003e 475C      		subi r20,-57
 100 0040 5F4F      		sbci r21,-1
 101               	.LVL6:
  22:Led.c         ****     uint32_t data=0x00000000;
 102               		.loc 1 22 0
 103 0042 60E0      		ldi r22,0
 104 0044 70E0      		ldi r23,0
 105 0046 CB01      		movw r24,r22
 106               	.LVL7:
 107               	.LBB36:
  23:Led.c         ****     for(uint8_t i=0;i<NBLEDS;i++){
  24:Led.c         ****         if(leds[i].row==mode){
  25:Led.c         ****             if((leds[i].c & c) ){
  26:Led.c         ****                 data|=(1<<leds[i].col);
 108               		.loc 1 26 0
 109 0048 A1E0      		ldi r26,lo8(1)
 110 004a B0E0      		ldi r27,0
 111               	.LVL8:
 112               	.L9:
  24:Led.c         ****             if((leds[i].c & c) ){
 113               		.loc 1 24 0
 114 004c 2181      		ldd r18,Z+1
 115 004e 2D13      		cpse r18,r29
 116 0050 00C0      		rjmp .L8
  25:Led.c         ****                 data|=(1<<leds[i].col);
 117               		.loc 1 25 0
 118 0052 2281      		ldd r18,Z+2
 119 0054 2C23      		and r18,r28
 120 0056 01F0      		breq .L8
 121               		.loc 1 26 0
 122 0058 8D01      		movw r16,r26
 123 005a 0080      		ld r0,Z
 124 005c 00C0      		rjmp 2f
 125               		1:
 126 005e 000F      		lsl r16
 127 0060 111F      		rol r17
 128               		2:
 129 0062 0A94      		dec r0
 130 0064 02F4      		brpl 1b
 131 0066 012E      		mov __tmp_reg__,r17
 132 0068 000C      		lsl r0
 133 006a 220B      		sbc r18,r18
 134 006c 330B      		sbc r19,r19
 135 006e 602B      		or r22,r16
 136 0070 712B      		or r23,r17
 137 0072 822B      		or r24,r18
 138 0074 932B      		or r25,r19
 139               	.LVL9:
 140               	.L8:
 141 0076 3396      		adiw r30,3
  23:Led.c         ****     for(uint8_t i=0;i<NBLEDS;i++){
 142               		.loc 1 23 0 discriminator 2
 143 0078 E417      		cp r30,r20
 144 007a F507      		cpc r31,r21
 145 007c 01F4      		brne .L9
 146               	/* epilogue start */
 147               	.LBE36:
  27:Led.c         ****             }
  28:Led.c         ****         }
  29:Led.c         ****     }
  30:Led.c         ****     return data;
  31:Led.c         **** }
 148               		.loc 1 31 0
 149 007e DF91      		pop r29
 150               	.LVL10:
 151 0080 CF91      		pop r28
 152 0082 1F91      		pop r17
 153 0084 0F91      		pop r16
 154 0086 0895      		ret
 155               		.cfi_endproc
 156               	.LFE7:
 158               	.global	ledOn
 160               	ledOn:
 161               	.LFB8:
  32:Led.c         **** 
  33:Led.c         **** void ledOn(Led* l,uint8_t c){
 162               		.loc 1 33 0
 163               		.cfi_startproc
 164               	.LVL11:
 165               	/* prologue: function */
 166               	/* frame size = 0 */
 167               	/* stack size = 0 */
 168               	.L__stack_usage = 0
  34:Led.c         ****     l->c=c;
 169               		.loc 1 34 0
 170 0088 FC01      		movw r30,r24
 171 008a 6283      		std Z+2,r22
 172 008c 0895      		ret
 173               		.cfi_endproc
 174               	.LFE8:
 176               	.global	ledOff
 178               	ledOff:
 179               	.LFB9:
  35:Led.c         **** }
  36:Led.c         **** void ledOff(Led* l){
 180               		.loc 1 36 0
 181               		.cfi_startproc
 182               	.LVL12:
 183               	/* prologue: function */
 184               	/* frame size = 0 */
 185               	/* stack size = 0 */
 186               	.L__stack_usage = 0
  37:Led.c         ****     l->c=BLACK;
 187               		.loc 1 37 0
 188 008e FC01      		movw r30,r24
 189 0090 1282      		std Z+2,__zero_reg__
 190 0092 0895      		ret
 191               		.cfi_endproc
 192               	.LFE9:
 194               	.global	clearLeds
 196               	clearLeds:
 197               	.LFB10:
  38:Led.c         **** }
  39:Led.c         **** void clearLeds(Led* l){
 198               		.loc 1 39 0
 199               		.cfi_startproc
 200               	.LVL13:
 201               	/* prologue: function */
 202               	/* frame size = 0 */
 203               	/* stack size = 0 */
 204               	.L__stack_usage = 0
 205 0094 9C01      		movw r18,r24
 206 0096 275C      		subi r18,-57
 207 0098 3F4F      		sbci r19,-1
 208               	.LVL14:
 209               	.L17:
 210               	.LBB37:
 211               	.LBB38:
 212               	.LBB39:
  37:Led.c         ****     l->c=BLACK;
 213               		.loc 1 37 0 discriminator 3
 214 009a FC01      		movw r30,r24
 215 009c 1282      		std Z+2,__zero_reg__
 216               	.LVL15:
 217 009e 0396      		adiw r24,3
 218               	.LBE39:
 219               	.LBE38:
  40:Led.c         ****     for(uint8_t i=0;i<NBLEDS;i++){
 220               		.loc 1 40 0 discriminator 3
 221 00a0 8217      		cp r24,r18
 222 00a2 9307      		cpc r25,r19
 223 00a4 01F4      		brne .L17
 224               	/* epilogue start */
 225               	.LBE37:
  41:Led.c         ****         ledOff(&l[i]);
  42:Led.c         ****     }
  43:Led.c         **** }
 226               		.loc 1 43 0
 227 00a6 0895      		ret
 228               		.cfi_endproc
 229               	.LFE10:
 231               	.global	setLeds
 233               	setLeds:
 234               	.LFB11:
  44:Led.c         **** 
  45:Led.c         **** void setLeds(Ttime t,Led* l){
 235               		.loc 1 45 0
 236               		.cfi_startproc
 237               	.LVL16:
 238 00a8 FF92      		push r15
 239               	.LCFI4:
 240               		.cfi_def_cfa_offset 3
 241               		.cfi_offset 15, -2
 242 00aa 0F93      		push r16
 243               	.LCFI5:
 244               		.cfi_def_cfa_offset 4
 245               		.cfi_offset 16, -3
 246 00ac 1F93      		push r17
 247               	.LCFI6:
 248               		.cfi_def_cfa_offset 5
 249               		.cfi_offset 17, -4
 250 00ae CF93      		push r28
 251               	.LCFI7:
 252               		.cfi_def_cfa_offset 6
 253               		.cfi_offset 28, -5
 254 00b0 DF93      		push r29
 255               	.LCFI8:
 256               		.cfi_def_cfa_offset 7
 257               		.cfi_offset 29, -6
 258 00b2 00D0      		rcall .
 259 00b4 00D0      		rcall .
 260 00b6 1F92      		push __zero_reg__
 261               	.LCFI9:
 262               		.cfi_def_cfa_offset 12
 263 00b8 CDB7      		in r28,__SP_L__
 264 00ba DEB7      		in r29,__SP_H__
 265               	.LCFI10:
 266               		.cfi_def_cfa_register 28
 267               	/* prologue: function */
 268               	/* frame size = 5 */
 269               	/* stack size = 10 */
 270               	.L__stack_usage = 10
 271 00bc 8901      		movw r16,r18
 272               	.LVL17:
  46:Led.c         ****     uint8_t temp=0;
  47:Led.c         ****     clearLeds(l);
 273               		.loc 1 47 0
 274 00be C901      		movw r24,r18
 275 00c0 00D0      		rcall clearLeds
 276               	.LVL18:
  48:Led.c         ****     ledOn(&l[ILEST],getColor());
 277               		.loc 1 48 0
 278 00c2 00D0      		rcall getColor
 279               	.LVL19:
 280               	.LBB40:
 281               	.LBB41:
  34:Led.c         **** }
 282               		.loc 1 34 0
 283 00c4 F801      		movw r30,r16
 284 00c6 80AF      		std Z+56,r24
 285               	.LVL20:
 286               	.LBE41:
 287               	.LBE40:
  49:Led.c         ****     
  50:Led.c         ****     temp=currentTime.hour;
 288               		.loc 1 50 0
 289 00c8 F090 0000 		lds r15,currentTime
 290               	.LVL21:
  51:Led.c         ****     if(currentTime.min>35){
 291               		.loc 1 51 0
 292 00cc 8091 0000 		lds r24,currentTime+1
 293 00d0 8432      		cpi r24,lo8(36)
 294 00d2 00F0      		brlo .L20
  52:Led.c         ****         temp++;
 295               		.loc 1 52 0
 296 00d4 F394      		inc r15
 297               	.LVL22:
 298               	.L20:
  53:Led.c         ****     }
  54:Led.c         ****     if(temp==0){
 299               		.loc 1 54 0
 300 00d6 F110      		cpse r15,__zero_reg__
 301 00d8 00C0      		rjmp .L21
  55:Led.c         ****         ledOn(&l[MINUIT],getColor());
 302               		.loc 1 55 0
 303 00da 00D0      		rcall getColor
 304               	.LVL23:
 305               	.LBB42:
 306               	.LBB43:
  34:Led.c         **** }
 307               		.loc 1 34 0
 308 00dc F801      		movw r30,r16
 309 00de 8387      		std Z+11,r24
 310 00e0 00C0      		rjmp .L22
 311               	.LVL24:
 312               	.L21:
 313               	.LBE43:
 314               	.LBE42:
  56:Led.c         ****     }else if(temp==12){
 315               		.loc 1 56 0
 316 00e2 FCE0      		ldi r31,lo8(12)
 317 00e4 FF12      		cpse r15,r31
 318 00e6 00C0      		rjmp .L23
  57:Led.c         ****             ledOn(&l[MIDI],getColor());
 319               		.loc 1 57 0
 320 00e8 00D0      		rcall getColor
 321               	.LVL25:
 322               	.LBB44:
 323               	.LBB45:
  34:Led.c         **** }
 324               		.loc 1 34 0
 325 00ea F801      		movw r30,r16
 326 00ec 81A7      		std Z+41,r24
 327 00ee 00C0      		rjmp .L22
 328               	.LVL26:
 329               	.L23:
 330               	.LBE45:
 331               	.LBE44:
  58:Led.c         ****     }else{
  59:Led.c         ****         temp=temp%12;
  60:Led.c         ****         ledOn(&l[ledMap[(temp-1)]],getColor());
 332               		.loc 1 60 0
 333 00f0 00D0      		rcall getColor
 334               	.LVL27:
 335 00f2 282F      		mov r18,r24
 336               	.LVL28:
 337 00f4 8F2D      		mov r24,r15
 338 00f6 6CE0      		ldi r22,lo8(12)
 339 00f8 00D0      		rcall __udivmodqi4
 340               	.LVL29:
 341 00fa E92F      		mov r30,r25
 342 00fc F0E0      		ldi r31,0
 343 00fe E050      		subi r30,lo8(-(ledMap-1))
 344 0100 F040      		sbci r31,hi8(-(ledMap-1))
 345               	.LBB46:
 346               	.LBB47:
  34:Led.c         **** }
 347               		.loc 1 34 0
 348 0102 8081      		ld r24,Z
 349 0104 90E0      		ldi r25,0
 350               	.LVL30:
 351 0106 63E0      		ldi r22,lo8(3)
 352 0108 70E0      		ldi r23,0
 353 010a 00D0      		rcall __mulhi3
 354 010c 800F      		add r24,r16
 355 010e 911F      		adc r25,r17
 356 0110 FC01      		movw r30,r24
 357 0112 2283      		std Z+2,r18
 358               	.LVL31:
 359               	.LBE47:
 360               	.LBE46:
  61:Led.c         ****         ledOn(&l[HEURE],getColor());
 361               		.loc 1 61 0
 362 0114 00D0      		rcall getColor
 363               	.LVL32:
 364               	.LBB48:
 365               	.LBB49:
  34:Led.c         **** }
 366               		.loc 1 34 0
 367 0116 F801      		movw r30,r16
 368 0118 87A7      		std Z+47,r24
 369               	.LVL33:
 370               	.L22:
 371               	.LBE49:
 372               	.LBE48:
  62:Led.c         ****     }
  63:Led.c         ****     
  64:Led.c         ****     temp = minquad(currentTime.min); 
 373               		.loc 1 64 0
 374 011a 8091 0000 		lds r24,currentTime+1
 375 011e 00D0      		rcall minquad
 376               	.LVL34:
 377 0120 F82E      		mov r15,r24
 378               	.LVL35:
  65:Led.c         ****     if(temp > 30){
 379               		.loc 1 65 0
 380 0122 FEE1      		ldi r31,lo8(30)
 381 0124 F817      		cp r31,r24
 382 0126 00F4      		brsh .L24
  66:Led.c         ****         ledOn(&l[MOINS],getColor());
 383               		.loc 1 66 0
 384 0128 00D0      		rcall getColor
 385               	.LVL36:
 386               	.LBB50:
 387               	.LBB51:
  34:Led.c         **** }
 388               		.loc 1 34 0
 389 012a F801      		movw r30,r16
 390 012c 858F      		std Z+29,r24
 391               	.LVL37:
 392               	.LBE51:
 393               	.LBE50:
  67:Led.c         ****         temp=60-temp;
 394               		.loc 1 67 0
 395 012e 8CE3      		ldi r24,lo8(60)
 396 0130 8F19      		sub r24,r15
 397 0132 F82E      		mov r15,r24
 398               	.LVL38:
 399               	.L24:
  68:Led.c         ****     }
  69:Led.c         ****     switch(temp){
 400               		.loc 1 69 0
 401 0134 F4E1      		ldi r31,lo8(20)
 402 0136 FF16      		cp r15,r31
 403 0138 01F0      		breq .L26
 404 013a 8EE1      		ldi r24,lo8(30)
 405 013c F816      		cp r15,r24
 406 013e 01F0      		breq .L27
 407 0140 EAE0      		ldi r30,lo8(10)
 408 0142 FE12      		cpse r15,r30
 409 0144 00C0      		rjmp .L19
  70:Led.c         ****         case 10 :
  71:Led.c         ****             ledOn(&l[DIX],getColor());
 410               		.loc 1 71 0
 411 0146 00D0      		rcall getColor
 412               	.LVL39:
 413               	.LBB52:
 414               	.LBB53:
  34:Led.c         **** }
 415               		.loc 1 34 0
 416 0148 F801      		movw r30,r16
 417 014a 818B      		std Z+17,r24
 418 014c 00C0      		rjmp .L19
 419               	.LVL40:
 420               	.L26:
 421               	.LBE53:
 422               	.LBE52:
  72:Led.c         ****             break;
  73:Led.c         ****         case 20 :
  74:Led.c         ****             ledOn(&l[VINGT],getColor());
 423               		.loc 1 74 0
 424 014e 00D0      		rcall getColor
 425               	.LVL41:
 426               	.LBB54:
 427               	.LBB55:
  34:Led.c         **** }
 428               		.loc 1 34 0
 429 0150 F801      		movw r30,r16
 430 0152 83A3      		std Z+35,r24
 431 0154 00C0      		rjmp .L19
 432               	.LVL42:
 433               	.L27:
 434               	.LBE55:
 435               	.LBE54:
  75:Led.c         ****             break;
  76:Led.c         ****         case 30 :
  77:Led.c         ****             ledOn(&l[ETDEMIE],getColor());
 436               		.loc 1 77 0
 437 0156 00D0      		rcall getColor
 438               	.LVL43:
 439               	.LBB56:
 440               	.LBB57:
  34:Led.c         **** }
 441               		.loc 1 34 0
 442 0158 F801      		movw r30,r16
 443 015a 8583      		std Z+5,r24
 444               	.LVL44:
 445               	.L19:
 446               	/* epilogue start */
 447               	.LBE57:
 448               	.LBE56:
  78:Led.c         ****             break;
  79:Led.c         ****     }
  80:Led.c         **** }
 449               		.loc 1 80 0
 450 015c 0F90      		pop __tmp_reg__
 451 015e 0F90      		pop __tmp_reg__
 452 0160 0F90      		pop __tmp_reg__
 453 0162 0F90      		pop __tmp_reg__
 454 0164 0F90      		pop __tmp_reg__
 455 0166 DF91      		pop r29
 456 0168 CF91      		pop r28
 457 016a 1F91      		pop r17
 458 016c 0F91      		pop r16
 459               	.LVL45:
 460 016e FF90      		pop r15
 461               	.LVL46:
 462 0170 0895      		ret
 463               		.cfi_endproc
 464               	.LFE11:
 466               	.global	setLedsNb
 468               	setLedsNb:
 469               	.LFB12:
  81:Led.c         **** 
  82:Led.c         **** void setLedsNb(int8_t nb, Led* l){
 470               		.loc 1 82 0
 471               		.cfi_startproc
 472               	.LVL47:
 473 0172 0F93      		push r16
 474               	.LCFI11:
 475               		.cfi_def_cfa_offset 3
 476               		.cfi_offset 16, -2
 477 0174 1F93      		push r17
 478               	.LCFI12:
 479               		.cfi_def_cfa_offset 4
 480               		.cfi_offset 17, -3
 481 0176 CF93      		push r28
 482               	.LCFI13:
 483               		.cfi_def_cfa_offset 5
 484               		.cfi_offset 28, -4
 485               	/* prologue: function */
 486               	/* frame size = 0 */
 487               	/* stack size = 3 */
 488               	.L__stack_usage = 3
 489 0178 C82F      		mov r28,r24
 490 017a 8B01      		movw r16,r22
  83:Led.c         ****     clearLeds(l);
 491               		.loc 1 83 0
 492 017c CB01      		movw r24,r22
 493               	.LVL48:
 494 017e 00D0      		rcall clearLeds
 495               	.LVL49:
  84:Led.c         ****     if(nb < 0){
 496               		.loc 1 84 0
 497 0180 C7FF      		sbrs r28,7
 498 0182 00C0      		rjmp .L30
  85:Led.c         ****         ledOn(&l[MOINS],getColor());
 499               		.loc 1 85 0
 500 0184 00D0      		rcall getColor
 501               	.LVL50:
 502               	.LBB58:
 503               	.LBB59:
  34:Led.c         **** }
 504               		.loc 1 34 0
 505 0186 F801      		movw r30,r16
 506 0188 858F      		std Z+29,r24
 507               	.LVL51:
 508               	.LBE59:
 509               	.LBE58:
  86:Led.c         ****         nb=-nb;
 510               		.loc 1 86 0
 511 018a C195      		neg r28
 512               	.LVL52:
 513               	.L30:
  87:Led.c         ****     }
  88:Led.c         ****     if(nb>29){
 514               		.loc 1 88 0
 515 018c CE31      		cpi r28,lo8(30)
 516 018e 04F0      		brlt .L31
  89:Led.c         ****         ledOn(&l[VINGT],getColor());
 517               		.loc 1 89 0
 518 0190 00D0      		rcall getColor
 519               	.LVL53:
 520               	.LBB60:
 521               	.LBB61:
  34:Led.c         **** }
 522               		.loc 1 34 0
 523 0192 F801      		movw r30,r16
 524 0194 83A3      		std Z+35,r24
 525               	.LVL54:
 526               	.LBE61:
 527               	.LBE60:
  90:Led.c         ****         ledOn(&l[DIX],getColor());
 528               		.loc 1 90 0
 529 0196 00D0      		rcall getColor
 530               	.LVL55:
 531               	.LBB62:
 532               	.LBB63:
  34:Led.c         **** }
 533               		.loc 1 34 0
 534 0198 F801      		movw r30,r16
 535 019a 818B      		std Z+17,r24
 536               	.LVL56:
 537               	.LBE63:
 538               	.LBE62:
  91:Led.c         ****         nb=nb-30;
 539               		.loc 1 91 0
 540 019c CE51      		subi r28,lo8(-(-30))
 541               	.LVL57:
 542 019e 00C0      		rjmp .L32
 543               	.L31:
  92:Led.c         ****     }else if(nb>19){
 544               		.loc 1 92 0
 545 01a0 C431      		cpi r28,lo8(20)
 546 01a2 04F0      		brlt .L33
  93:Led.c         ****         ledOn(&l[VINGT],getColor());
 547               		.loc 1 93 0
 548 01a4 00D0      		rcall getColor
 549               	.LVL58:
 550               	.LBB64:
 551               	.LBB65:
  34:Led.c         **** }
 552               		.loc 1 34 0
 553 01a6 F801      		movw r30,r16
 554 01a8 83A3      		std Z+35,r24
 555               	.LVL59:
 556               	.LBE65:
 557               	.LBE64:
  94:Led.c         ****         nb=nb-20;
 558               		.loc 1 94 0
 559 01aa C451      		subi r28,lo8(-(-20))
 560               	.LVL60:
 561 01ac 00C0      		rjmp .L32
 562               	.L33:
  95:Led.c         ****     }else if(nb>11){
 563               		.loc 1 95 0
 564 01ae CC30      		cpi r28,lo8(12)
 565 01b0 04F0      		brlt .L32
  96:Led.c         ****         ledOn(&l[DIX],getColor());
 566               		.loc 1 96 0
 567 01b2 00D0      		rcall getColor
 568               	.LVL61:
 569               	.LBB66:
 570               	.LBB67:
  34:Led.c         **** }
 571               		.loc 1 34 0
 572 01b4 F801      		movw r30,r16
 573 01b6 818B      		std Z+17,r24
 574               	.LVL62:
 575               	.LBE67:
 576               	.LBE66:
  97:Led.c         ****         nb=nb-10;
 577               		.loc 1 97 0
 578 01b8 CA50      		subi r28,lo8(-(-10))
 579               	.LVL63:
 580               	.L32:
  98:Led.c         ****     }
  99:Led.c         ****     ledOn(&l[ledMap[nb-1]],getColor());
 581               		.loc 1 99 0
 582 01ba 00D0      		rcall getColor
 583               	.LVL64:
 584 01bc 282F      		mov r18,r24
 585               	.LVL65:
 586 01be EC2F      		mov r30,r28
 587 01c0 CC0F      		lsl r28
 588 01c2 FF0B      		sbc r31,r31
 589 01c4 E050      		subi r30,lo8(-(ledMap-1))
 590 01c6 F040      		sbci r31,hi8(-(ledMap-1))
 591               	.LVL66:
 592               	.LBB68:
 593               	.LBB69:
  34:Led.c         **** }
 594               		.loc 1 34 0
 595 01c8 8081      		ld r24,Z
 596 01ca 90E0      		ldi r25,0
 597 01cc 63E0      		ldi r22,lo8(3)
 598 01ce 70E0      		ldi r23,0
 599 01d0 00D0      		rcall __mulhi3
 600 01d2 800F      		add r24,r16
 601 01d4 911F      		adc r25,r17
 602 01d6 FC01      		movw r30,r24
 603               	.LVL67:
 604 01d8 2283      		std Z+2,r18
 605               	.LVL68:
 606               	/* epilogue start */
 607               	.LBE69:
 608               	.LBE68:
 100:Led.c         **** }
 609               		.loc 1 100 0
 610 01da CF91      		pop r28
 611               	.LVL69:
 612 01dc 1F91      		pop r17
 613 01de 0F91      		pop r16
 614               	.LVL70:
 615 01e0 0895      		ret
 616               		.cfi_endproc
 617               	.LFE12:
 619               	.global	sendRawData
 621               	sendRawData:
 622               	.LFB13:
 101:Led.c         **** void sendRawData(uint32_t data){
 623               		.loc 1 101 0
 624               		.cfi_startproc
 625               	.LVL71:
 626 01e2 0F93      		push r16
 627               	.LCFI14:
 628               		.cfi_def_cfa_offset 3
 629               		.cfi_offset 16, -2
 630 01e4 1F93      		push r17
 631               	.LCFI15:
 632               		.cfi_def_cfa_offset 4
 633               		.cfi_offset 17, -3
 634               	/* prologue: function */
 635               	/* frame size = 0 */
 636               	/* stack size = 2 */
 637               	.L__stack_usage = 2
 102:Led.c         ****     PORTA &=~(STROBE|CLK);
 638               		.loc 1 102 0
 639 01e6 2BB3      		in r18,0x1b
 640 01e8 237F      		andi r18,lo8(-13)
 641 01ea 2BBB      		out 0x1b,r18
 642               	.LVL72:
 643 01ec 40E0      		ldi r20,0
 644 01ee 50E0      		ldi r21,0
 645               	.LVL73:
 646               	.L37:
 647               	.LBB70:
 103:Led.c         ****     for(uint8_t i=0;i<20;i++){
 104:Led.c         ****         if((data>>i) & 0x00000001){
 648               		.loc 1 104 0
 649 01f0 8B01      		movw r16,r22
 650 01f2 9C01      		movw r18,r24
 651 01f4 042E      		mov r0,r20
 652 01f6 00C0      		rjmp 2f
 653               		1:
 654 01f8 3695      		lsr r19
 655 01fa 2795      		ror r18
 656 01fc 1795      		ror r17
 657 01fe 0795      		ror r16
 658               		2:
 659 0200 0A94      		dec r0
 660 0202 02F4      		brpl 1b
 661 0204 00FF      		sbrs r16,0
 662 0206 00C0      		rjmp .L35
 105:Led.c         ****             PORTA|=DATA;
 663               		.loc 1 105 0
 664 0208 D99A      		sbi 0x1b,1
 665 020a 00C0      		rjmp .L36
 666               	.L35:
 106:Led.c         ****         }else{
 107:Led.c         ****             PORTA&=~DATA;
 667               		.loc 1 107 0
 668 020c D998      		cbi 0x1b,1
 669               	.L36:
 108:Led.c         ****         }
 109:Led.c         ****         PORTA|=CLK;
 670               		.loc 1 109 0 discriminator 2
 671 020e DB9A      		sbi 0x1b,3
 110:Led.c         ****         PORTA&=~CLK;
 672               		.loc 1 110 0 discriminator 2
 673 0210 DB98      		cbi 0x1b,3
 674               	.LVL74:
 675 0212 4F5F      		subi r20,-1
 676 0214 5F4F      		sbci r21,-1
 677               	.LVL75:
 103:Led.c         ****         if((data>>i) & 0x00000001){
 678               		.loc 1 103 0 discriminator 2
 679 0216 4431      		cpi r20,20
 680 0218 5105      		cpc r21,__zero_reg__
 681 021a 01F4      		brne .L37
 682               	.LBE70:
 111:Led.c         ****     }
 112:Led.c         ****     PORTA|=STROBE;
 683               		.loc 1 112 0
 684 021c DA9A      		sbi 0x1b,2
 113:Led.c         ****     PORTA&=~STROBE;
 685               		.loc 1 113 0
 686 021e DA98      		cbi 0x1b,2
 687               	/* epilogue start */
 114:Led.c         **** }
 688               		.loc 1 114 0
 689 0220 1F91      		pop r17
 690 0222 0F91      		pop r16
 691 0224 0895      		ret
 692               		.cfi_endproc
 693               	.LFE13:
 695               		.section	.rodata
 698               	ledMap:
 699 0000 07        		.byte	7
 700 0001 08        		.byte	8
 701 0002 0A        		.byte	10
 702 0003 0E        		.byte	14
 703 0004 00        		.byte	0
 704 0005 04        		.byte	4
 705 0006 11        		.byte	17
 706 0007 02        		.byte	2
 707 0008 0C        		.byte	12
 708 0009 06        		.byte	6
 709 000a 10        		.byte	16
 710               		.comm	M1rainbow,3,1
 711               		.comm	M1reset,3,1
 712               		.comm	M1eventMode,3,1
 713               		.comm	M2setminpm,3,1
 714               		.comm	M2setminam,3,1
 715               		.comm	M2sethourpm,3,1
 716               		.comm	M2sethouram,3,1
 717               		.comm	M1setTime,3,1
 718               		.comm	M3onhour,3,1
 719               		.comm	M2offhour,3,1
 720               		.comm	M1nightmode,3,1
 721               		.comm	M1cmode,3,1
 722               		.comm	M1mode,3,1
 723               		.comm	M0main,3,1
 724               		.comm	USI_I2C_Master_State,1,1
 725               		.comm	currentTime,5,1
 726               		.text
 727               	.Letext0:
 728               		.file 2 "/usr/lib/avr/include/stdint.h"
 729               		.file 3 "RTC.h"
 730               		.file 4 "Menu.h"
 731               		.file 5 "Led.h"
 732               		.file 6 "defines.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Led.c
     /tmp/ccUhXe8r.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccUhXe8r.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccUhXe8r.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccUhXe8r.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccUhXe8r.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccUhXe8r.s:12     .text:0000000000000000 ledInit
     /tmp/ccUhXe8r.s:70     .text:0000000000000030 getDataByColor
     /tmp/ccUhXe8r.s:160    .text:0000000000000088 ledOn
     /tmp/ccUhXe8r.s:178    .text:000000000000008e ledOff
     /tmp/ccUhXe8r.s:196    .text:0000000000000094 clearLeds
     /tmp/ccUhXe8r.s:233    .text:00000000000000a8 setLeds
                            *COM*:0000000000000005 currentTime
     /tmp/ccUhXe8r.s:698    .rodata:0000000000000000 ledMap
     /tmp/ccUhXe8r.s:468    .text:0000000000000172 setLedsNb
     /tmp/ccUhXe8r.s:621    .text:00000000000001e2 sendRawData
                            *COM*:0000000000000003 M1rainbow
                            *COM*:0000000000000003 M1reset
                            *COM*:0000000000000003 M1eventMode
                            *COM*:0000000000000003 M2setminpm
                            *COM*:0000000000000003 M2setminam
                            *COM*:0000000000000003 M2sethourpm
                            *COM*:0000000000000003 M2sethouram
                            *COM*:0000000000000003 M1setTime
                            *COM*:0000000000000003 M3onhour
                            *COM*:0000000000000003 M2offhour
                            *COM*:0000000000000003 M1nightmode
                            *COM*:0000000000000003 M1cmode
                            *COM*:0000000000000003 M1mode
                            *COM*:0000000000000003 M0main
                            *COM*:0000000000000001 USI_I2C_Master_State

UNDEFINED SYMBOLS
getColor
__udivmodqi4
__mulhi3
minquad
__do_copy_data
__do_clear_bss
