   1               		.file	"Led.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	ledInit
  12               	ledInit:
  13               	.LFB6:
  14               		.file 1 "Led.c"
   1:Led.c         **** #include "Led.h" 
   2:Led.c         **** 
   3:Led.c         **** static const uint8_t ledMap[11]={7,8,10,14,0,4,17,2,12,6,16};
   4:Led.c         **** 
   5:Led.c         **** 
   6:Led.c         **** void ledInit(Led* leds){
  15               		.loc 1 6 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
   7:Led.c         ****     DDRA |= CLK|DATA|STROBE|LED;
  22               		.loc 1 7 0
  23 0000 2AB3      		in r18,0x1a
  24 0002 2F60      		ori r18,lo8(15)
  25 0004 2ABB      		out 0x1a,r18
   8:Led.c         ****     PORTA &= ~(CLK|DATA|STROBE|LED);
  26               		.loc 1 8 0
  27 0006 2BB3      		in r18,0x1b
  28 0008 207F      		andi r18,lo8(-16)
  29 000a 2BBB      		out 0x1b,r18
  30               	.LVL1:
  31 000c FC01      		movw r30,r24
  32               	.LBB36:
   9:Led.c         ****     
  10:Led.c         ****     for(uint8_t i=0;i<NBLEDS;i++){
  33               		.loc 1 10 0
  34 000e 90E0      		ldi r25,0
  35               	.LVL2:
  36               	.L4:
  11:Led.c         ****         leds[i].row=i%2;//leds[0]=0, leds[1]=1
  37               		.loc 1 11 0
  38 0010 892F      		mov r24,r25
  39 0012 8170      		andi r24,lo8(1)
  40 0014 8183      		std Z+1,r24
  12:Led.c         ****         if(i<10){
  41               		.loc 1 12 0
  42 0016 9A30      		cpi r25,lo8(10)
  43 0018 00F4      		brsh .L2
  13:Led.c         ****             leds[i].col=i;//0-9
  44               		.loc 1 13 0
  45 001a 9083      		st Z,r25
  46 001c 00C0      		rjmp .L3
  47               	.L2:
  14:Led.c         ****         }else{
  15:Led.c         ****             leds[i].col=i-9;//1-9
  48               		.loc 1 15 0
  49 001e 87EF      		ldi r24,lo8(-9)
  50 0020 890F      		add r24,r25
  51 0022 8083      		st Z,r24
  52               	.L3:
  16:Led.c         ****         }
  17:Led.c         ****         leds[i].c=BLACK;
  53               		.loc 1 17 0 discriminator 2
  54 0024 1282      		std Z+2,__zero_reg__
  10:Led.c         ****         leds[i].row=i%2;//leds[0]=0, leds[1]=1
  55               		.loc 1 10 0 discriminator 2
  56 0026 9F5F      		subi r25,lo8(-(1))
  57               	.LVL3:
  58 0028 3396      		adiw r30,3
  59 002a 9331      		cpi r25,lo8(19)
  60 002c 01F4      		brne .L4
  61               	/* epilogue start */
  62               	.LBE36:
  18:Led.c         ****     }
  19:Led.c         **** }
  63               		.loc 1 19 0
  64 002e 0895      		ret
  65               		.cfi_endproc
  66               	.LFE6:
  68               	.global	getDataByColor
  70               	getDataByColor:
  71               	.LFB7:
  20:Led.c         **** 
  21:Led.c         **** uint32_t getDataByColor(uint8_t c, uint8_t mode, Led* leds){
  72               		.loc 1 21 0
  73               		.cfi_startproc
  74               	.LVL4:
  75 0030 0F93      		push r16
  76               	.LCFI0:
  77               		.cfi_def_cfa_offset 3
  78               		.cfi_offset 16, -2
  79 0032 1F93      		push r17
  80               	.LCFI1:
  81               		.cfi_def_cfa_offset 4
  82               		.cfi_offset 17, -3
  83 0034 CF93      		push r28
  84               	.LCFI2:
  85               		.cfi_def_cfa_offset 5
  86               		.cfi_offset 28, -4
  87 0036 DF93      		push r29
  88               	.LCFI3:
  89               		.cfi_def_cfa_offset 6
  90               		.cfi_offset 29, -5
  91               	/* prologue: function */
  92               	/* frame size = 0 */
  93               	/* stack size = 4 */
  94               	.L__stack_usage = 4
  95 0038 C82F      		mov r28,r24
  96 003a D62F      		mov r29,r22
  97 003c FA01      		movw r30,r20
  98               	.LVL5:
  99 003e 475C      		subi r20,-57
 100 0040 5F4F      		sbci r21,-1
 101               	.LVL6:
  22:Led.c         ****     uint32_t data=0x00000000;
 102               		.loc 1 22 0
 103 0042 60E0      		ldi r22,0
 104 0044 70E0      		ldi r23,0
 105 0046 CB01      		movw r24,r22
 106               	.LVL7:
 107               	.LBB37:
  23:Led.c         ****     for(uint8_t i=0;i<NBLEDS;i++){
  24:Led.c         ****         if(leds[i].row==mode){
  25:Led.c         ****             if((leds[i].c & c) ){
  26:Led.c         ****                 data|=(1<<leds[i].col);
 108               		.loc 1 26 0
 109 0048 A1E0      		ldi r26,lo8(1)
 110 004a B0E0      		ldi r27,0
 111               	.LVL8:
 112               	.L9:
  24:Led.c         ****             if((leds[i].c & c) ){
 113               		.loc 1 24 0
 114 004c 2181      		ldd r18,Z+1
 115 004e 2D13      		cpse r18,r29
 116 0050 00C0      		rjmp .L8
  25:Led.c         ****                 data|=(1<<leds[i].col);
 117               		.loc 1 25 0
 118 0052 2281      		ldd r18,Z+2
 119 0054 2C23      		and r18,r28
 120 0056 01F0      		breq .L8
 121               		.loc 1 26 0
 122 0058 8D01      		movw r16,r26
 123 005a 0080      		ld r0,Z
 124 005c 00C0      		rjmp 2f
 125               		1:
 126 005e 000F      		lsl r16
 127 0060 111F      		rol r17
 128               		2:
 129 0062 0A94      		dec r0
 130 0064 02F4      		brpl 1b
 131 0066 012E      		mov __tmp_reg__,r17
 132 0068 000C      		lsl r0
 133 006a 220B      		sbc r18,r18
 134 006c 330B      		sbc r19,r19
 135 006e 602B      		or r22,r16
 136 0070 712B      		or r23,r17
 137 0072 822B      		or r24,r18
 138 0074 932B      		or r25,r19
 139               	.LVL9:
 140               	.L8:
 141 0076 3396      		adiw r30,3
  23:Led.c         ****     for(uint8_t i=0;i<NBLEDS;i++){
 142               		.loc 1 23 0 discriminator 2
 143 0078 E417      		cp r30,r20
 144 007a F507      		cpc r31,r21
 145 007c 01F4      		brne .L9
 146               	/* epilogue start */
 147               	.LBE37:
  27:Led.c         ****             }
  28:Led.c         ****         }
  29:Led.c         ****     }
  30:Led.c         ****     return data;
  31:Led.c         **** }
 148               		.loc 1 31 0
 149 007e DF91      		pop r29
 150               	.LVL10:
 151 0080 CF91      		pop r28
 152 0082 1F91      		pop r17
 153 0084 0F91      		pop r16
 154 0086 0895      		ret
 155               		.cfi_endproc
 156               	.LFE7:
 158               	.global	ledOn
 160               	ledOn:
 161               	.LFB8:
  32:Led.c         **** 
  33:Led.c         **** void ledOn(Led* l,uint8_t c){
 162               		.loc 1 33 0
 163               		.cfi_startproc
 164               	.LVL11:
 165               	/* prologue: function */
 166               	/* frame size = 0 */
 167               	/* stack size = 0 */
 168               	.L__stack_usage = 0
  34:Led.c         ****     l->c=c;
 169               		.loc 1 34 0
 170 0088 FC01      		movw r30,r24
 171 008a 6283      		std Z+2,r22
 172 008c 0895      		ret
 173               		.cfi_endproc
 174               	.LFE8:
 176               	.global	ledOff
 178               	ledOff:
 179               	.LFB9:
  35:Led.c         **** }
  36:Led.c         **** void ledOff(Led* l){
 180               		.loc 1 36 0
 181               		.cfi_startproc
 182               	.LVL12:
 183               	/* prologue: function */
 184               	/* frame size = 0 */
 185               	/* stack size = 0 */
 186               	.L__stack_usage = 0
  37:Led.c         ****     l->c=BLACK;
 187               		.loc 1 37 0
 188 008e FC01      		movw r30,r24
 189 0090 1282      		std Z+2,__zero_reg__
 190 0092 0895      		ret
 191               		.cfi_endproc
 192               	.LFE9:
 194               	.global	setLeds
 196               	setLeds:
 197               	.LFB10:
  38:Led.c         **** }
  39:Led.c         **** 
  40:Led.c         **** void setLeds(Ttime t,Led* l){
 198               		.loc 1 40 0
 199               		.cfi_startproc
 200               	.LVL13:
 201 0094 FF92      		push r15
 202               	.LCFI4:
 203               		.cfi_def_cfa_offset 3
 204               		.cfi_offset 15, -2
 205 0096 0F93      		push r16
 206               	.LCFI5:
 207               		.cfi_def_cfa_offset 4
 208               		.cfi_offset 16, -3
 209 0098 1F93      		push r17
 210               	.LCFI6:
 211               		.cfi_def_cfa_offset 5
 212               		.cfi_offset 17, -4
 213 009a CF93      		push r28
 214               	.LCFI7:
 215               		.cfi_def_cfa_offset 6
 216               		.cfi_offset 28, -5
 217 009c DF93      		push r29
 218               	.LCFI8:
 219               		.cfi_def_cfa_offset 7
 220               		.cfi_offset 29, -6
 221 009e 00D0      		rcall .
 222 00a0 00D0      		rcall .
 223 00a2 1F92      		push __zero_reg__
 224               	.LCFI9:
 225               		.cfi_def_cfa_offset 12
 226 00a4 CDB7      		in r28,__SP_L__
 227 00a6 DEB7      		in r29,__SP_H__
 228               	.LCFI10:
 229               		.cfi_def_cfa_register 28
 230               	/* prologue: function */
 231               	/* frame size = 5 */
 232               	/* stack size = 10 */
 233               	.L__stack_usage = 10
 234 00a8 8901      		movw r16,r18
 235               	.LVL14:
 236 00aa F901      		movw r30,r18
 237 00ac C901      		movw r24,r18
 238 00ae C996      		adiw r24,57
 239               	.LVL15:
 240               	.L17:
 241               	.LBB38:
 242               	.LBB39:
  37:Led.c         ****     l->c=BLACK;
 243               		.loc 1 37 0 discriminator 2
 244 00b0 1282      		std Z+2,__zero_reg__
 245               	.LVL16:
 246 00b2 3396      		adiw r30,3
 247               	.LBE39:
 248               	.LBE38:
  41:Led.c         ****     uint8_t temp=0;
  42:Led.c         ****     for(;temp<NBLEDS;temp++){
 249               		.loc 1 42 0 discriminator 2
 250 00b4 E817      		cp r30,r24
 251 00b6 F907      		cpc r31,r25
 252 00b8 01F4      		brne .L17
  43:Led.c         ****         ledOff(&l[temp]);
  44:Led.c         ****     }
  45:Led.c         ****     ledOn(&l[ILEST],getColor());
 253               		.loc 1 45 0
 254 00ba 00D0      		rcall getColor
 255               	.LVL17:
 256               	.LBB40:
 257               	.LBB41:
  34:Led.c         **** }
 258               		.loc 1 34 0
 259 00bc F801      		movw r30,r16
 260 00be 80AF      		std Z+56,r24
 261               	.LVL18:
 262               	.LBE41:
 263               	.LBE40:
  46:Led.c         ****     
  47:Led.c         ****     temp=currentTime.hour;
 264               		.loc 1 47 0
 265 00c0 8091 0000 		lds r24,currentTime
 266               	.LVL19:
  48:Led.c         ****     if(currentTime.min>35){
 267               		.loc 1 48 0
 268 00c4 9091 0000 		lds r25,currentTime+1
 269 00c8 9432      		cpi r25,lo8(36)
 270 00ca 00F0      		brlo .L18
  49:Led.c         ****         temp++;
 271               		.loc 1 49 0
 272 00cc 8F5F      		subi r24,lo8(-(1))
 273               	.LVL20:
 274               	.L18:
  50:Led.c         ****     }
  51:Led.c         ****     if(temp)
 275               		.loc 1 51 0
 276 00ce 8823      		tst r24
 277 00d0 01F0      		breq .L19
  52:Led.c         ****     temp=temp%12;
 278               		.loc 1 52 0
 279 00d2 6CE0      		ldi r22,lo8(12)
 280 00d4 00D0      		rcall __udivmodqi4
 281               	.LVL21:
 282 00d6 F92E      		mov r15,r25
 283               	.LVL22:
  53:Led.c         ****     switch(temp){
 284               		.loc 1 53 0
 285 00d8 9111      		cpse r25,__zero_reg__
 286 00da 00C0      		rjmp .L34
 287               	.LVL23:
 288               	.L19:
  54:Led.c         ****         case 0 :
  55:Led.c         ****             ledOn(&l[MINUIT],getColor());
 289               		.loc 1 55 0
 290 00dc 00D0      		rcall getColor
 291               	.LVL24:
 292               	.LBB42:
 293               	.LBB43:
  34:Led.c         **** }
 294               		.loc 1 34 0
 295 00de F801      		movw r30,r16
 296 00e0 8387      		std Z+11,r24
 297 00e2 00C0      		rjmp .L21
 298               	.LVL25:
 299               	.L34:
 300               	.LBE43:
 301               	.LBE42:
  56:Led.c         ****             break;
  57:Led.c         ****         case 12 :
  58:Led.c         ****             ledOn(&l[MIDI],getColor());
  59:Led.c         ****             break;
  60:Led.c         ****         default :
  61:Led.c         ****             ledOn(&l[ledMap[(temp-1)]],getColor());
 302               		.loc 1 61 0
 303 00e4 00D0      		rcall getColor
 304               	.LVL26:
 305 00e6 282F      		mov r18,r24
 306               	.LVL27:
 307 00e8 EF2D      		mov r30,r15
 308 00ea F0E0      		ldi r31,0
 309 00ec E050      		subi r30,lo8(-(ledMap-1))
 310 00ee F040      		sbci r31,hi8(-(ledMap-1))
 311               	.LBB44:
 312               	.LBB45:
  34:Led.c         **** }
 313               		.loc 1 34 0
 314 00f0 8081      		ld r24,Z
 315 00f2 90E0      		ldi r25,0
 316 00f4 63E0      		ldi r22,lo8(3)
 317 00f6 70E0      		ldi r23,0
 318 00f8 00D0      		rcall __mulhi3
 319 00fa 800F      		add r24,r16
 320 00fc 911F      		adc r25,r17
 321 00fe FC01      		movw r30,r24
 322 0100 2283      		std Z+2,r18
 323               	.LVL28:
 324               	.LBE45:
 325               	.LBE44:
  62:Led.c         ****             ledOn(&l[HEURE],getColor());
 326               		.loc 1 62 0
 327 0102 00D0      		rcall getColor
 328               	.LVL29:
 329               	.LBB46:
 330               	.LBB47:
  34:Led.c         **** }
 331               		.loc 1 34 0
 332 0104 F801      		movw r30,r16
 333 0106 87A7      		std Z+47,r24
 334               	.LVL30:
 335               	.L21:
 336               	.LBE47:
 337               	.LBE46:
  63:Led.c         ****             break;
  64:Led.c         ****     }
  65:Led.c         ****     
  66:Led.c         ****     temp = minquad(currentTime.min); 
 338               		.loc 1 66 0
 339 0108 8091 0000 		lds r24,currentTime+1
 340 010c 00D0      		rcall minquad
 341               	.LVL31:
 342 010e F82E      		mov r15,r24
 343               	.LVL32:
  67:Led.c         ****     if(temp > 30){
 344               		.loc 1 67 0
 345 0110 FEE1      		ldi r31,lo8(30)
 346 0112 F817      		cp r31,r24
 347 0114 00F4      		brsh .L22
  68:Led.c         ****         ledOn(&l[MOINS],getColor());
 348               		.loc 1 68 0
 349 0116 00D0      		rcall getColor
 350               	.LVL33:
 351               	.LBB48:
 352               	.LBB49:
  34:Led.c         **** }
 353               		.loc 1 34 0
 354 0118 F801      		movw r30,r16
 355 011a 858F      		std Z+29,r24
 356               	.LVL34:
 357               	.LBE49:
 358               	.LBE48:
  69:Led.c         ****         temp=60-temp;
 359               		.loc 1 69 0
 360 011c 8CE3      		ldi r24,lo8(60)
 361 011e 8F19      		sub r24,r15
 362 0120 F82E      		mov r15,r24
 363               	.LVL35:
 364               	.L22:
  70:Led.c         ****     }
  71:Led.c         ****     switch(temp){
 365               		.loc 1 71 0
 366 0122 F4E1      		ldi r31,lo8(20)
 367 0124 FF16      		cp r15,r31
 368 0126 01F0      		breq .L24
 369 0128 8EE1      		ldi r24,lo8(30)
 370 012a F816      		cp r15,r24
 371 012c 01F0      		breq .L25
 372 012e EAE0      		ldi r30,lo8(10)
 373 0130 FE12      		cpse r15,r30
 374 0132 00C0      		rjmp .L16
  72:Led.c         ****         case 10 :
  73:Led.c         ****             ledOn(&l[DIX],getColor());
 375               		.loc 1 73 0
 376 0134 00D0      		rcall getColor
 377               	.LVL36:
 378               	.LBB50:
 379               	.LBB51:
  34:Led.c         **** }
 380               		.loc 1 34 0
 381 0136 F801      		movw r30,r16
 382 0138 818B      		std Z+17,r24
 383 013a 00C0      		rjmp .L16
 384               	.LVL37:
 385               	.L24:
 386               	.LBE51:
 387               	.LBE50:
  74:Led.c         ****             break;
  75:Led.c         ****         case 20 :
  76:Led.c         ****             ledOn(&l[VINGT],getColor());
 388               		.loc 1 76 0
 389 013c 00D0      		rcall getColor
 390               	.LVL38:
 391               	.LBB52:
 392               	.LBB53:
  34:Led.c         **** }
 393               		.loc 1 34 0
 394 013e F801      		movw r30,r16
 395 0140 83A3      		std Z+35,r24
 396 0142 00C0      		rjmp .L16
 397               	.LVL39:
 398               	.L25:
 399               	.LBE53:
 400               	.LBE52:
  77:Led.c         ****             break;
  78:Led.c         ****         case 30 :
  79:Led.c         ****             ledOn(&l[ETDEMIE],getColor());
 401               		.loc 1 79 0
 402 0144 00D0      		rcall getColor
 403               	.LVL40:
 404               	.LBB54:
 405               	.LBB55:
  34:Led.c         **** }
 406               		.loc 1 34 0
 407 0146 F801      		movw r30,r16
 408 0148 8583      		std Z+5,r24
 409               	.LVL41:
 410               	.L16:
 411               	/* epilogue start */
 412               	.LBE55:
 413               	.LBE54:
  80:Led.c         ****             break;
  81:Led.c         ****     }
  82:Led.c         **** }
 414               		.loc 1 82 0
 415 014a 0F90      		pop __tmp_reg__
 416 014c 0F90      		pop __tmp_reg__
 417 014e 0F90      		pop __tmp_reg__
 418 0150 0F90      		pop __tmp_reg__
 419 0152 0F90      		pop __tmp_reg__
 420 0154 DF91      		pop r29
 421 0156 CF91      		pop r28
 422 0158 1F91      		pop r17
 423 015a 0F91      		pop r16
 424               	.LVL42:
 425 015c FF90      		pop r15
 426               	.LVL43:
 427 015e 0895      		ret
 428               		.cfi_endproc
 429               	.LFE10:
 431               	.global	setLedsNb
 433               	setLedsNb:
 434               	.LFB11:
  83:Led.c         **** 
  84:Led.c         **** void setLedsNb(int8_t nb, Led* l){
 435               		.loc 1 84 0
 436               		.cfi_startproc
 437               	.LVL44:
 438 0160 0F93      		push r16
 439               	.LCFI11:
 440               		.cfi_def_cfa_offset 3
 441               		.cfi_offset 16, -2
 442 0162 1F93      		push r17
 443               	.LCFI12:
 444               		.cfi_def_cfa_offset 4
 445               		.cfi_offset 17, -3
 446 0164 CF93      		push r28
 447               	.LCFI13:
 448               		.cfi_def_cfa_offset 5
 449               		.cfi_offset 28, -4
 450               	/* prologue: function */
 451               	/* frame size = 0 */
 452               	/* stack size = 3 */
 453               	.L__stack_usage = 3
 454 0166 C82F      		mov r28,r24
 455 0168 8B01      		movw r16,r22
 456               	.LVL45:
 457 016a FB01      		movw r30,r22
 458 016c CB01      		movw r24,r22
 459               	.LVL46:
 460 016e C996      		adiw r24,57
 461               	.LVL47:
 462               	.L36:
 463               	.LBB56:
 464               	.LBB57:
  37:Led.c         **** }
 465               		.loc 1 37 0 discriminator 2
 466 0170 1282      		std Z+2,__zero_reg__
 467               	.LVL48:
 468 0172 3396      		adiw r30,3
 469               	.LBE57:
 470               	.LBE56:
  85:Led.c         ****     uint8_t i=0;
  86:Led.c         ****     for(;i<NBLEDS;i++){
 471               		.loc 1 86 0 discriminator 2
 472 0174 8E17      		cp r24,r30
 473 0176 9F07      		cpc r25,r31
 474 0178 01F4      		brne .L36
  87:Led.c         ****         ledOff(&l[i]);
  88:Led.c         ****     }
  89:Led.c         ****     if(nb < 0){
 475               		.loc 1 89 0
 476 017a C7FF      		sbrs r28,7
 477 017c 00C0      		rjmp .L37
  90:Led.c         ****         ledOn(&l[MOINS],getColor());
 478               		.loc 1 90 0
 479 017e 00D0      		rcall getColor
 480               	.LVL49:
 481               	.LBB58:
 482               	.LBB59:
  34:Led.c         **** }
 483               		.loc 1 34 0
 484 0180 F801      		movw r30,r16
 485 0182 858F      		std Z+29,r24
 486               	.LVL50:
 487               	.LBE59:
 488               	.LBE58:
  91:Led.c         ****         nb=-nb;
 489               		.loc 1 91 0
 490 0184 C195      		neg r28
 491               	.LVL51:
 492               	.L37:
  92:Led.c         ****     }
  93:Led.c         ****     if(nb>29){
 493               		.loc 1 93 0
 494 0186 CE31      		cpi r28,lo8(30)
 495 0188 04F0      		brlt .L38
  94:Led.c         ****         ledOn(&l[VINGT],getColor());
 496               		.loc 1 94 0
 497 018a 00D0      		rcall getColor
 498               	.LVL52:
 499               	.LBB60:
 500               	.LBB61:
  34:Led.c         **** }
 501               		.loc 1 34 0
 502 018c F801      		movw r30,r16
 503 018e 83A3      		std Z+35,r24
 504               	.LVL53:
 505               	.LBE61:
 506               	.LBE60:
  95:Led.c         ****         ledOn(&l[DIX],getColor());
 507               		.loc 1 95 0
 508 0190 00D0      		rcall getColor
 509               	.LVL54:
 510               	.LBB62:
 511               	.LBB63:
  34:Led.c         **** }
 512               		.loc 1 34 0
 513 0192 F801      		movw r30,r16
 514 0194 818B      		std Z+17,r24
 515               	.LVL55:
 516               	.LBE63:
 517               	.LBE62:
  96:Led.c         ****         nb=nb-30;
 518               		.loc 1 96 0
 519 0196 CE51      		subi r28,lo8(-(-30))
 520               	.LVL56:
 521 0198 00C0      		rjmp .L39
 522               	.L38:
  97:Led.c         ****     }else if(nb>19){
 523               		.loc 1 97 0
 524 019a C431      		cpi r28,lo8(20)
 525 019c 04F0      		brlt .L40
  98:Led.c         ****         ledOn(&l[VINGT],getColor());
 526               		.loc 1 98 0
 527 019e 00D0      		rcall getColor
 528               	.LVL57:
 529               	.LBB64:
 530               	.LBB65:
  34:Led.c         **** }
 531               		.loc 1 34 0
 532 01a0 F801      		movw r30,r16
 533 01a2 83A3      		std Z+35,r24
 534               	.LVL58:
 535               	.LBE65:
 536               	.LBE64:
  99:Led.c         ****         nb=nb-20;
 537               		.loc 1 99 0
 538 01a4 C451      		subi r28,lo8(-(-20))
 539               	.LVL59:
 540 01a6 00C0      		rjmp .L39
 541               	.L40:
 100:Led.c         ****     }else if(nb>11){
 542               		.loc 1 100 0
 543 01a8 CC30      		cpi r28,lo8(12)
 544 01aa 04F0      		brlt .L39
 101:Led.c         ****         ledOn(&l[DIX],getColor());
 545               		.loc 1 101 0
 546 01ac 00D0      		rcall getColor
 547               	.LVL60:
 548               	.LBB66:
 549               	.LBB67:
  34:Led.c         **** }
 550               		.loc 1 34 0
 551 01ae F801      		movw r30,r16
 552 01b0 818B      		std Z+17,r24
 553               	.LVL61:
 554               	.LBE67:
 555               	.LBE66:
 102:Led.c         ****         nb=nb-10;
 556               		.loc 1 102 0
 557 01b2 CA50      		subi r28,lo8(-(-10))
 558               	.LVL62:
 559               	.L39:
 103:Led.c         ****     }
 104:Led.c         ****     ledOn(&l[ledMap[nb-1]],getColor());
 560               		.loc 1 104 0
 561 01b4 00D0      		rcall getColor
 562               	.LVL63:
 563 01b6 282F      		mov r18,r24
 564               	.LVL64:
 565 01b8 EC2F      		mov r30,r28
 566 01ba CC0F      		lsl r28
 567 01bc FF0B      		sbc r31,r31
 568 01be E050      		subi r30,lo8(-(ledMap-1))
 569 01c0 F040      		sbci r31,hi8(-(ledMap-1))
 570               	.LVL65:
 571               	.LBB68:
 572               	.LBB69:
  34:Led.c         **** }
 573               		.loc 1 34 0
 574 01c2 8081      		ld r24,Z
 575 01c4 90E0      		ldi r25,0
 576 01c6 63E0      		ldi r22,lo8(3)
 577 01c8 70E0      		ldi r23,0
 578 01ca 00D0      		rcall __mulhi3
 579 01cc 800F      		add r24,r16
 580 01ce 911F      		adc r25,r17
 581 01d0 FC01      		movw r30,r24
 582               	.LVL66:
 583 01d2 2283      		std Z+2,r18
 584               	.LVL67:
 585               	/* epilogue start */
 586               	.LBE69:
 587               	.LBE68:
 105:Led.c         **** }
 588               		.loc 1 105 0
 589 01d4 CF91      		pop r28
 590               	.LVL68:
 591 01d6 1F91      		pop r17
 592 01d8 0F91      		pop r16
 593               	.LVL69:
 594 01da 0895      		ret
 595               		.cfi_endproc
 596               	.LFE11:
 598               	.global	sendRawData
 600               	sendRawData:
 601               	.LFB12:
 106:Led.c         **** void sendRawData(uint32_t data){
 602               		.loc 1 106 0
 603               		.cfi_startproc
 604               	.LVL70:
 605 01dc 0F93      		push r16
 606               	.LCFI14:
 607               		.cfi_def_cfa_offset 3
 608               		.cfi_offset 16, -2
 609 01de 1F93      		push r17
 610               	.LCFI15:
 611               		.cfi_def_cfa_offset 4
 612               		.cfi_offset 17, -3
 613               	/* prologue: function */
 614               	/* frame size = 0 */
 615               	/* stack size = 2 */
 616               	.L__stack_usage = 2
 107:Led.c         ****     PORTA &=~(STROBE|CLK);
 617               		.loc 1 107 0
 618 01e0 2BB3      		in r18,0x1b
 619 01e2 237F      		andi r18,lo8(-13)
 620 01e4 2BBB      		out 0x1b,r18
 621               	.LVL71:
 622 01e6 40E0      		ldi r20,0
 623 01e8 50E0      		ldi r21,0
 624               	.LVL72:
 625               	.L45:
 626               	.LBB70:
 108:Led.c         ****     for(uint8_t i=0;i<20;i++){
 109:Led.c         ****         if((data>>i) & 0x00000001){
 627               		.loc 1 109 0
 628 01ea 8B01      		movw r16,r22
 629 01ec 9C01      		movw r18,r24
 630 01ee 042E      		mov r0,r20
 631 01f0 00C0      		rjmp 2f
 632               		1:
 633 01f2 3695      		lsr r19
 634 01f4 2795      		ror r18
 635 01f6 1795      		ror r17
 636 01f8 0795      		ror r16
 637               		2:
 638 01fa 0A94      		dec r0
 639 01fc 02F4      		brpl 1b
 640 01fe 00FF      		sbrs r16,0
 641 0200 00C0      		rjmp .L43
 110:Led.c         ****             PORTA|=DATA;
 642               		.loc 1 110 0
 643 0202 D99A      		sbi 0x1b,1
 644 0204 00C0      		rjmp .L44
 645               	.L43:
 111:Led.c         ****         }else{
 112:Led.c         ****             PORTA&=~DATA;
 646               		.loc 1 112 0
 647 0206 D998      		cbi 0x1b,1
 648               	.L44:
 113:Led.c         ****         }
 114:Led.c         ****         PORTA|=CLK;
 649               		.loc 1 114 0 discriminator 2
 650 0208 DB9A      		sbi 0x1b,3
 115:Led.c         ****         PORTA&=~CLK;
 651               		.loc 1 115 0 discriminator 2
 652 020a DB98      		cbi 0x1b,3
 653               	.LVL73:
 654 020c 4F5F      		subi r20,-1
 655 020e 5F4F      		sbci r21,-1
 656               	.LVL74:
 108:Led.c         ****         if((data>>i) & 0x00000001){
 657               		.loc 1 108 0 discriminator 2
 658 0210 4431      		cpi r20,20
 659 0212 5105      		cpc r21,__zero_reg__
 660 0214 01F4      		brne .L45
 661               	.LBE70:
 116:Led.c         ****     }
 117:Led.c         ****     PORTA|=STROBE;
 662               		.loc 1 117 0
 663 0216 DA9A      		sbi 0x1b,2
 118:Led.c         ****     PORTA&=~STROBE;
 664               		.loc 1 118 0
 665 0218 DA98      		cbi 0x1b,2
 666               	/* epilogue start */
 119:Led.c         **** }
 667               		.loc 1 119 0
 668 021a 1F91      		pop r17
 669 021c 0F91      		pop r16
 670 021e 0895      		ret
 671               		.cfi_endproc
 672               	.LFE12:
 674               		.section	.rodata
 677               	ledMap:
 678 0000 07        		.byte	7
 679 0001 08        		.byte	8
 680 0002 0A        		.byte	10
 681 0003 0E        		.byte	14
 682 0004 00        		.byte	0
 683 0005 04        		.byte	4
 684 0006 11        		.byte	17
 685 0007 02        		.byte	2
 686 0008 0C        		.byte	12
 687 0009 06        		.byte	6
 688 000a 10        		.byte	16
 689               		.comm	M1rainbow,3,1
 690               		.comm	M1reset,3,1
 691               		.comm	M1eventMode,3,1
 692               		.comm	M2setminpm,3,1
 693               		.comm	M2setminam,3,1
 694               		.comm	M2sethourpm,3,1
 695               		.comm	M2sethouram,3,1
 696               		.comm	M1setTime,3,1
 697               		.comm	M3onhour,3,1
 698               		.comm	M2offhour,3,1
 699               		.comm	M1nightmode,3,1
 700               		.comm	M1cmode,3,1
 701               		.comm	M1mode,3,1
 702               		.comm	M0main,3,1
 703               		.comm	USI_I2C_Master_State,1,1
 704               		.comm	currentTime,5,1
 705               		.text
 706               	.Letext0:
 707               		.file 2 "/usr/lib/avr/include/stdint.h"
 708               		.file 3 "RTC.h"
 709               		.file 4 "Menu.h"
 710               		.file 5 "Led.h"
 711               		.file 6 "defines.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Led.c
     /tmp/cc4ZtoG1.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc4ZtoG1.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc4ZtoG1.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc4ZtoG1.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc4ZtoG1.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc4ZtoG1.s:12     .text:0000000000000000 ledInit
     /tmp/cc4ZtoG1.s:70     .text:0000000000000030 getDataByColor
     /tmp/cc4ZtoG1.s:160    .text:0000000000000088 ledOn
     /tmp/cc4ZtoG1.s:178    .text:000000000000008e ledOff
     /tmp/cc4ZtoG1.s:196    .text:0000000000000094 setLeds
                            *COM*:0000000000000005 currentTime
     /tmp/cc4ZtoG1.s:677    .rodata:0000000000000000 ledMap
     /tmp/cc4ZtoG1.s:433    .text:0000000000000160 setLedsNb
     /tmp/cc4ZtoG1.s:600    .text:00000000000001dc sendRawData
                            *COM*:0000000000000003 M1rainbow
                            *COM*:0000000000000003 M1reset
                            *COM*:0000000000000003 M1eventMode
                            *COM*:0000000000000003 M2setminpm
                            *COM*:0000000000000003 M2setminam
                            *COM*:0000000000000003 M2sethourpm
                            *COM*:0000000000000003 M2sethouram
                            *COM*:0000000000000003 M1setTime
                            *COM*:0000000000000003 M3onhour
                            *COM*:0000000000000003 M2offhour
                            *COM*:0000000000000003 M1nightmode
                            *COM*:0000000000000003 M1cmode
                            *COM*:0000000000000003 M1mode
                            *COM*:0000000000000003 M0main
                            *COM*:0000000000000001 USI_I2C_Master_State

UNDEFINED SYMBOLS
getColor
__udivmodqi4
__mulhi3
minquad
__do_copy_data
__do_clear_bss
