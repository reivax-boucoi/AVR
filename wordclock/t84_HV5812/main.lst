   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	sendData
  12               	sendData:
  13               	.LFB6:
  14               		.file 1 "main.c"
   1:main.c        **** #define F_CPU 16000000UL
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** #include <util/delay.h>
   5:main.c        **** #include "defines.h"
   6:main.c        **** #include "Led.h"
   7:main.c        **** #include "RTC.h"
   8:main.c        **** #include "Menu.h"
   9:main.c        **** 
  10:main.c        **** uint8_t ledr=0;
  11:main.c        **** uint8_t ledb=0;
  12:main.c        **** 
  13:main.c        **** void sendData(uint32_t data){
  15               		.loc 1 13 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  14:main.c        ****     if(ledr)data|=LEDR;
  22               		.loc 1 14 0
  23 0000 2091 0000 		lds r18,ledr
  24 0004 2111      		cpse r18,__zero_reg__
  25               		.loc 1 14 0 is_stmt 0 discriminator 1
  26 0006 7860      		ori r23,8
  27               	.LVL1:
  28               	.L2:
  15:main.c        ****     if(ledb)data|=LEDB;
  29               		.loc 1 15 0 is_stmt 1
  30 0008 2091 0000 		lds r18,ledb
  31 000c 2111      		cpse r18,__zero_reg__
  32               		.loc 1 15 0 is_stmt 0 discriminator 1
  33 000e 7460      		ori r23,4
  34               	.LVL2:
  35               	.L3:
  16:main.c        ****     sendRawData(data);
  36               		.loc 1 16 0 is_stmt 1
  37 0010 00C0      		rjmp sendRawData
  38               	.LVL3:
  39               		.cfi_endproc
  40               	.LFE6:
  42               		.section	.text.startup,"ax",@progbits
  43               	.global	main
  45               	main:
  46               	.LFB7:
  17:main.c        **** }
  18:main.c        **** 
  19:main.c        **** 
  20:main.c        **** volatile uint8_t state=0;
  21:main.c        **** struct Menu* Mcurrent=0;
  22:main.c        **** uint8_t Mindex=0;
  23:main.c        **** Led leds[NBLEDS];
  24:main.c        **** 
  25:main.c        **** int main(void){    
  47               		.loc 1 25 0
  48               		.cfi_startproc
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
  26:main.c        ****     ledInit(leds);
  53               		.loc 1 26 0
  54 0000 80E0      		ldi r24,lo8(leds)
  55 0002 90E0      		ldi r25,hi8(leds)
  56 0004 00D0      		rcall ledInit
  57               	.LVL4:
  27:main.c        ****     DDRA&=~(BTNINTERNAL|BTNOK);
  58               		.loc 1 27 0
  59 0006 8AB3      		in r24,0x1a
  60 0008 8F75      		andi r24,lo8(95)
  61 000a 8ABB      		out 0x1a,r24
  28:main.c        ****     DDRB&=~BTNSELECT;
  62               		.loc 1 28 0
  63 000c BA98      		cbi 0x17,2
  29:main.c        ****     PORTA|=(BTNINTERNAL|BTNOK);
  64               		.loc 1 29 0
  65 000e 8BB3      		in r24,0x1b
  66 0010 806A      		ori r24,lo8(-96)
  67 0012 8BBB      		out 0x1b,r24
  30:main.c        ****     PORTB|=BTNSELECT;
  68               		.loc 1 30 0
  69 0014 C29A      		sbi 0x18,2
  31:main.c        ****     TIMSK1|=(1<<TOIE1);//|(1<<OCIE1B);
  70               		.loc 1 31 0
  71 0016 609A      		sbi 0xc,0
  32:main.c        ****    // OCR1B=32768;
  33:main.c        ****     TIMSK0|=(1<<TOIE0);
  72               		.loc 1 33 0
  73 0018 89B7      		in r24,0x39
  74 001a 8160      		ori r24,lo8(1)
  75 001c 89BF      		out 0x39,r24
  34:main.c        ****     GIMSK|=(1<<PCIE1)|(1<<PCIE0);
  76               		.loc 1 34 0
  77 001e 8BB7      		in r24,0x3b
  78 0020 8063      		ori r24,lo8(48)
  79 0022 8BBF      		out 0x3b,r24
  35:main.c        ****     PCMSK0|=(1<<PCINT7)|(1<<PCINT5);
  80               		.loc 1 35 0
  81 0024 82B3      		in r24,0x12
  82 0026 806A      		ori r24,lo8(-96)
  83 0028 82BB      		out 0x12,r24
  36:main.c        ****     PCMSK1|=(1<<PCINT10);
  84               		.loc 1 36 0
  85 002a 80B5      		in r24,0x20
  86 002c 8460      		ori r24,lo8(4)
  87 002e 80BD      		out 0x20,r24
  37:main.c        ****     sei();
  88               		.loc 1 37 0
  89               	/* #APP */
  90               	 ;  37 "main.c" 1
  91 0030 7894      		sei
  92               	 ;  0 "" 2
  38:main.c        ****     
  39:main.c        ****     sendData(0b11111100001111111111);//white
  93               		.loc 1 39 0
  94               	/* #NOAPP */
  95 0032 6FEF      		ldi r22,lo8(-1)
  96 0034 73EC      		ldi r23,lo8(-61)
  97 0036 8FE0      		ldi r24,lo8(15)
  98 0038 90E0      		ldi r25,0
  99 003a 00D0      		rcall sendData
 100               	.LVL5:
 101               	.LBB16:
 102               	.LBB17:
 103               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 104               		.loc 2 187 0
 105 003c 2FEF      		ldi r18,lo8(1599999)
 106 003e 89E6      		ldi r24,hi8(1599999)
 107 0040 98E1      		ldi r25,hlo8(1599999)
 108 0042 2150      	1:	subi r18,1
 109 0044 8040      		sbci r24,0
 110 0046 9040      		sbci r25,0
 111 0048 01F4      		brne 1b
 112 004a 00C0      		rjmp .
 113 004c 0000      		nop
 114               	.LVL6:
 115               	.LBE17:
 116               	.LBE16:
  40:main.c        ****     _delay_ms(500);
  41:main.c        ****     sendData(0b11000000001111111111);//green
 117               		.loc 1 41 0
 118 004e 6FEF      		ldi r22,lo8(-1)
 119 0050 73E0      		ldi r23,lo8(3)
 120 0052 8CE0      		ldi r24,lo8(12)
 121 0054 90E0      		ldi r25,0
 122 0056 00D0      		rcall sendData
 123               	.LVL7:
 124               	.LBB18:
 125               	.LBB19:
 126               		.loc 2 187 0
 127 0058 2FEF      		ldi r18,lo8(1599999)
 128 005a 89E6      		ldi r24,hi8(1599999)
 129 005c 98E1      		ldi r25,hlo8(1599999)
 130 005e 2150      	1:	subi r18,1
 131 0060 8040      		sbci r24,0
 132 0062 9040      		sbci r25,0
 133 0064 01F4      		brne 1b
 134 0066 00C0      		rjmp .
 135 0068 0000      		nop
 136               	.LVL8:
 137               	.LBE19:
 138               	.LBE18:
  42:main.c        ****     _delay_ms(500);
  43:main.c        ****     sendData(0b00001100001111111111);//red
 139               		.loc 1 43 0
 140 006a 6FEF      		ldi r22,lo8(-1)
 141 006c 73EC      		ldi r23,lo8(-61)
 142 006e 80E0      		ldi r24,0
 143 0070 90E0      		ldi r25,0
 144 0072 00D0      		rcall sendData
 145               	.LVL9:
 146               	.LBB20:
 147               	.LBB21:
 148               		.loc 2 187 0
 149 0074 2FEF      		ldi r18,lo8(1599999)
 150 0076 89E6      		ldi r24,hi8(1599999)
 151 0078 98E1      		ldi r25,hlo8(1599999)
 152 007a 2150      	1:	subi r18,1
 153 007c 8040      		sbci r24,0
 154 007e 9040      		sbci r25,0
 155 0080 01F4      		brne 1b
 156 0082 00C0      		rjmp .
 157 0084 0000      		nop
 158               	.LVL10:
 159               	.LBE21:
 160               	.LBE20:
  44:main.c        ****     _delay_ms(500);
  45:main.c        ****     sendData(0b00110000001111111111);//blue
 161               		.loc 1 45 0
 162 0086 6FEF      		ldi r22,lo8(-1)
 163 0088 73E0      		ldi r23,lo8(3)
 164 008a 83E0      		ldi r24,lo8(3)
 165 008c 90E0      		ldi r25,0
 166 008e 00D0      		rcall sendData
 167               	.LVL11:
 168               	.LBB22:
 169               	.LBB23:
 170               		.loc 2 187 0
 171 0090 2FEF      		ldi r18,lo8(1599999)
 172 0092 89E6      		ldi r24,hi8(1599999)
 173 0094 98E1      		ldi r25,hlo8(1599999)
 174 0096 2150      	1:	subi r18,1
 175 0098 8040      		sbci r24,0
 176 009a 9040      		sbci r25,0
 177 009c 01F4      		brne 1b
 178 009e 00C0      		rjmp .
 179 00a0 0000      		nop
 180               	.LVL12:
 181               	.LBE23:
 182               	.LBE22:
  46:main.c        ****     _delay_ms(500);
  47:main.c        ****     sendData(0b11110000001111111111);//cyan
 183               		.loc 1 47 0
 184 00a2 6FEF      		ldi r22,lo8(-1)
 185 00a4 73E0      		ldi r23,lo8(3)
 186 00a6 8FE0      		ldi r24,lo8(15)
 187 00a8 90E0      		ldi r25,0
 188 00aa 00D0      		rcall sendData
 189               	.LVL13:
 190               	.LBB24:
 191               	.LBB25:
 192               		.loc 2 187 0
 193 00ac 2FEF      		ldi r18,lo8(1599999)
 194 00ae 89E6      		ldi r24,hi8(1599999)
 195 00b0 98E1      		ldi r25,hlo8(1599999)
 196 00b2 2150      	1:	subi r18,1
 197 00b4 8040      		sbci r24,0
 198 00b6 9040      		sbci r25,0
 199 00b8 01F4      		brne 1b
 200 00ba 00C0      		rjmp .
 201 00bc 0000      		nop
 202               	.LVL14:
 203               	.LBE25:
 204               	.LBE24:
  48:main.c        ****     _delay_ms(500);
  49:main.c        ****     sendData(0b00111100001111111111);//magenta
 205               		.loc 1 49 0
 206 00be 6FEF      		ldi r22,lo8(-1)
 207 00c0 73EC      		ldi r23,lo8(-61)
 208 00c2 83E0      		ldi r24,lo8(3)
 209 00c4 90E0      		ldi r25,0
 210 00c6 00D0      		rcall sendData
 211               	.LVL15:
 212               	.LBB26:
 213               	.LBB27:
 214               		.loc 2 187 0
 215 00c8 2FEF      		ldi r18,lo8(1599999)
 216 00ca 89E6      		ldi r24,hi8(1599999)
 217 00cc 98E1      		ldi r25,hlo8(1599999)
 218 00ce 2150      	1:	subi r18,1
 219 00d0 8040      		sbci r24,0
 220 00d2 9040      		sbci r25,0
 221 00d4 01F4      		brne 1b
 222 00d6 00C0      		rjmp .
 223 00d8 0000      		nop
 224               	.LVL16:
 225               	.LBE27:
 226               	.LBE26:
  50:main.c        ****     _delay_ms(500);
  51:main.c        ****     sendData(0b11001100001111111111);//yellow
 227               		.loc 1 51 0
 228 00da 6FEF      		ldi r22,lo8(-1)
 229 00dc 73EC      		ldi r23,lo8(-61)
 230 00de 8CE0      		ldi r24,lo8(12)
 231 00e0 90E0      		ldi r25,0
 232 00e2 00D0      		rcall sendData
 233               	.LVL17:
 234               	.LBB28:
 235               	.LBB29:
 236               		.loc 2 187 0
 237 00e4 2FEF      		ldi r18,lo8(1599999)
 238 00e6 89E6      		ldi r24,hi8(1599999)
 239 00e8 98E1      		ldi r25,hlo8(1599999)
 240 00ea 2150      	1:	subi r18,1
 241 00ec 8040      		sbci r24,0
 242 00ee 9040      		sbci r25,0
 243 00f0 01F4      		brne 1b
 244 00f2 00C0      		rjmp .
 245 00f4 0000      		nop
 246               	.LVL18:
 247               	.LBE29:
 248               	.LBE28:
  52:main.c        ****     _delay_ms(500);
  53:main.c        ****     
  54:main.c        ****     #ifdef DELLONG
  55:main.c        ****     TCCR1B|=(1<<CS12)|(1<<CS10);
 249               		.loc 1 55 0
 250 00f6 8EB5      		in r24,0x2e
 251 00f8 8560      		ori r24,lo8(5)
 252 00fa 8EBD      		out 0x2e,r24
  56:main.c        ****     #else
  57:main.c        ****     TCCR1B|=(1<<CS12);//|(1<<CS10);
  58:main.c        ****     #endif
  59:main.c        ****     
  60:main.c        ****     TCCR0B|=(1<<CS01)|(1<<CS00);
 253               		.loc 1 60 0
 254 00fc 83B7      		in r24,0x33
 255 00fe 8360      		ori r24,lo8(3)
 256 0100 83BF      		out 0x33,r24
  61:main.c        ****     
  62:main.c        ****     setCurrentTime(0,10,7,12);
 257               		.loc 1 62 0
 258 0102 2CE0      		ldi r18,lo8(12)
 259 0104 47E0      		ldi r20,lo8(7)
 260 0106 6AE0      		ldi r22,lo8(10)
 261 0108 80E0      		ldi r24,0
 262 010a 00D0      		rcall setCurrentTime
 263               	.LVL19:
  63:main.c        ****     // //RTC_setTime(currentTime,6,18);
  64:main.c        ****     RTC_readTime(&currentTime);
 264               		.loc 1 64 0
 265 010c 80E0      		ldi r24,lo8(currentTime)
 266 010e 90E0      		ldi r25,hi8(currentTime)
 267 0110 00D0      		rcall RTC_readTime
 268               	.LVL20:
 269               	.L12:
 270 0112 00C0      		rjmp .L12
 271               		.cfi_endproc
 272               	.LFE7:
 274               		.text
 275               	.global	__vector_3
 277               	__vector_3:
 278               	.LFB8:
  65:main.c        ****     while(1){
  66:main.c        ****     }
  67:main.c        ****     return(0);
  68:main.c        ****     
  69:main.c        **** }
  70:main.c        **** ISR( PCINT1_vect){
 279               		.loc 1 70 0
 280               		.cfi_startproc
 281 0012 1F92      		push r1
 282               	.LCFI0:
 283               		.cfi_def_cfa_offset 3
 284               		.cfi_offset 1, -2
 285 0014 0F92      		push r0
 286               	.LCFI1:
 287               		.cfi_def_cfa_offset 4
 288               		.cfi_offset 0, -3
 289 0016 0FB6      		in r0,__SREG__
 290 0018 0F92      		push r0
 291 001a 1124      		clr __zero_reg__
 292 001c 2F93      		push r18
 293               	.LCFI2:
 294               		.cfi_def_cfa_offset 5
 295               		.cfi_offset 18, -4
 296 001e 3F93      		push r19
 297               	.LCFI3:
 298               		.cfi_def_cfa_offset 6
 299               		.cfi_offset 19, -5
 300 0020 4F93      		push r20
 301               	.LCFI4:
 302               		.cfi_def_cfa_offset 7
 303               		.cfi_offset 20, -6
 304 0022 5F93      		push r21
 305               	.LCFI5:
 306               		.cfi_def_cfa_offset 8
 307               		.cfi_offset 21, -7
 308 0024 6F93      		push r22
 309               	.LCFI6:
 310               		.cfi_def_cfa_offset 9
 311               		.cfi_offset 22, -8
 312 0026 7F93      		push r23
 313               	.LCFI7:
 314               		.cfi_def_cfa_offset 10
 315               		.cfi_offset 23, -9
 316 0028 8F93      		push r24
 317               	.LCFI8:
 318               		.cfi_def_cfa_offset 11
 319               		.cfi_offset 24, -10
 320 002a 9F93      		push r25
 321               	.LCFI9:
 322               		.cfi_def_cfa_offset 12
 323               		.cfi_offset 25, -11
 324 002c AF93      		push r26
 325               	.LCFI10:
 326               		.cfi_def_cfa_offset 13
 327               		.cfi_offset 26, -12
 328 002e BF93      		push r27
 329               	.LCFI11:
 330               		.cfi_def_cfa_offset 14
 331               		.cfi_offset 27, -13
 332 0030 EF93      		push r30
 333               	.LCFI12:
 334               		.cfi_def_cfa_offset 15
 335               		.cfi_offset 30, -14
 336 0032 FF93      		push r31
 337               	.LCFI13:
 338               		.cfi_def_cfa_offset 16
 339               		.cfi_offset 31, -15
 340               	/* prologue: Signal */
 341               	/* frame size = 0 */
 342               	/* stack size = 15 */
 343               	.L__stack_usage = 15
  71:main.c        ****     if(PINB&BTNSELECT){
 344               		.loc 1 71 0
 345 0034 B29B      		sbis 0x16,2
 346 0036 00C0      		rjmp .L13
  72:main.c        ****         Mindex=findNextEntry(Mcurrent,Mindex);
 347               		.loc 1 72 0
 348 0038 6091 0000 		lds r22,Mindex
 349 003c 8091 0000 		lds r24,Mcurrent
 350 0040 9091 0000 		lds r25,Mcurrent+1
 351 0044 00D0      		rcall findNextEntry
 352               	.LVL21:
 353 0046 8093 0000 		sts Mindex,r24
  73:main.c        ****         TCNT1=65534;
 354               		.loc 1 73 0
 355 004a 8EEF      		ldi r24,lo8(-2)
 356 004c 9FEF      		ldi r25,lo8(-1)
 357 004e 9DBD      		out 0x2c+1,r25
 358 0050 8CBD      		out 0x2c,r24
 359               	.L13:
 360               	/* epilogue start */
  74:main.c        ****     }
  75:main.c        **** }
 361               		.loc 1 75 0
 362 0052 FF91      		pop r31
 363 0054 EF91      		pop r30
 364 0056 BF91      		pop r27
 365 0058 AF91      		pop r26
 366 005a 9F91      		pop r25
 367 005c 8F91      		pop r24
 368 005e 7F91      		pop r23
 369 0060 6F91      		pop r22
 370 0062 5F91      		pop r21
 371 0064 4F91      		pop r20
 372 0066 3F91      		pop r19
 373 0068 2F91      		pop r18
 374 006a 0F90      		pop r0
 375 006c 0FBE      		out __SREG__,r0
 376 006e 0F90      		pop r0
 377 0070 1F90      		pop r1
 378 0072 1895      		reti
 379               		.cfi_endproc
 380               	.LFE8:
 382               	.global	__vector_2
 384               	__vector_2:
 385               	.LFB9:
  76:main.c        **** ISR( PCINT0_vect){
 386               		.loc 1 76 0
 387               		.cfi_startproc
 388 0074 1F92      		push r1
 389               	.LCFI14:
 390               		.cfi_def_cfa_offset 3
 391               		.cfi_offset 1, -2
 392 0076 0F92      		push r0
 393               	.LCFI15:
 394               		.cfi_def_cfa_offset 4
 395               		.cfi_offset 0, -3
 396 0078 0FB6      		in r0,__SREG__
 397 007a 0F92      		push r0
 398 007c 1124      		clr __zero_reg__
 399 007e 2F93      		push r18
 400               	.LCFI16:
 401               		.cfi_def_cfa_offset 5
 402               		.cfi_offset 18, -4
 403 0080 3F93      		push r19
 404               	.LCFI17:
 405               		.cfi_def_cfa_offset 6
 406               		.cfi_offset 19, -5
 407 0082 4F93      		push r20
 408               	.LCFI18:
 409               		.cfi_def_cfa_offset 7
 410               		.cfi_offset 20, -6
 411 0084 5F93      		push r21
 412               	.LCFI19:
 413               		.cfi_def_cfa_offset 8
 414               		.cfi_offset 21, -7
 415 0086 6F93      		push r22
 416               	.LCFI20:
 417               		.cfi_def_cfa_offset 9
 418               		.cfi_offset 22, -8
 419 0088 7F93      		push r23
 420               	.LCFI21:
 421               		.cfi_def_cfa_offset 10
 422               		.cfi_offset 23, -9
 423 008a 8F93      		push r24
 424               	.LCFI22:
 425               		.cfi_def_cfa_offset 11
 426               		.cfi_offset 24, -10
 427 008c 9F93      		push r25
 428               	.LCFI23:
 429               		.cfi_def_cfa_offset 12
 430               		.cfi_offset 25, -11
 431 008e AF93      		push r26
 432               	.LCFI24:
 433               		.cfi_def_cfa_offset 13
 434               		.cfi_offset 26, -12
 435 0090 BF93      		push r27
 436               	.LCFI25:
 437               		.cfi_def_cfa_offset 14
 438               		.cfi_offset 27, -13
 439 0092 CF93      		push r28
 440               	.LCFI26:
 441               		.cfi_def_cfa_offset 15
 442               		.cfi_offset 28, -14
 443 0094 DF93      		push r29
 444               	.LCFI27:
 445               		.cfi_def_cfa_offset 16
 446               		.cfi_offset 29, -15
 447 0096 EF93      		push r30
 448               	.LCFI28:
 449               		.cfi_def_cfa_offset 17
 450               		.cfi_offset 30, -16
 451 0098 FF93      		push r31
 452               	.LCFI29:
 453               		.cfi_def_cfa_offset 18
 454               		.cfi_offset 31, -17
 455               	/* prologue: Signal */
 456               	/* frame size = 0 */
 457               	/* stack size = 17 */
 458               	.L__stack_usage = 17
  77:main.c        ****     if(PINA&BTNOK){
 459               		.loc 1 77 0
 460 009a CF9B      		sbis 0x19,7
 461 009c 00C0      		rjmp .L19
  78:main.c        ****         if(!Mcurrent){
 462               		.loc 1 78 0
 463 009e A091 0000 		lds r26,Mcurrent
 464 00a2 B091 0000 		lds r27,Mcurrent+1
 465 00a6 1097      		sbiw r26,0
 466 00a8 01F4      		brne .L20
  79:main.c        ****             Mcurrent=&M0main;//if not in menu mode
 467               		.loc 1 79 0
 468 00aa 80E0      		ldi r24,lo8(M0main)
 469 00ac 90E0      		ldi r25,hi8(M0main)
 470 00ae 9093 0000 		sts Mcurrent+1,r25
 471 00b2 8093 0000 		sts Mcurrent,r24
 472 00b6 00C0      		rjmp .L21
 473               	.L20:
  80:main.c        ****         }else{//enter menu and execute
  81:main.c        ****             if(Mcurrent->fptr!=0 && Mcurrent->sub[Mindex].submenu==0)Mcurrent->fptr(Mindex);//check
 474               		.loc 1 81 0
 475 00b8 1196      		adiw r26,1
 476 00ba ED91      		ld r30,X+
 477 00bc FC91      		ld r31,X
 478 00be 1297      		sbiw r26,1+1
 479 00c0 3097      		sbiw r30,0
 480 00c2 01F0      		breq .L22
 481               		.loc 1 81 0 is_stmt 0 discriminator 1
 482 00c4 2091 0000 		lds r18,Mindex
 483 00c8 822F      		mov r24,r18
 484 00ca 90E0      		ldi r25,0
 485 00cc 63E0      		ldi r22,lo8(3)
 486 00ce 70E0      		ldi r23,0
 487 00d0 00D0      		rcall __mulhi3
 488 00d2 A80F      		add r26,r24
 489 00d4 B91F      		adc r27,r25
 490 00d6 1496      		adiw r26,4
 491 00d8 8D91      		ld r24,X+
 492 00da 9C91      		ld r25,X
 493 00dc 1597      		sbiw r26,4+1
 494 00de 892B      		or r24,r25
 495 00e0 01F4      		brne .L22
 496               		.loc 1 81 0 discriminator 2
 497 00e2 822F      		mov r24,r18
 498 00e4 0995      		icall
 499               	.LVL22:
 500               	.L22:
  82:main.c        ****             Mcurrent=getSubMenu(Mcurrent,Mindex);//get new menu
 501               		.loc 1 82 0 is_stmt 1
 502 00e6 6091 0000 		lds r22,Mindex
 503 00ea 8091 0000 		lds r24,Mcurrent
 504 00ee 9091 0000 		lds r25,Mcurrent+1
 505 00f2 00D0      		rcall getSubMenu
 506               	.LVL23:
 507 00f4 9093 0000 		sts Mcurrent+1,r25
 508 00f8 8093 0000 		sts Mcurrent,r24
  83:main.c        ****             Mindex=0;
 509               		.loc 1 83 0
 510 00fc 1092 0000 		sts Mindex,__zero_reg__
 511               	.LVL24:
 512 0100 C0E0      		ldi r28,lo8(leds)
 513 0102 D0E0      		ldi r29,hi8(leds)
 514               	.LVL25:
 515               	.L23:
 516               	.LBB30:
  84:main.c        ****             for(uint8_t i=0;i<NBLEDS;i++){
  85:main.c        ****                 ledOff(&leds[i]);
 517               		.loc 1 85 0 discriminator 3
 518 0104 CE01      		movw r24,r28
 519 0106 00D0      		rcall ledOff
 520               	.LVL26:
 521 0108 2396      		adiw r28,3
  84:main.c        ****             for(uint8_t i=0;i<NBLEDS;i++){
 522               		.loc 1 84 0 discriminator 3
 523 010a 80E0      		ldi r24,hi8(leds+57)
 524 010c C030      		cpi r28,lo8(leds+57)
 525 010e D807      		cpc r29,r24
 526 0110 01F4      		brne .L23
 527               	.L21:
 528               	.LBE30:
  86:main.c        ****             }
  87:main.c        ****         }
  88:main.c        ****         TCNT1=65534;
 529               		.loc 1 88 0
 530 0112 8EEF      		ldi r24,lo8(-2)
 531 0114 9FEF      		ldi r25,lo8(-1)
 532 0116 9DBD      		out 0x2c+1,r25
 533 0118 8CBD      		out 0x2c,r24
 534               	.L19:
  89:main.c        ****     }
  90:main.c        ****     if(PINA&BTNINTERNAL){
 535               		.loc 1 90 0
 536 011a 89B3      		in r24,0x19
 537               	/* epilogue start */
  91:main.c        ****     }
  92:main.c        **** }/*
 538               		.loc 1 92 0
 539 011c FF91      		pop r31
 540 011e EF91      		pop r30
 541 0120 DF91      		pop r29
 542 0122 CF91      		pop r28
 543 0124 BF91      		pop r27
 544 0126 AF91      		pop r26
 545 0128 9F91      		pop r25
 546 012a 8F91      		pop r24
 547 012c 7F91      		pop r23
 548 012e 6F91      		pop r22
 549 0130 5F91      		pop r21
 550 0132 4F91      		pop r20
 551 0134 3F91      		pop r19
 552 0136 2F91      		pop r18
 553 0138 0F90      		pop r0
 554 013a 0FBE      		out __SREG__,r0
 555 013c 0F90      		pop r0
 556 013e 1F90      		pop r1
 557 0140 1895      		reti
 558               		.cfi_endproc
 559               	.LFE9:
 561               	.global	__vector_8
 563               	__vector_8:
 564               	.LFB10:
  93:main.c        **** ISR( TIM1_COMPB_vect){
  94:main.c        **** }*/
  95:main.c        **** ISR( TIM1_OVF_vect ){
 565               		.loc 1 95 0
 566               		.cfi_startproc
 567 0142 1F92      		push r1
 568               	.LCFI30:
 569               		.cfi_def_cfa_offset 3
 570               		.cfi_offset 1, -2
 571 0144 0F92      		push r0
 572               	.LCFI31:
 573               		.cfi_def_cfa_offset 4
 574               		.cfi_offset 0, -3
 575 0146 0FB6      		in r0,__SREG__
 576 0148 0F92      		push r0
 577 014a 1124      		clr __zero_reg__
 578 014c 0F93      		push r16
 579               	.LCFI32:
 580               		.cfi_def_cfa_offset 5
 581               		.cfi_offset 16, -4
 582 014e 1F93      		push r17
 583               	.LCFI33:
 584               		.cfi_def_cfa_offset 6
 585               		.cfi_offset 17, -5
 586 0150 2F93      		push r18
 587               	.LCFI34:
 588               		.cfi_def_cfa_offset 7
 589               		.cfi_offset 18, -6
 590 0152 3F93      		push r19
 591               	.LCFI35:
 592               		.cfi_def_cfa_offset 8
 593               		.cfi_offset 19, -7
 594 0154 4F93      		push r20
 595               	.LCFI36:
 596               		.cfi_def_cfa_offset 9
 597               		.cfi_offset 20, -8
 598 0156 5F93      		push r21
 599               	.LCFI37:
 600               		.cfi_def_cfa_offset 10
 601               		.cfi_offset 21, -9
 602 0158 6F93      		push r22
 603               	.LCFI38:
 604               		.cfi_def_cfa_offset 11
 605               		.cfi_offset 22, -10
 606 015a 7F93      		push r23
 607               	.LCFI39:
 608               		.cfi_def_cfa_offset 12
 609               		.cfi_offset 23, -11
 610 015c 8F93      		push r24
 611               	.LCFI40:
 612               		.cfi_def_cfa_offset 13
 613               		.cfi_offset 24, -12
 614 015e 9F93      		push r25
 615               	.LCFI41:
 616               		.cfi_def_cfa_offset 14
 617               		.cfi_offset 25, -13
 618 0160 AF93      		push r26
 619               	.LCFI42:
 620               		.cfi_def_cfa_offset 15
 621               		.cfi_offset 26, -14
 622 0162 BF93      		push r27
 623               	.LCFI43:
 624               		.cfi_def_cfa_offset 16
 625               		.cfi_offset 27, -15
 626 0164 CF93      		push r28
 627               	.LCFI44:
 628               		.cfi_def_cfa_offset 17
 629               		.cfi_offset 28, -16
 630 0166 EF93      		push r30
 631               	.LCFI45:
 632               		.cfi_def_cfa_offset 18
 633               		.cfi_offset 30, -17
 634 0168 FF93      		push r31
 635               	.LCFI46:
 636               		.cfi_def_cfa_offset 19
 637               		.cfi_offset 31, -18
 638               	/* prologue: Signal */
 639               	/* frame size = 0 */
 640               	/* stack size = 18 */
 641               	.L__stack_usage = 18
  96:main.c        ****     if(!Mcurrent){
 642               		.loc 1 96 0
 643 016a 8091 0000 		lds r24,Mcurrent
 644 016e 9091 0000 		lds r25,Mcurrent+1
 645 0172 892B      		or r24,r25
 646 0174 01F4      		brne .L29
 647               	.LBB31:
  97:main.c        ****         uint8_t m=getMode();
 648               		.loc 1 97 0
 649 0176 00D0      		rcall getMode
 650               	.LVL27:
 651 0178 C82F      		mov r28,r24
 652               	.LVL28:
  98:main.c        ****         RTC_readTime(&currentTime);
 653               		.loc 1 98 0
 654 017a 80E0      		ldi r24,lo8(currentTime)
 655 017c 90E0      		ldi r25,hi8(currentTime)
 656               	.LVL29:
 657 017e 00D0      		rcall RTC_readTime
 658               	.LVL30:
  99:main.c        ****         if(isInAllowedTime(currentTime.hour)){
 659               		.loc 1 99 0
 660 0180 8091 0000 		lds r24,currentTime
 661 0184 00D0      		rcall isInAllowedTime
 662               	.LVL31:
 663 0186 8823      		tst r24
 664 0188 01F0      		breq .L30
 100:main.c        ****             if(m<2){
 665               		.loc 1 100 0
 666 018a C230      		cpi r28,lo8(2)
 667 018c 00F4      		brsh .L31
 101:main.c        ****                 setLeds(currentTime,leds);
 668               		.loc 1 101 0
 669 018e 20E0      		ldi r18,lo8(leds)
 670 0190 30E0      		ldi r19,hi8(leds)
 671 0192 4091 0000 		lds r20,currentTime
 672 0196 5091 0000 		lds r21,currentTime+1
 673 019a 6091 0000 		lds r22,currentTime+2
 674 019e 7091 0000 		lds r23,currentTime+3
 675 01a2 8091 0000 		lds r24,currentTime+4
 676 01a6 00D0      		rcall setLeds
 677               	.LVL32:
 678 01a8 00C0      		rjmp .L30
 679               	.L31:
 102:main.c        ****             }else if(m<4){
 680               		.loc 1 102 0
 681 01aa C430      		cpi r28,lo8(4)
 682 01ac 00F4      		brsh .L30
 103:main.c        ****                 setLedsNb(RTC_readTemp(),leds);
 683               		.loc 1 103 0
 684 01ae 00D0      		rcall RTC_readTemp
 685               	.LVL33:
 686 01b0 60E0      		ldi r22,lo8(leds)
 687 01b2 70E0      		ldi r23,hi8(leds)
 688 01b4 00D0      		rcall setLedsNb
 689               	.LVL34:
 690               	.L30:
 104:main.c        ****             }
 105:main.c        ****         }
 106:main.c        ****         ledr=!ledr;
 691               		.loc 1 106 0
 692 01b6 81E0      		ldi r24,lo8(1)
 693 01b8 9091 0000 		lds r25,ledr
 694 01bc 9111      		cpse r25,__zero_reg__
 695 01be 80E0      		ldi r24,0
 696               	.L32:
 697 01c0 8093 0000 		sts ledr,r24
 698               	.LBE31:
 699 01c4 00C0      		rjmp .L28
 700               	.LVL35:
 701               	.L29:
 702 01c6 00E0      		ldi r16,lo8(leds)
 703 01c8 10E0      		ldi r17,hi8(leds)
  96:main.c        ****         uint8_t m=getMode();
 704               		.loc 1 96 0
 705 01ca C0E0      		ldi r28,0
 706               	.L36:
 707               	.LVL36:
 708               	.LBB32:
 107:main.c        ****     }else{
 108:main.c        ****         for(uint8_t i=0;i<NBLEDS;i++){
 109:main.c        ****             if(Mcurrent->sub[Mindex].led==i){
 709               		.loc 1 109 0
 710 01cc 2091 0000 		lds r18,Mcurrent
 711 01d0 3091 0000 		lds r19,Mcurrent+1
 712 01d4 8091 0000 		lds r24,Mindex
 713 01d8 90E0      		ldi r25,0
 714 01da 0196      		adiw r24,1
 715 01dc 63E0      		ldi r22,lo8(3)
 716 01de 70E0      		ldi r23,0
 717 01e0 00D0      		rcall __mulhi3
 718 01e2 820F      		add r24,r18
 719 01e4 931F      		adc r25,r19
 720 01e6 FC01      		movw r30,r24
 721 01e8 8081      		ld r24,Z
 722 01ea 8C13      		cpse r24,r28
 723 01ec 00C0      		rjmp .L34
 110:main.c        ****                 ledOn(&leds[i],WHITE);
 724               		.loc 1 110 0
 725 01ee 67E0      		ldi r22,lo8(7)
 726 01f0 C801      		movw r24,r16
 727 01f2 00D0      		rcall ledOn
 728               	.LVL37:
 729 01f4 00C0      		rjmp .L35
 730               	.L34:
 111:main.c        ****             }else{
 112:main.c        ****                 ledOff(&leds[i]);
 731               		.loc 1 112 0
 732 01f6 C801      		movw r24,r16
 733 01f8 00D0      		rcall ledOff
 734               	.LVL38:
 735               	.L35:
 108:main.c        ****             if(Mcurrent->sub[Mindex].led==i){
 736               		.loc 1 108 0 discriminator 2
 737 01fa CF5F      		subi r28,lo8(-(1))
 738               	.LVL39:
 739 01fc 0D5F      		subi r16,-3
 740 01fe 1F4F      		sbci r17,-1
 741 0200 C331      		cpi r28,lo8(19)
 742 0202 01F4      		brne .L36
 743               	.LVL40:
 744               	.L28:
 745               	/* epilogue start */
 746               	.LBE32:
 113:main.c        ****             }
 114:main.c        ****         }
 115:main.c        ****     }
 116:main.c        **** }
 747               		.loc 1 116 0
 748 0204 FF91      		pop r31
 749 0206 EF91      		pop r30
 750 0208 CF91      		pop r28
 751 020a BF91      		pop r27
 752 020c AF91      		pop r26
 753 020e 9F91      		pop r25
 754 0210 8F91      		pop r24
 755 0212 7F91      		pop r23
 756 0214 6F91      		pop r22
 757 0216 5F91      		pop r21
 758 0218 4F91      		pop r20
 759 021a 3F91      		pop r19
 760 021c 2F91      		pop r18
 761 021e 1F91      		pop r17
 762 0220 0F91      		pop r16
 763 0222 0F90      		pop r0
 764 0224 0FBE      		out __SREG__,r0
 765 0226 0F90      		pop r0
 766 0228 1F90      		pop r1
 767 022a 1895      		reti
 768               		.cfi_endproc
 769               	.LFE10:
 771               	.global	__vector_11
 773               	__vector_11:
 774               	.LFB11:
 117:main.c        **** ISR( TIM0_OVF_vect ){
 775               		.loc 1 117 0
 776               		.cfi_startproc
 777 022c 1F92      		push r1
 778               	.LCFI47:
 779               		.cfi_def_cfa_offset 3
 780               		.cfi_offset 1, -2
 781 022e 0F92      		push r0
 782               	.LCFI48:
 783               		.cfi_def_cfa_offset 4
 784               		.cfi_offset 0, -3
 785 0230 0FB6      		in r0,__SREG__
 786 0232 0F92      		push r0
 787 0234 1124      		clr __zero_reg__
 788 0236 2F93      		push r18
 789               	.LCFI49:
 790               		.cfi_def_cfa_offset 5
 791               		.cfi_offset 18, -4
 792 0238 3F93      		push r19
 793               	.LCFI50:
 794               		.cfi_def_cfa_offset 6
 795               		.cfi_offset 19, -5
 796 023a 4F93      		push r20
 797               	.LCFI51:
 798               		.cfi_def_cfa_offset 7
 799               		.cfi_offset 20, -6
 800 023c 5F93      		push r21
 801               	.LCFI52:
 802               		.cfi_def_cfa_offset 8
 803               		.cfi_offset 21, -7
 804 023e 6F93      		push r22
 805               	.LCFI53:
 806               		.cfi_def_cfa_offset 9
 807               		.cfi_offset 22, -8
 808 0240 7F93      		push r23
 809               	.LCFI54:
 810               		.cfi_def_cfa_offset 10
 811               		.cfi_offset 23, -9
 812 0242 8F93      		push r24
 813               	.LCFI55:
 814               		.cfi_def_cfa_offset 11
 815               		.cfi_offset 24, -10
 816 0244 9F93      		push r25
 817               	.LCFI56:
 818               		.cfi_def_cfa_offset 12
 819               		.cfi_offset 25, -11
 820 0246 AF93      		push r26
 821               	.LCFI57:
 822               		.cfi_def_cfa_offset 13
 823               		.cfi_offset 26, -12
 824 0248 BF93      		push r27
 825               	.LCFI58:
 826               		.cfi_def_cfa_offset 14
 827               		.cfi_offset 27, -13
 828 024a EF93      		push r30
 829               	.LCFI59:
 830               		.cfi_def_cfa_offset 15
 831               		.cfi_offset 30, -14
 832 024c FF93      		push r31
 833               	.LCFI60:
 834               		.cfi_def_cfa_offset 16
 835               		.cfi_offset 31, -15
 836               	/* prologue: Signal */
 837               	/* frame size = 0 */
 838               	/* stack size = 15 */
 839               	.L__stack_usage = 15
 118:main.c        ****     switch(state){
 840               		.loc 1 118 0
 841 024e 8091 0000 		lds r24,state
 842 0252 8230      		cpi r24,lo8(2)
 843 0254 01F0      		breq .L46
 844 0256 00F4      		brsh .L47
 845 0258 8823      		tst r24
 846 025a 01F0      		breq .L48
 847 025c 8130      		cpi r24,lo8(1)
 848 025e 01F4      		brne .L45
 119:main.c        ****         case 0:
 120:main.c        ****             sendData(R2 | getDataByColor(RED,0,leds));
 121:main.c        ****             break;
 122:main.c        ****         case 1:
 123:main.c        ****             sendData(R1 | getDataByColor(RED,1,leds));
 849               		.loc 1 123 0
 850 0260 40E0      		ldi r20,lo8(leds)
 851 0262 50E0      		ldi r21,hi8(leds)
 852 0264 61E0      		ldi r22,lo8(1)
 853 0266 84E0      		ldi r24,lo8(4)
 854 0268 00D0      		rcall getDataByColor
 855               	.LVL41:
 856 026a 7068      		ori r23,128
 857 026c 00C0      		rjmp .L54
 858               	.L47:
 118:main.c        ****     switch(state){
 859               		.loc 1 118 0
 860 026e 8430      		cpi r24,lo8(4)
 861 0270 01F0      		breq .L50
 862 0272 00F0      		brlo .L51
 863 0274 8530      		cpi r24,lo8(5)
 864 0276 01F4      		brne .L45
 124:main.c        ****             break;
 125:main.c        ****         case 2:
 126:main.c        ****             sendData(G2 | getDataByColor(GREEN,0,leds));
 127:main.c        ****             break;
 128:main.c        ****         case 3:
 129:main.c        ****             sendData(G1 | getDataByColor(GREEN,1,leds));
 130:main.c        ****             break;
 131:main.c        ****         case 4:
 132:main.c        ****             sendData(B2 | getDataByColor(BLUE,0,leds));
 133:main.c        ****             break;
 134:main.c        ****         case 5:
 135:main.c        ****             sendData(B1 | getDataByColor(BLUE,1,leds));
 865               		.loc 1 135 0
 866 0278 40E0      		ldi r20,lo8(leds)
 867 027a 50E0      		ldi r21,hi8(leds)
 868 027c 61E0      		ldi r22,lo8(1)
 869 027e 81E0      		ldi r24,lo8(1)
 870 0280 00D0      		rcall getDataByColor
 871               	.LVL42:
 872 0282 8260      		ori r24,2
 873 0284 00C0      		rjmp .L54
 874               	.L48:
 120:main.c        ****             break;
 875               		.loc 1 120 0
 876 0286 40E0      		ldi r20,lo8(leds)
 877 0288 50E0      		ldi r21,hi8(leds)
 878 028a 60E0      		ldi r22,0
 879 028c 84E0      		ldi r24,lo8(4)
 880 028e 00D0      		rcall getDataByColor
 881               	.LVL43:
 882 0290 7064      		ori r23,64
 883 0292 00C0      		rjmp .L54
 884               	.L46:
 126:main.c        ****             break;
 885               		.loc 1 126 0
 886 0294 40E0      		ldi r20,lo8(leds)
 887 0296 50E0      		ldi r21,hi8(leds)
 888 0298 60E0      		ldi r22,0
 889 029a 82E0      		ldi r24,lo8(2)
 890 029c 00D0      		rcall getDataByColor
 891               	.LVL44:
 892 029e 8460      		ori r24,4
 893 02a0 00C0      		rjmp .L54
 894               	.L51:
 129:main.c        ****             break;
 895               		.loc 1 129 0
 896 02a2 40E0      		ldi r20,lo8(leds)
 897 02a4 50E0      		ldi r21,hi8(leds)
 898 02a6 61E0      		ldi r22,lo8(1)
 899 02a8 82E0      		ldi r24,lo8(2)
 900 02aa 00D0      		rcall getDataByColor
 901               	.LVL45:
 902 02ac 8860      		ori r24,8
 903 02ae 00C0      		rjmp .L54
 904               	.L50:
 132:main.c        ****             break;
 905               		.loc 1 132 0
 906 02b0 40E0      		ldi r20,lo8(leds)
 907 02b2 50E0      		ldi r21,hi8(leds)
 908 02b4 60E0      		ldi r22,0
 909 02b6 81E0      		ldi r24,lo8(1)
 910 02b8 00D0      		rcall getDataByColor
 911               	.LVL46:
 912 02ba 8160      		ori r24,1
 913               	.L54:
 914               		.loc 1 135 0
 915 02bc 00D0      		rcall sendData
 916               	.LVL47:
 917               	.L45:
 136:main.c        ****             break;
 137:main.c        ****     }
 138:main.c        ****     state++;
 918               		.loc 1 138 0
 919 02be 8091 0000 		lds r24,state
 920 02c2 8F5F      		subi r24,lo8(-(1))
 921 02c4 8093 0000 		sts state,r24
 139:main.c        ****     if(state>5)state=0;
 922               		.loc 1 139 0
 923 02c8 8091 0000 		lds r24,state
 924 02cc 8630      		cpi r24,lo8(6)
 925 02ce 00F0      		brlo .L44
 926               		.loc 1 139 0 is_stmt 0 discriminator 1
 927 02d0 1092 0000 		sts state,__zero_reg__
 928               	.L44:
 929               	/* epilogue start */
 140:main.c        **** }
 930               		.loc 1 140 0 is_stmt 1
 931 02d4 FF91      		pop r31
 932 02d6 EF91      		pop r30
 933 02d8 BF91      		pop r27
 934 02da AF91      		pop r26
 935 02dc 9F91      		pop r25
 936 02de 8F91      		pop r24
 937 02e0 7F91      		pop r23
 938 02e2 6F91      		pop r22
 939 02e4 5F91      		pop r21
 940 02e6 4F91      		pop r20
 941 02e8 3F91      		pop r19
 942 02ea 2F91      		pop r18
 943 02ec 0F90      		pop r0
 944 02ee 0FBE      		out __SREG__,r0
 945 02f0 0F90      		pop r0
 946 02f2 1F90      		pop r1
 947 02f4 1895      		reti
 948               		.cfi_endproc
 949               	.LFE11:
 951               		.comm	leds,57,1
 952               	.global	Mindex
 953               		.section .bss
 956               	Mindex:
 957 0000 00        		.zero	1
 958               	.global	Mcurrent
 961               	Mcurrent:
 962 0001 0000      		.zero	2
 963               	.global	state
 966               	state:
 967 0003 00        		.zero	1
 968               	.global	ledb
 971               	ledb:
 972 0004 00        		.zero	1
 973               	.global	ledr
 976               	ledr:
 977 0005 00        		.zero	1
 978               		.comm	M1rainbow,3,1
 979               		.comm	M1reset,3,1
 980               		.comm	M1eventMode,3,1
 981               		.comm	M2setminpm,3,1
 982               		.comm	M2setminam,3,1
 983               		.comm	M2sethourpm,3,1
 984               		.comm	M2sethouram,3,1
 985               		.comm	M1setTime,3,1
 986               		.comm	M3onhour,3,1
 987               		.comm	M2offhour,3,1
 988               		.comm	M1nightmode,3,1
 989               		.comm	M1cmode,3,1
 990               		.comm	M1mode,3,1
 991               		.comm	M0main,3,1
 992               		.comm	USI_I2C_Master_State,1,1
 993               		.comm	currentTime,5,1
 994               		.text
 995               	.Letext0:
 996               		.file 3 "/usr/lib/avr/include/stdint.h"
 997               		.file 4 "RTC.h"
 998               		.file 5 "Led.h"
 999               		.file 6 "Menu.h"
 1000               		.file 7 "defines.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cc8pnnMy.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc8pnnMy.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc8pnnMy.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc8pnnMy.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc8pnnMy.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc8pnnMy.s:12     .text:0000000000000000 sendData
     /tmp/cc8pnnMy.s:976    .bss:0000000000000005 ledr
     /tmp/cc8pnnMy.s:971    .bss:0000000000000004 ledb
     /tmp/cc8pnnMy.s:45     .text.startup:0000000000000000 main
                            *COM*:0000000000000039 leds
                            *COM*:0000000000000005 currentTime
     /tmp/cc8pnnMy.s:277    .text:0000000000000012 __vector_3
     /tmp/cc8pnnMy.s:956    .bss:0000000000000000 Mindex
     /tmp/cc8pnnMy.s:961    .bss:0000000000000001 Mcurrent
     /tmp/cc8pnnMy.s:384    .text:0000000000000074 __vector_2
                            *COM*:0000000000000003 M0main
     /tmp/cc8pnnMy.s:563    .text:0000000000000142 __vector_8
     /tmp/cc8pnnMy.s:773    .text:000000000000022c __vector_11
     /tmp/cc8pnnMy.s:966    .bss:0000000000000003 state
                            *COM*:0000000000000003 M1rainbow
                            *COM*:0000000000000003 M1reset
                            *COM*:0000000000000003 M1eventMode
                            *COM*:0000000000000003 M2setminpm
                            *COM*:0000000000000003 M2setminam
                            *COM*:0000000000000003 M2sethourpm
                            *COM*:0000000000000003 M2sethouram
                            *COM*:0000000000000003 M1setTime
                            *COM*:0000000000000003 M3onhour
                            *COM*:0000000000000003 M2offhour
                            *COM*:0000000000000003 M1nightmode
                            *COM*:0000000000000003 M1cmode
                            *COM*:0000000000000003 M1mode
                            *COM*:0000000000000001 USI_I2C_Master_State

UNDEFINED SYMBOLS
sendRawData
ledInit
setCurrentTime
RTC_readTime
findNextEntry
__mulhi3
getSubMenu
ledOff
getMode
isInAllowedTime
setLeds
RTC_readTemp
setLedsNb
ledOn
getDataByColor
__do_clear_bss
