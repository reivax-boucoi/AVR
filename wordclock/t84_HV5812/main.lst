   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	sendRawData
  12               	sendRawData:
  13               	.LFB6:
  14               		.file 1 "main.c"
   1:main.c        **** #define F_CPU 16000000UL
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** #include <util/delay.h>
   5:main.c        **** #include "defines.h"
   6:main.c        **** #include "Led.h"
   7:main.c        **** #include "RTC.h"
   8:main.c        **** 
   9:main.c        **** void sendRawData(uint32_t data){
  15               		.loc 1 9 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26               	/* prologue: function */
  27               	/* frame size = 0 */
  28               	/* stack size = 2 */
  29               	.L__stack_usage = 2
  10:main.c        ****     PORTA &=~(STROBE|CLK);
  30               		.loc 1 10 0
  31 0004 2BB3      		in r18,0x1b
  32 0006 237F      		andi r18,lo8(-13)
  33 0008 2BBB      		out 0x1b,r18
  34               	.LVL1:
  35 000a 40E0      		ldi r20,0
  36 000c 50E0      		ldi r21,0
  37               	.LVL2:
  38               	.L4:
  39               	.LBB38:
  11:main.c        ****     for(uint8_t i=0;i<20;i++){
  12:main.c        ****         if((data>>i) & 0x00000001){
  40               		.loc 1 12 0
  41 000e 8B01      		movw r16,r22
  42 0010 9C01      		movw r18,r24
  43 0012 042E      		mov r0,r20
  44 0014 00C0      		rjmp 2f
  45               		1:
  46 0016 3695      		lsr r19
  47 0018 2795      		ror r18
  48 001a 1795      		ror r17
  49 001c 0795      		ror r16
  50               		2:
  51 001e 0A94      		dec r0
  52 0020 02F4      		brpl 1b
  53 0022 00FF      		sbrs r16,0
  54 0024 00C0      		rjmp .L2
  13:main.c        ****             PORTA|=DATA;
  55               		.loc 1 13 0
  56 0026 D99A      		sbi 0x1b,1
  57 0028 00C0      		rjmp .L3
  58               	.L2:
  14:main.c        ****         }else{
  15:main.c        ****             PORTA&=~DATA;
  59               		.loc 1 15 0
  60 002a D998      		cbi 0x1b,1
  61               	.L3:
  16:main.c        ****         }
  17:main.c        ****         PORTA|=CLK;
  62               		.loc 1 17 0 discriminator 2
  63 002c DB9A      		sbi 0x1b,3
  18:main.c        ****         PORTA&=~CLK;
  64               		.loc 1 18 0 discriminator 2
  65 002e DB98      		cbi 0x1b,3
  66               	.LVL3:
  67 0030 4F5F      		subi r20,-1
  68 0032 5F4F      		sbci r21,-1
  69               	.LVL4:
  11:main.c        ****         if((data>>i) & 0x00000001){
  70               		.loc 1 11 0 discriminator 2
  71 0034 4431      		cpi r20,20
  72 0036 5105      		cpc r21,__zero_reg__
  73 0038 01F4      		brne .L4
  74               	.LBE38:
  19:main.c        ****     }
  20:main.c        ****     PORTA|=STROBE;
  75               		.loc 1 20 0
  76 003a DA9A      		sbi 0x1b,2
  21:main.c        ****     PORTA&=~STROBE;
  77               		.loc 1 21 0
  78 003c DA98      		cbi 0x1b,2
  79               	/* epilogue start */
  22:main.c        **** }
  80               		.loc 1 22 0
  81 003e 1F91      		pop r17
  82 0040 0F91      		pop r16
  83 0042 0895      		ret
  84               		.cfi_endproc
  85               	.LFE6:
  87               	.global	sendData
  89               	sendData:
  90               	.LFB7:
  23:main.c        **** uint8_t ledr=0;
  24:main.c        **** uint8_t ledb=0;
  25:main.c        **** void sendData(uint32_t data){
  91               		.loc 1 25 0
  92               		.cfi_startproc
  93               	.LVL5:
  94               	/* prologue: function */
  95               	/* frame size = 0 */
  96               	/* stack size = 0 */
  97               	.L__stack_usage = 0
  98 0044 0895      		ret
  99               		.cfi_endproc
 100               	.LFE7:
 102               		.section	.text.startup,"ax",@progbits
 103               	.global	main
 105               	main:
 106               	.LFB8:
  26:main.c        ****     if(ledr)data|=LEDR;
  27:main.c        ****     if(ledb)data|=LEDB;
  28:main.c        **** }
  29:main.c        **** volatile uint8_t state=0;
  30:main.c        **** Led leds[NBLEDS];
  31:main.c        **** 
  32:main.c        **** int main(void){    
 107               		.loc 1 32 0
 108               		.cfi_startproc
 109               	/* prologue: function */
 110               	/* frame size = 0 */
 111               	/* stack size = 0 */
 112               	.L__stack_usage = 0
  33:main.c        ****     DDRA |= CLK|DATA|STROBE|LED;
 113               		.loc 1 33 0
 114 0000 8AB3      		in r24,0x1a
 115 0002 8F60      		ori r24,lo8(15)
 116 0004 8ABB      		out 0x1a,r24
  34:main.c        ****     PORTA &= ~(CLK|DATA|STROBE|LED);
 117               		.loc 1 34 0
 118 0006 8BB3      		in r24,0x1b
 119 0008 807F      		andi r24,lo8(-16)
 120 000a 8BBB      		out 0x1b,r24
  35:main.c        ****     ledInit(leds);
 121               		.loc 1 35 0
 122 000c 80E0      		ldi r24,lo8(leds)
 123 000e 90E0      		ldi r25,hi8(leds)
 124 0010 00D0      		rcall ledInit
 125               	.LVL6:
  36:main.c        ****     
  37:main.c        ****     TIMSK1|=(1<<TOIE1);
 126               		.loc 1 37 0
 127 0012 609A      		sbi 0xc,0
  38:main.c        ****     TIMSK0|=(1<<TOIE0);
 128               		.loc 1 38 0
 129 0014 89B7      		in r24,0x39
 130 0016 8160      		ori r24,lo8(1)
 131 0018 89BF      		out 0x39,r24
  39:main.c        ****     sei();
 132               		.loc 1 39 0
 133               	/* #APP */
 134               	 ;  39 "main.c" 1
 135 001a 7894      		sei
 136               	 ;  0 "" 2
 137               	.LVL7:
 138               	/* #NOAPP */
 139               	.LBB39:
 140               	.LBB40:
 141               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 142               		.loc 2 187 0
 143 001c 2FEF      		ldi r18,lo8(799999)
 144 001e 84E3      		ldi r24,hi8(799999)
 145 0020 9CE0      		ldi r25,hlo8(799999)
 146 0022 2150      	1:	subi r18,1
 147 0024 8040      		sbci r24,0
 148 0026 9040      		sbci r25,0
 149 0028 01F4      		brne 1b
 150 002a 00C0      		rjmp .
 151 002c 0000      		nop
 152               	.LVL8:
 153               	.LBE40:
 154               	.LBE39:
 155               	.LBB41:
 156               	.LBB42:
 157 002e 2FEF      		ldi r18,lo8(799999)
 158 0030 84E3      		ldi r24,hi8(799999)
 159 0032 9CE0      		ldi r25,hlo8(799999)
 160 0034 2150      	1:	subi r18,1
 161 0036 8040      		sbci r24,0
 162 0038 9040      		sbci r25,0
 163 003a 01F4      		brne 1b
 164 003c 00C0      		rjmp .
 165 003e 0000      		nop
 166               	.LVL9:
 167               	.LBE42:
 168               	.LBE41:
 169               	.LBB43:
 170               	.LBB44:
 171 0040 2FEF      		ldi r18,lo8(799999)
 172 0042 84E3      		ldi r24,hi8(799999)
 173 0044 9CE0      		ldi r25,hlo8(799999)
 174 0046 2150      	1:	subi r18,1
 175 0048 8040      		sbci r24,0
 176 004a 9040      		sbci r25,0
 177 004c 01F4      		brne 1b
 178 004e 00C0      		rjmp .
 179 0050 0000      		nop
 180               	.LVL10:
 181               	.LBE44:
 182               	.LBE43:
 183               	.LBB45:
 184               	.LBB46:
 185 0052 2FEF      		ldi r18,lo8(799999)
 186 0054 84E3      		ldi r24,hi8(799999)
 187 0056 9CE0      		ldi r25,hlo8(799999)
 188 0058 2150      	1:	subi r18,1
 189 005a 8040      		sbci r24,0
 190 005c 9040      		sbci r25,0
 191 005e 01F4      		brne 1b
 192 0060 00C0      		rjmp .
 193 0062 0000      		nop
 194               	.LVL11:
 195               	.LBE46:
 196               	.LBE45:
  40:main.c        ****     
  41:main.c        ****     sendData(0b11111100001111111111 | LEDB);
  42:main.c        ****     _delay_ms(250);
  43:main.c        ****     sendData(0b11000000001111111111);
  44:main.c        ****     _delay_ms(250);
  45:main.c        ****     sendData(0b00001100001111111111 | LEDR);
  46:main.c        ****     _delay_ms(250);
  47:main.c        ****     sendData(0b00110000001111111111);
  48:main.c        ****     _delay_ms(250);
  49:main.c        ****     #ifdef DELLONG
  50:main.c        **** 		TCCR1B|=(1<<CS12)|(1<<CS10);
  51:main.c        **** 	#else
  52:main.c        **** 		TCCR1B|=(1<<CS12);//|(1<<CS10);
 197               		.loc 1 52 0
 198 0064 8EB5      		in r24,0x2e
 199 0066 8460      		ori r24,lo8(4)
 200 0068 8EBD      		out 0x2e,r24
  53:main.c        **** 	#endif
  54:main.c        **** 	
  55:main.c        **** 	TCCR0B|=(1<<CS01)|(1<<CS00);
 201               		.loc 1 55 0
 202 006a 83B7      		in r24,0x33
 203 006c 8360      		ori r24,lo8(3)
 204 006e 83BF      		out 0x33,r24
  56:main.c        ****     
  57:main.c        ****     currentColor=tcolorV(RED);
 205               		.loc 1 57 0
 206 0070 60E0      		ldi r22,0
 207 0072 70E0      		ldi r23,0
 208 0074 8FEF      		ldi r24,lo8(-1)
 209 0076 90E0      		ldi r25,0
 210 0078 00D0      		rcall tcolorV
 211               	.LVL12:
 212 007a 6093 0000 		sts currentColor,r22
 213 007e 7093 0000 		sts currentColor+1,r23
 214 0082 8093 0000 		sts currentColor+2,r24
  58:main.c        ****     setCurrentTime(15,45,7,11);
 215               		.loc 1 58 0
 216 0086 2BE0      		ldi r18,lo8(11)
 217 0088 47E0      		ldi r20,lo8(7)
 218 008a 6DE2      		ldi r22,lo8(45)
 219 008c 8FE0      		ldi r24,lo8(15)
 220 008e 00D0      		rcall setCurrentTime
 221               	.LVL13:
  59:main.c        **** 	//RTC_readTime(&currentTime);
  60:main.c        ****     currentTime.temp=11;
 222               		.loc 1 60 0
 223 0090 8BE0      		ldi r24,lo8(11)
 224 0092 8093 0000 		sts currentTime+4,r24
 225               	.L9:
 226 0096 00C0      		rjmp .L9
 227               		.cfi_endproc
 228               	.LFE8:
 230               		.text
 231               	.global	__vector_8
 233               	__vector_8:
 234               	.LFB9:
  61:main.c        ****     //setLeds(currentTime,leds,currentColor);
  62:main.c        ****     
  63:main.c        ****     while(1){
  64:main.c        ****        
  65:main.c        ****     }
  66:main.c        ****     return(0);
  67:main.c        ****     
  68:main.c        **** }
  69:main.c        **** ISR( TIM1_OVF_vect ){
 235               		.loc 1 69 0
 236               		.cfi_startproc
 237 0046 1F92      		push r1
 238               	.LCFI2:
 239               		.cfi_def_cfa_offset 3
 240               		.cfi_offset 1, -2
 241 0048 0F92      		push r0
 242               	.LCFI3:
 243               		.cfi_def_cfa_offset 4
 244               		.cfi_offset 0, -3
 245 004a 0FB6      		in r0,__SREG__
 246 004c 0F92      		push r0
 247 004e 1124      		clr __zero_reg__
 248 0050 EF92      		push r14
 249               	.LCFI4:
 250               		.cfi_def_cfa_offset 5
 251               		.cfi_offset 14, -4
 252 0052 FF92      		push r15
 253               	.LCFI5:
 254               		.cfi_def_cfa_offset 6
 255               		.cfi_offset 15, -5
 256 0054 0F93      		push r16
 257               	.LCFI6:
 258               		.cfi_def_cfa_offset 7
 259               		.cfi_offset 16, -6
 260 0056 2F93      		push r18
 261               	.LCFI7:
 262               		.cfi_def_cfa_offset 8
 263               		.cfi_offset 18, -7
 264 0058 3F93      		push r19
 265               	.LCFI8:
 266               		.cfi_def_cfa_offset 9
 267               		.cfi_offset 19, -8
 268 005a 4F93      		push r20
 269               	.LCFI9:
 270               		.cfi_def_cfa_offset 10
 271               		.cfi_offset 20, -9
 272 005c 5F93      		push r21
 273               	.LCFI10:
 274               		.cfi_def_cfa_offset 11
 275               		.cfi_offset 21, -10
 276 005e 6F93      		push r22
 277               	.LCFI11:
 278               		.cfi_def_cfa_offset 12
 279               		.cfi_offset 22, -11
 280 0060 7F93      		push r23
 281               	.LCFI12:
 282               		.cfi_def_cfa_offset 13
 283               		.cfi_offset 23, -12
 284 0062 8F93      		push r24
 285               	.LCFI13:
 286               		.cfi_def_cfa_offset 14
 287               		.cfi_offset 24, -13
 288 0064 9F93      		push r25
 289               	.LCFI14:
 290               		.cfi_def_cfa_offset 15
 291               		.cfi_offset 25, -14
 292 0066 AF93      		push r26
 293               	.LCFI15:
 294               		.cfi_def_cfa_offset 16
 295               		.cfi_offset 26, -15
 296 0068 BF93      		push r27
 297               	.LCFI16:
 298               		.cfi_def_cfa_offset 17
 299               		.cfi_offset 27, -16
 300 006a EF93      		push r30
 301               	.LCFI17:
 302               		.cfi_def_cfa_offset 18
 303               		.cfi_offset 30, -17
 304 006c FF93      		push r31
 305               	.LCFI18:
 306               		.cfi_def_cfa_offset 19
 307               		.cfi_offset 31, -18
 308               	/* prologue: Signal */
 309               	/* frame size = 0 */
 310               	/* stack size = 18 */
 311               	.L__stack_usage = 18
  70:main.c        ****     ledb=1-ledb;
 312               		.loc 1 70 0
 313 006e 9091 0000 		lds r25,ledb
 314 0072 81E0      		ldi r24,lo8(1)
 315 0074 891B      		sub r24,r25
 316 0076 8093 0000 		sts ledb,r24
  71:main.c        ****     //RTC_readTime(&currentTime);
  72:main.c        ****     setLeds(currentTime,leds,currentColor);
 317               		.loc 1 72 0
 318 007a E090 0000 		lds r14,currentColor
 319 007e F090 0000 		lds r15,currentColor+1
 320 0082 0091 0000 		lds r16,currentColor+2
 321 0086 20E0      		ldi r18,lo8(leds)
 322 0088 30E0      		ldi r19,hi8(leds)
 323 008a 4091 0000 		lds r20,currentTime
 324 008e 5091 0000 		lds r21,currentTime+1
 325 0092 6091 0000 		lds r22,currentTime+2
 326 0096 7091 0000 		lds r23,currentTime+3
 327 009a 8091 0000 		lds r24,currentTime+4
 328 009e 00D0      		rcall setLeds
 329               	.LVL14:
 330               	/* epilogue start */
  73:main.c        **** }
 331               		.loc 1 73 0
 332 00a0 FF91      		pop r31
 333 00a2 EF91      		pop r30
 334 00a4 BF91      		pop r27
 335 00a6 AF91      		pop r26
 336 00a8 9F91      		pop r25
 337 00aa 8F91      		pop r24
 338 00ac 7F91      		pop r23
 339 00ae 6F91      		pop r22
 340 00b0 5F91      		pop r21
 341 00b2 4F91      		pop r20
 342 00b4 3F91      		pop r19
 343 00b6 2F91      		pop r18
 344 00b8 0F91      		pop r16
 345 00ba FF90      		pop r15
 346 00bc EF90      		pop r14
 347 00be 0F90      		pop r0
 348 00c0 0FBE      		out __SREG__,r0
 349 00c2 0F90      		pop r0
 350 00c4 1F90      		pop r1
 351 00c6 1895      		reti
 352               		.cfi_endproc
 353               	.LFE9:
 355               	.global	__vector_11
 357               	__vector_11:
 358               	.LFB10:
  74:main.c        **** ISR( TIM0_OVF_vect ){
 359               		.loc 1 74 0
 360               		.cfi_startproc
 361 00c8 1F92      		push r1
 362               	.LCFI19:
 363               		.cfi_def_cfa_offset 3
 364               		.cfi_offset 1, -2
 365 00ca 0F92      		push r0
 366               	.LCFI20:
 367               		.cfi_def_cfa_offset 4
 368               		.cfi_offset 0, -3
 369 00cc 0FB6      		in r0,__SREG__
 370 00ce 0F92      		push r0
 371 00d0 1124      		clr __zero_reg__
 372 00d2 2F93      		push r18
 373               	.LCFI21:
 374               		.cfi_def_cfa_offset 5
 375               		.cfi_offset 18, -4
 376 00d4 3F93      		push r19
 377               	.LCFI22:
 378               		.cfi_def_cfa_offset 6
 379               		.cfi_offset 19, -5
 380 00d6 4F93      		push r20
 381               	.LCFI23:
 382               		.cfi_def_cfa_offset 7
 383               		.cfi_offset 20, -6
 384 00d8 5F93      		push r21
 385               	.LCFI24:
 386               		.cfi_def_cfa_offset 8
 387               		.cfi_offset 21, -7
 388 00da 6F93      		push r22
 389               	.LCFI25:
 390               		.cfi_def_cfa_offset 9
 391               		.cfi_offset 22, -8
 392 00dc 7F93      		push r23
 393               	.LCFI26:
 394               		.cfi_def_cfa_offset 10
 395               		.cfi_offset 23, -9
 396 00de 8F93      		push r24
 397               	.LCFI27:
 398               		.cfi_def_cfa_offset 11
 399               		.cfi_offset 24, -10
 400 00e0 9F93      		push r25
 401               	.LCFI28:
 402               		.cfi_def_cfa_offset 12
 403               		.cfi_offset 25, -11
 404 00e2 AF93      		push r26
 405               	.LCFI29:
 406               		.cfi_def_cfa_offset 13
 407               		.cfi_offset 26, -12
 408 00e4 BF93      		push r27
 409               	.LCFI30:
 410               		.cfi_def_cfa_offset 14
 411               		.cfi_offset 27, -13
 412 00e6 EF93      		push r30
 413               	.LCFI31:
 414               		.cfi_def_cfa_offset 15
 415               		.cfi_offset 30, -14
 416 00e8 FF93      		push r31
 417               	.LCFI32:
 418               		.cfi_def_cfa_offset 16
 419               		.cfi_offset 31, -15
 420               	/* prologue: Signal */
 421               	/* frame size = 0 */
 422               	/* stack size = 15 */
 423               	.L__stack_usage = 15
  75:main.c        ****     switch(state){
 424               		.loc 1 75 0
 425 00ea 8091 0000 		lds r24,state
 426 00ee 8230      		cpi r24,lo8(2)
 427 00f0 01F0      		breq .L13
 428 00f2 00F4      		brsh .L14
 429 00f4 8823      		tst r24
 430 00f6 01F0      		breq .L15
 431 00f8 8130      		cpi r24,lo8(1)
 432 00fa 01F4      		brne .L12
  76:main.c        ****         case 0:
  77:main.c        ****             sendData(R2 | getDataByColor(tcolor(1,0,0),0,leds));
  78:main.c        ****             break;
  79:main.c        ****         case 1:
  80:main.c        ****             sendData(R1 | getDataByColor(tcolor(1,0,0),1,leds));
 433               		.loc 1 80 0
 434 00fc 40E0      		ldi r20,0
 435 00fe 60E0      		ldi r22,0
 436 0100 81E0      		ldi r24,lo8(1)
 437 0102 00C0      		rjmp .L22
 438               	.L14:
  75:main.c        ****     switch(state){
 439               		.loc 1 75 0
 440 0104 8430      		cpi r24,lo8(4)
 441 0106 01F0      		breq .L17
 442 0108 00F0      		brlo .L18
 443 010a 8530      		cpi r24,lo8(5)
 444 010c 01F4      		brne .L12
  81:main.c        ****             break;
  82:main.c        ****         case 2:
  83:main.c        ****             sendData(G2 | getDataByColor(tcolor(0,1,0),0,leds));
  84:main.c        ****             break;
  85:main.c        ****         case 3:
  86:main.c        ****             sendData(G1 | getDataByColor(tcolor(0,1,0),1,leds));
  87:main.c        ****             break;
  88:main.c        ****         case 4:
  89:main.c        ****             sendData(B2 | getDataByColor(tcolor(0,0,1),0,leds));
  90:main.c        ****             break;
  91:main.c        ****         case 5:
  92:main.c        ****             sendData(B1 | getDataByColor(tcolor(0,0,1),1,leds));
 445               		.loc 1 92 0
 446 010e 41E0      		ldi r20,lo8(1)
 447 0110 60E0      		ldi r22,0
 448 0112 00C0      		rjmp .L23
 449               	.L15:
  77:main.c        ****             break;
 450               		.loc 1 77 0
 451 0114 40E0      		ldi r20,0
 452 0116 60E0      		ldi r22,0
 453 0118 81E0      		ldi r24,lo8(1)
 454 011a 00C0      		rjmp .L24
 455               	.L13:
  83:main.c        ****             break;
 456               		.loc 1 83 0
 457 011c 40E0      		ldi r20,0
 458 011e 61E0      		ldi r22,lo8(1)
 459 0120 00C0      		rjmp .L25
 460               	.L18:
  86:main.c        ****             break;
 461               		.loc 1 86 0
 462 0122 40E0      		ldi r20,0
 463 0124 61E0      		ldi r22,lo8(1)
 464 0126 00C0      		rjmp .L23
 465               	.L17:
  89:main.c        ****             break;
 466               		.loc 1 89 0
 467 0128 41E0      		ldi r20,lo8(1)
 468 012a 60E0      		ldi r22,0
 469               	.L25:
 470 012c 80E0      		ldi r24,0
 471               	.L24:
 472 012e 00D0      		rcall tcolor
 473               	.LVL15:
 474 0130 20E0      		ldi r18,lo8(leds)
 475 0132 30E0      		ldi r19,hi8(leds)
 476 0134 40E0      		ldi r20,0
 477 0136 00C0      		rjmp .L21
 478               	.L23:
 479               		.loc 1 92 0
 480 0138 80E0      		ldi r24,0
 481               	.L22:
 482 013a 00D0      		rcall tcolor
 483               	.LVL16:
 484 013c 20E0      		ldi r18,lo8(leds)
 485 013e 30E0      		ldi r19,hi8(leds)
 486 0140 41E0      		ldi r20,lo8(1)
 487               	.L21:
 488 0142 00D0      		rcall getDataByColor
 489               	.LVL17:
 490               	.L12:
  93:main.c        ****             break;
  94:main.c        ****     }
  95:main.c        ****     state++;
 491               		.loc 1 95 0
 492 0144 8091 0000 		lds r24,state
 493 0148 8F5F      		subi r24,lo8(-(1))
 494 014a 8093 0000 		sts state,r24
  96:main.c        ****     if(state>5)state=0;
 495               		.loc 1 96 0
 496 014e 8091 0000 		lds r24,state
 497 0152 8630      		cpi r24,lo8(6)
 498 0154 00F0      		brlo .L11
 499               		.loc 1 96 0 is_stmt 0 discriminator 1
 500 0156 1092 0000 		sts state,__zero_reg__
 501               	.L11:
 502               	/* epilogue start */
  97:main.c        **** }
 503               		.loc 1 97 0 is_stmt 1
 504 015a FF91      		pop r31
 505 015c EF91      		pop r30
 506 015e BF91      		pop r27
 507 0160 AF91      		pop r26
 508 0162 9F91      		pop r25
 509 0164 8F91      		pop r24
 510 0166 7F91      		pop r23
 511 0168 6F91      		pop r22
 512 016a 5F91      		pop r21
 513 016c 4F91      		pop r20
 514 016e 3F91      		pop r19
 515 0170 2F91      		pop r18
 516 0172 0F90      		pop r0
 517 0174 0FBE      		out __SREG__,r0
 518 0176 0F90      		pop r0
 519 0178 1F90      		pop r1
 520 017a 1895      		reti
 521               		.cfi_endproc
 522               	.LFE10:
 524               		.comm	leds,95,1
 525               	.global	state
 526               		.section .bss
 529               	state:
 530 0000 00        		.zero	1
 531               	.global	ledb
 534               	ledb:
 535 0001 00        		.zero	1
 536               	.global	ledr
 539               	ledr:
 540 0002 00        		.zero	1
 541               		.comm	currentColor,3,1
 542               		.comm	USI_I2C_Master_State,1,1
 543               		.comm	currentTime,5,1
 544               		.text
 545               	.Letext0:
 546               		.file 3 "/usr/lib/avr/include/stdint.h"
 547               		.file 4 "RTC.h"
 548               		.file 5 "Led.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cccYcVSX.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cccYcVSX.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cccYcVSX.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cccYcVSX.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cccYcVSX.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cccYcVSX.s:12     .text:0000000000000000 sendRawData
     /tmp/cccYcVSX.s:89     .text:0000000000000044 sendData
     /tmp/cccYcVSX.s:105    .text.startup:0000000000000000 main
                            *COM*:000000000000005f leds
                            *COM*:0000000000000003 currentColor
                            *COM*:0000000000000005 currentTime
     /tmp/cccYcVSX.s:233    .text:0000000000000046 __vector_8
     /tmp/cccYcVSX.s:534    .bss:0000000000000001 ledb
     /tmp/cccYcVSX.s:357    .text:00000000000000c8 __vector_11
     /tmp/cccYcVSX.s:529    .bss:0000000000000000 state
     /tmp/cccYcVSX.s:539    .bss:0000000000000002 ledr
                            *COM*:0000000000000001 USI_I2C_Master_State

UNDEFINED SYMBOLS
ledInit
tcolorV
setCurrentTime
setLeds
tcolor
getDataByColor
__do_clear_bss
