   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	sendData
  12               	sendData:
  13               	.LFB6:
  14               		.file 1 "main.c"
   1:main.c        **** #define F_CPU 16000000UL
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** #include <util/delay.h>
   5:main.c        **** #include "defines.h"
   6:main.c        **** #include "Led.h"
   7:main.c        **** #include "RTC.h"
   8:main.c        **** #include "Menu.h"
   9:main.c        **** 
  10:main.c        **** uint8_t ledr=0;
  11:main.c        **** uint8_t ledb=0;
  12:main.c        **** void sendData(uint32_t data){
  15               		.loc 1 12 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  13:main.c        ****     if(ledr)data|=LEDR;
  22               		.loc 1 13 0
  23 0000 2091 0000 		lds r18,ledr
  24 0004 2111      		cpse r18,__zero_reg__
  25               		.loc 1 13 0 is_stmt 0 discriminator 1
  26 0006 7860      		ori r23,8
  27               	.LVL1:
  28               	.L2:
  14:main.c        ****     if(ledb)data|=LEDB;
  29               		.loc 1 14 0 is_stmt 1
  30 0008 2091 0000 		lds r18,ledb
  31 000c 2111      		cpse r18,__zero_reg__
  32               		.loc 1 14 0 is_stmt 0 discriminator 1
  33 000e 7460      		ori r23,4
  34               	.LVL2:
  35               	.L3:
  15:main.c        ****     sendRawData(data);
  36               		.loc 1 15 0 is_stmt 1
  37 0010 00C0      		rjmp sendRawData
  38               	.LVL3:
  39               		.cfi_endproc
  40               	.LFE6:
  42               		.section	.text.startup,"ax",@progbits
  43               	.global	main
  45               	main:
  46               	.LFB7:
  16:main.c        **** }
  17:main.c        **** 
  18:main.c        **** 
  19:main.c        **** volatile uint8_t state=0;
  20:main.c        **** volatile struct Menu* Mcurrent=0;
  21:main.c        **** volatile uint8_t Mindex=0;
  22:main.c        **** Led leds[NBLEDS];
  23:main.c        **** 
  24:main.c        **** int main(void){    
  47               		.loc 1 24 0
  48               		.cfi_startproc
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
  25:main.c        ****     ledInit(leds);
  53               		.loc 1 25 0
  54 0000 80E0      		ldi r24,lo8(leds)
  55 0002 90E0      		ldi r25,hi8(leds)
  56 0004 00D0      		rcall ledInit
  57               	.LVL4:
  26:main.c        ****     DDRA&=~(BTNINTERNAL|BTNOK);
  58               		.loc 1 26 0
  59 0006 8AB3      		in r24,0x1a
  60 0008 8F75      		andi r24,lo8(95)
  61 000a 8ABB      		out 0x1a,r24
  27:main.c        ****     DDRB&=~BTNSELECT;
  62               		.loc 1 27 0
  63 000c BA98      		cbi 0x17,2
  28:main.c        ****     PORTA|=(BTNINTERNAL|BTNOK);
  64               		.loc 1 28 0
  65 000e 8BB3      		in r24,0x1b
  66 0010 806A      		ori r24,lo8(-96)
  67 0012 8BBB      		out 0x1b,r24
  29:main.c        ****     PORTB|=BTNSELECT;
  68               		.loc 1 29 0
  69 0014 C29A      		sbi 0x18,2
  30:main.c        ****     TIMSK1|=(1<<TOIE1);
  70               		.loc 1 30 0
  71 0016 609A      		sbi 0xc,0
  31:main.c        ****     TIMSK0|=(1<<TOIE0);
  72               		.loc 1 31 0
  73 0018 89B7      		in r24,0x39
  74 001a 8160      		ori r24,lo8(1)
  75 001c 89BF      		out 0x39,r24
  32:main.c        ****     GIMSK|=(1<<PCIE1)|(1<<PCIE0);
  76               		.loc 1 32 0
  77 001e 8BB7      		in r24,0x3b
  78 0020 8063      		ori r24,lo8(48)
  79 0022 8BBF      		out 0x3b,r24
  33:main.c        ****     PCMSK0|=(1<<PCINT7)|(1<<PCINT5);
  80               		.loc 1 33 0
  81 0024 82B3      		in r24,0x12
  82 0026 806A      		ori r24,lo8(-96)
  83 0028 82BB      		out 0x12,r24
  34:main.c        ****     PCMSK1|=(1<<PCINT10);
  84               		.loc 1 34 0
  85 002a 80B5      		in r24,0x20
  86 002c 8460      		ori r24,lo8(4)
  87 002e 80BD      		out 0x20,r24
  35:main.c        ****     sei();
  88               		.loc 1 35 0
  89               	/* #APP */
  90               	 ;  35 "main.c" 1
  91 0030 7894      		sei
  92               	 ;  0 "" 2
  36:main.c        ****     
  37:main.c        ****     sendData(0b11111100001111111111);//white
  93               		.loc 1 37 0
  94               	/* #NOAPP */
  95 0032 6FEF      		ldi r22,lo8(-1)
  96 0034 73EC      		ldi r23,lo8(-61)
  97 0036 8FE0      		ldi r24,lo8(15)
  98 0038 90E0      		ldi r25,0
  99 003a 00D0      		rcall sendData
 100               	.LVL5:
 101               	.LBB16:
 102               	.LBB17:
 103               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 104               		.loc 2 187 0
 105 003c 2FEF      		ldi r18,lo8(1599999)
 106 003e 89E6      		ldi r24,hi8(1599999)
 107 0040 98E1      		ldi r25,hlo8(1599999)
 108 0042 2150      	1:	subi r18,1
 109 0044 8040      		sbci r24,0
 110 0046 9040      		sbci r25,0
 111 0048 01F4      		brne 1b
 112 004a 00C0      		rjmp .
 113 004c 0000      		nop
 114               	.LVL6:
 115               	.LBE17:
 116               	.LBE16:
  38:main.c        ****     _delay_ms(500);
  39:main.c        ****     sendData(0b11000000001111111111);//green
 117               		.loc 1 39 0
 118 004e 6FEF      		ldi r22,lo8(-1)
 119 0050 73E0      		ldi r23,lo8(3)
 120 0052 8CE0      		ldi r24,lo8(12)
 121 0054 90E0      		ldi r25,0
 122 0056 00D0      		rcall sendData
 123               	.LVL7:
 124               	.LBB18:
 125               	.LBB19:
 126               		.loc 2 187 0
 127 0058 2FEF      		ldi r18,lo8(1599999)
 128 005a 89E6      		ldi r24,hi8(1599999)
 129 005c 98E1      		ldi r25,hlo8(1599999)
 130 005e 2150      	1:	subi r18,1
 131 0060 8040      		sbci r24,0
 132 0062 9040      		sbci r25,0
 133 0064 01F4      		brne 1b
 134 0066 00C0      		rjmp .
 135 0068 0000      		nop
 136               	.LVL8:
 137               	.LBE19:
 138               	.LBE18:
  40:main.c        ****     _delay_ms(500);
  41:main.c        ****     sendData(0b00001100001111111111);//red
 139               		.loc 1 41 0
 140 006a 6FEF      		ldi r22,lo8(-1)
 141 006c 73EC      		ldi r23,lo8(-61)
 142 006e 80E0      		ldi r24,0
 143 0070 90E0      		ldi r25,0
 144 0072 00D0      		rcall sendData
 145               	.LVL9:
 146               	.LBB20:
 147               	.LBB21:
 148               		.loc 2 187 0
 149 0074 2FEF      		ldi r18,lo8(1599999)
 150 0076 89E6      		ldi r24,hi8(1599999)
 151 0078 98E1      		ldi r25,hlo8(1599999)
 152 007a 2150      	1:	subi r18,1
 153 007c 8040      		sbci r24,0
 154 007e 9040      		sbci r25,0
 155 0080 01F4      		brne 1b
 156 0082 00C0      		rjmp .
 157 0084 0000      		nop
 158               	.LVL10:
 159               	.LBE21:
 160               	.LBE20:
  42:main.c        ****     _delay_ms(500);
  43:main.c        ****     sendData(0b00110000001111111111);//blue
 161               		.loc 1 43 0
 162 0086 6FEF      		ldi r22,lo8(-1)
 163 0088 73E0      		ldi r23,lo8(3)
 164 008a 83E0      		ldi r24,lo8(3)
 165 008c 90E0      		ldi r25,0
 166 008e 00D0      		rcall sendData
 167               	.LVL11:
 168               	.LBB22:
 169               	.LBB23:
 170               		.loc 2 187 0
 171 0090 2FEF      		ldi r18,lo8(1599999)
 172 0092 89E6      		ldi r24,hi8(1599999)
 173 0094 98E1      		ldi r25,hlo8(1599999)
 174 0096 2150      	1:	subi r18,1
 175 0098 8040      		sbci r24,0
 176 009a 9040      		sbci r25,0
 177 009c 01F4      		brne 1b
 178 009e 00C0      		rjmp .
 179 00a0 0000      		nop
 180               	.LVL12:
 181               	.LBE23:
 182               	.LBE22:
  44:main.c        ****     _delay_ms(500);
  45:main.c        ****     sendData(0b11110000001111111111);//cyan
 183               		.loc 1 45 0
 184 00a2 6FEF      		ldi r22,lo8(-1)
 185 00a4 73E0      		ldi r23,lo8(3)
 186 00a6 8FE0      		ldi r24,lo8(15)
 187 00a8 90E0      		ldi r25,0
 188 00aa 00D0      		rcall sendData
 189               	.LVL13:
 190               	.LBB24:
 191               	.LBB25:
 192               		.loc 2 187 0
 193 00ac 2FEF      		ldi r18,lo8(1599999)
 194 00ae 89E6      		ldi r24,hi8(1599999)
 195 00b0 98E1      		ldi r25,hlo8(1599999)
 196 00b2 2150      	1:	subi r18,1
 197 00b4 8040      		sbci r24,0
 198 00b6 9040      		sbci r25,0
 199 00b8 01F4      		brne 1b
 200 00ba 00C0      		rjmp .
 201 00bc 0000      		nop
 202               	.LVL14:
 203               	.LBE25:
 204               	.LBE24:
  46:main.c        ****     _delay_ms(500);
  47:main.c        ****     sendData(0b00111100001111111111);//magenta
 205               		.loc 1 47 0
 206 00be 6FEF      		ldi r22,lo8(-1)
 207 00c0 73EC      		ldi r23,lo8(-61)
 208 00c2 83E0      		ldi r24,lo8(3)
 209 00c4 90E0      		ldi r25,0
 210 00c6 00D0      		rcall sendData
 211               	.LVL15:
 212               	.LBB26:
 213               	.LBB27:
 214               		.loc 2 187 0
 215 00c8 2FEF      		ldi r18,lo8(1599999)
 216 00ca 89E6      		ldi r24,hi8(1599999)
 217 00cc 98E1      		ldi r25,hlo8(1599999)
 218 00ce 2150      	1:	subi r18,1
 219 00d0 8040      		sbci r24,0
 220 00d2 9040      		sbci r25,0
 221 00d4 01F4      		brne 1b
 222 00d6 00C0      		rjmp .
 223 00d8 0000      		nop
 224               	.LVL16:
 225               	.LBE27:
 226               	.LBE26:
  48:main.c        ****     _delay_ms(500);
  49:main.c        ****     sendData(0b11001100001111111111);//yellow
 227               		.loc 1 49 0
 228 00da 6FEF      		ldi r22,lo8(-1)
 229 00dc 73EC      		ldi r23,lo8(-61)
 230 00de 8CE0      		ldi r24,lo8(12)
 231 00e0 90E0      		ldi r25,0
 232 00e2 00D0      		rcall sendData
 233               	.LVL17:
 234               	.LBB28:
 235               	.LBB29:
 236               		.loc 2 187 0
 237 00e4 2FEF      		ldi r18,lo8(1599999)
 238 00e6 89E6      		ldi r24,hi8(1599999)
 239 00e8 98E1      		ldi r25,hlo8(1599999)
 240 00ea 2150      	1:	subi r18,1
 241 00ec 8040      		sbci r24,0
 242 00ee 9040      		sbci r25,0
 243 00f0 01F4      		brne 1b
 244 00f2 00C0      		rjmp .
 245 00f4 0000      		nop
 246               	.LVL18:
 247               	.LBE29:
 248               	.LBE28:
  50:main.c        ****     _delay_ms(500);
  51:main.c        ****     
  52:main.c        ****     #ifdef DELLONG
  53:main.c        ****     TCCR1B|=(1<<CS12)|(1<<CS10);
  54:main.c        ****     #else
  55:main.c        ****     TCCR1B|=(1<<CS12);//|(1<<CS10);
 249               		.loc 1 55 0
 250 00f6 8EB5      		in r24,0x2e
 251 00f8 8460      		ori r24,lo8(4)
 252 00fa 8EBD      		out 0x2e,r24
  56:main.c        ****     #endif
  57:main.c        ****     
  58:main.c        ****     TCCR0B|=(1<<CS01)|(1<<CS00);
 253               		.loc 1 58 0
 254 00fc 83B7      		in r24,0x33
 255 00fe 8360      		ori r24,lo8(3)
 256 0100 83BF      		out 0x33,r24
  59:main.c        ****     
  60:main.c        ****     currentColor=tcolorV(WHITE);
 257               		.loc 1 60 0
 258 0102 6FEF      		ldi r22,lo8(-1)
 259 0104 7FEF      		ldi r23,lo8(-1)
 260 0106 8FEF      		ldi r24,lo8(-1)
 261 0108 90E0      		ldi r25,0
 262 010a 00D0      		rcall tcolorV
 263               	.LVL19:
 264 010c 6093 0000 		sts currentColor,r22
 265 0110 7093 0000 		sts currentColor+1,r23
 266 0114 8093 0000 		sts currentColor+2,r24
  61:main.c        ****     setCurrentTime(0,10,7,12);
 267               		.loc 1 61 0
 268 0118 2CE0      		ldi r18,lo8(12)
 269 011a 47E0      		ldi r20,lo8(7)
 270 011c 6AE0      		ldi r22,lo8(10)
 271 011e 80E0      		ldi r24,0
 272 0120 00D0      		rcall setCurrentTime
 273               	.LVL20:
  62:main.c        ****    // //RTC_setTime(currentTime,6,18);
  63:main.c        ****     RTC_readTime(&currentTime);
 274               		.loc 1 63 0
 275 0122 80E0      		ldi r24,lo8(currentTime)
 276 0124 90E0      		ldi r25,hi8(currentTime)
 277 0126 00D0      		rcall RTC_readTime
 278               	.LVL21:
  64:main.c        ****     setLeds(currentTime,leds,currentColor);
 279               		.loc 1 64 0
 280 0128 E090 0000 		lds r14,currentColor
 281 012c F090 0000 		lds r15,currentColor+1
 282 0130 0091 0000 		lds r16,currentColor+2
 283 0134 20E0      		ldi r18,lo8(leds)
 284 0136 30E0      		ldi r19,hi8(leds)
 285 0138 4091 0000 		lds r20,currentTime
 286 013c 5091 0000 		lds r21,currentTime+1
 287 0140 6091 0000 		lds r22,currentTime+2
 288 0144 7091 0000 		lds r23,currentTime+3
 289 0148 8091 0000 		lds r24,currentTime+4
 290 014c 00D0      		rcall setLeds
 291               	.LVL22:
 292               	.L12:
 293 014e 00C0      		rjmp .L12
 294               		.cfi_endproc
 295               	.LFE7:
 297               		.text
 298               	.global	__vector_3
 300               	__vector_3:
 301               	.LFB8:
  65:main.c        ****     //setLedsNb(currentTime.temp,leds,currentColor);
  66:main.c        ****     while(1){
  67:main.c        ****     }
  68:main.c        ****     return(0);
  69:main.c        ****     
  70:main.c        **** }
  71:main.c        **** ISR( PCINT1_vect){
 302               		.loc 1 71 0
 303               		.cfi_startproc
 304 0012 1F92      		push r1
 305               	.LCFI0:
 306               		.cfi_def_cfa_offset 3
 307               		.cfi_offset 1, -2
 308 0014 0F92      		push r0
 309               	.LCFI1:
 310               		.cfi_def_cfa_offset 4
 311               		.cfi_offset 0, -3
 312 0016 0FB6      		in r0,__SREG__
 313 0018 0F92      		push r0
 314 001a 1124      		clr __zero_reg__
 315 001c 8F93      		push r24
 316               	.LCFI2:
 317               		.cfi_def_cfa_offset 5
 318               		.cfi_offset 24, -4
 319 001e 9F93      		push r25
 320               	.LCFI3:
 321               		.cfi_def_cfa_offset 6
 322               		.cfi_offset 25, -5
 323               	/* prologue: Signal */
 324               	/* frame size = 0 */
 325               	/* stack size = 5 */
 326               	.L__stack_usage = 5
  72:main.c        ****     if(PINB&BTNSELECT){
 327               		.loc 1 72 0
 328 0020 B29B      		sbis 0x16,2
 329 0022 00C0      		rjmp .L13
  73:main.c        ****         ledb=1-ledb;
 330               		.loc 1 73 0
 331 0024 9091 0000 		lds r25,ledb
 332 0028 81E0      		ldi r24,lo8(1)
 333 002a 891B      		sub r24,r25
 334 002c 8093 0000 		sts ledb,r24
  74:main.c        ****         ledr=0;
 335               		.loc 1 74 0
 336 0030 1092 0000 		sts ledr,__zero_reg__
 337               	.L13:
 338               	/* epilogue start */
  75:main.c        ****     }
  76:main.c        **** }
 339               		.loc 1 76 0
 340 0034 9F91      		pop r25
 341 0036 8F91      		pop r24
 342 0038 0F90      		pop r0
 343 003a 0FBE      		out __SREG__,r0
 344 003c 0F90      		pop r0
 345 003e 1F90      		pop r1
 346 0040 1895      		reti
 347               		.cfi_endproc
 348               	.LFE8:
 350               	.global	__vector_2
 352               	__vector_2:
 353               	.LFB9:
  77:main.c        **** ISR( PCINT0_vect){
 354               		.loc 1 77 0
 355               		.cfi_startproc
 356 0042 1F92      		push r1
 357               	.LCFI4:
 358               		.cfi_def_cfa_offset 3
 359               		.cfi_offset 1, -2
 360 0044 0F92      		push r0
 361               	.LCFI5:
 362               		.cfi_def_cfa_offset 4
 363               		.cfi_offset 0, -3
 364 0046 0FB6      		in r0,__SREG__
 365 0048 0F92      		push r0
 366 004a 1124      		clr __zero_reg__
 367 004c 8F93      		push r24
 368               	.LCFI6:
 369               		.cfi_def_cfa_offset 5
 370               		.cfi_offset 24, -4
 371               	/* prologue: Signal */
 372               	/* frame size = 0 */
 373               	/* stack size = 4 */
 374               	.L__stack_usage = 4
  78:main.c        ****     if(PINA&BTNOK){
 375               		.loc 1 78 0
 376 004e CF9B      		sbis 0x19,7
 377 0050 00C0      		rjmp .L19
  79:main.c        ****         ledr++;
 378               		.loc 1 79 0
 379 0052 8091 0000 		lds r24,ledr
 380 0056 8F5F      		subi r24,lo8(-(1))
 381 0058 8093 0000 		sts ledr,r24
 382               	.L19:
  80:main.c        ****     }
  81:main.c        ****     if(PINA&BTNINTERNAL){
 383               		.loc 1 81 0
 384 005c CD9B      		sbis 0x19,5
 385 005e 00C0      		rjmp .L18
  82:main.c        ****         ledr--;
 386               		.loc 1 82 0
 387 0060 8091 0000 		lds r24,ledr
 388 0064 8150      		subi r24,lo8(-(-1))
 389 0066 8093 0000 		sts ledr,r24
 390               	.L18:
 391               	/* epilogue start */
  83:main.c        ****     }
  84:main.c        **** }
 392               		.loc 1 84 0
 393 006a 8F91      		pop r24
 394 006c 0F90      		pop r0
 395 006e 0FBE      		out __SREG__,r0
 396 0070 0F90      		pop r0
 397 0072 1F90      		pop r1
 398 0074 1895      		reti
 399               		.cfi_endproc
 400               	.LFE9:
 402               	.global	__vector_8
 404               	__vector_8:
 405               	.LFB10:
  85:main.c        **** ISR( TIM1_OVF_vect ){
 406               		.loc 1 85 0
 407               		.cfi_startproc
 408 0076 1F92      		push r1
 409               	.LCFI7:
 410               		.cfi_def_cfa_offset 3
 411               		.cfi_offset 1, -2
 412 0078 0F92      		push r0
 413               	.LCFI8:
 414               		.cfi_def_cfa_offset 4
 415               		.cfi_offset 0, -3
 416 007a 0FB6      		in r0,__SREG__
 417 007c 0F92      		push r0
 418 007e 1124      		clr __zero_reg__
 419 0080 CF92      		push r12
 420               	.LCFI9:
 421               		.cfi_def_cfa_offset 5
 422               		.cfi_offset 12, -4
 423 0082 DF92      		push r13
 424               	.LCFI10:
 425               		.cfi_def_cfa_offset 6
 426               		.cfi_offset 13, -5
 427 0084 EF92      		push r14
 428               	.LCFI11:
 429               		.cfi_def_cfa_offset 7
 430               		.cfi_offset 14, -6
 431 0086 FF92      		push r15
 432               	.LCFI12:
 433               		.cfi_def_cfa_offset 8
 434               		.cfi_offset 15, -7
 435 0088 0F93      		push r16
 436               	.LCFI13:
 437               		.cfi_def_cfa_offset 9
 438               		.cfi_offset 16, -8
 439 008a 2F93      		push r18
 440               	.LCFI14:
 441               		.cfi_def_cfa_offset 10
 442               		.cfi_offset 18, -9
 443 008c 3F93      		push r19
 444               	.LCFI15:
 445               		.cfi_def_cfa_offset 11
 446               		.cfi_offset 19, -10
 447 008e 4F93      		push r20
 448               	.LCFI16:
 449               		.cfi_def_cfa_offset 12
 450               		.cfi_offset 20, -11
 451 0090 5F93      		push r21
 452               	.LCFI17:
 453               		.cfi_def_cfa_offset 13
 454               		.cfi_offset 21, -12
 455 0092 6F93      		push r22
 456               	.LCFI18:
 457               		.cfi_def_cfa_offset 14
 458               		.cfi_offset 22, -13
 459 0094 7F93      		push r23
 460               	.LCFI19:
 461               		.cfi_def_cfa_offset 15
 462               		.cfi_offset 23, -14
 463 0096 8F93      		push r24
 464               	.LCFI20:
 465               		.cfi_def_cfa_offset 16
 466               		.cfi_offset 24, -15
 467 0098 9F93      		push r25
 468               	.LCFI21:
 469               		.cfi_def_cfa_offset 17
 470               		.cfi_offset 25, -16
 471 009a AF93      		push r26
 472               	.LCFI22:
 473               		.cfi_def_cfa_offset 18
 474               		.cfi_offset 26, -17
 475 009c BF93      		push r27
 476               	.LCFI23:
 477               		.cfi_def_cfa_offset 19
 478               		.cfi_offset 27, -18
 479 009e EF93      		push r30
 480               	.LCFI24:
 481               		.cfi_def_cfa_offset 20
 482               		.cfi_offset 30, -19
 483 00a0 FF93      		push r31
 484               	.LCFI25:
 485               		.cfi_def_cfa_offset 21
 486               		.cfi_offset 31, -20
 487               	/* prologue: Signal */
 488               	/* frame size = 0 */
 489               	/* stack size = 20 */
 490               	.L__stack_usage = 20
  86:main.c        ****     if(ledr){
 491               		.loc 1 86 0
 492 00a2 8091 0000 		lds r24,ledr
 493 00a6 8823      		tst r24
 494 00a8 01F0      		breq .L25
  87:main.c        ****         RTC_readTime(&currentTime);
 495               		.loc 1 87 0
 496 00aa 80E0      		ldi r24,lo8(currentTime)
 497 00ac 90E0      		ldi r25,hi8(currentTime)
 498 00ae 00D0      		rcall RTC_readTime
 499               	.LVL23:
  88:main.c        ****         setLeds(currentTime,leds,tcolorV(YELLOW));
 500               		.loc 1 88 0
 501 00b0 60E0      		ldi r22,0
 502 00b2 7FEF      		ldi r23,lo8(-1)
 503 00b4 8FEF      		ldi r24,lo8(-1)
 504 00b6 90E0      		ldi r25,0
 505 00b8 00D0      		rcall tcolorV
 506               	.LVL24:
 507 00ba 7B01      		movw r14,r22
 508 00bc 082F      		mov r16,r24
 509 00be 20E0      		ldi r18,lo8(leds)
 510 00c0 30E0      		ldi r19,hi8(leds)
 511 00c2 4091 0000 		lds r20,currentTime
 512 00c6 5091 0000 		lds r21,currentTime+1
 513 00ca 6091 0000 		lds r22,currentTime+2
 514 00ce 7091 0000 		lds r23,currentTime+3
 515 00d2 8091 0000 		lds r24,currentTime+4
 516 00d6 00D0      		rcall setLeds
 517               	.LVL25:
 518 00d8 00C0      		rjmp .L24
 519               	.L25:
  89:main.c        ****     }else{
  90:main.c        ****         setLedsNb(RTC_readTemp(),leds,tcolorV(CYAN));
 520               		.loc 1 90 0
 521 00da 6FEF      		ldi r22,lo8(-1)
 522 00dc 7FEF      		ldi r23,lo8(-1)
 523 00de 80E0      		ldi r24,0
 524 00e0 90E0      		ldi r25,0
 525 00e2 00D0      		rcall tcolorV
 526               	.LVL26:
 527 00e4 6B01      		movw r12,r22
 528 00e6 E82E      		mov r14,r24
 529 00e8 00D0      		rcall RTC_readTemp
 530               	.LVL27:
 531 00ea 4E2D      		mov r20,r14
 532 00ec 9601      		movw r18,r12
 533 00ee 60E0      		ldi r22,lo8(leds)
 534 00f0 70E0      		ldi r23,hi8(leds)
 535 00f2 00D0      		rcall setLedsNb
 536               	.LVL28:
 537               	.L24:
 538               	/* epilogue start */
  91:main.c        ****     }
  92:main.c        ****     
  93:main.c        **** }
 539               		.loc 1 93 0
 540 00f4 FF91      		pop r31
 541 00f6 EF91      		pop r30
 542 00f8 BF91      		pop r27
 543 00fa AF91      		pop r26
 544 00fc 9F91      		pop r25
 545 00fe 8F91      		pop r24
 546 0100 7F91      		pop r23
 547 0102 6F91      		pop r22
 548 0104 5F91      		pop r21
 549 0106 4F91      		pop r20
 550 0108 3F91      		pop r19
 551 010a 2F91      		pop r18
 552 010c 0F91      		pop r16
 553 010e FF90      		pop r15
 554 0110 EF90      		pop r14
 555 0112 DF90      		pop r13
 556 0114 CF90      		pop r12
 557 0116 0F90      		pop r0
 558 0118 0FBE      		out __SREG__,r0
 559 011a 0F90      		pop r0
 560 011c 1F90      		pop r1
 561 011e 1895      		reti
 562               		.cfi_endproc
 563               	.LFE10:
 565               	.global	__vector_11
 567               	__vector_11:
 568               	.LFB11:
  94:main.c        **** ISR( TIM0_OVF_vect ){
 569               		.loc 1 94 0
 570               		.cfi_startproc
 571 0120 1F92      		push r1
 572               	.LCFI26:
 573               		.cfi_def_cfa_offset 3
 574               		.cfi_offset 1, -2
 575 0122 0F92      		push r0
 576               	.LCFI27:
 577               		.cfi_def_cfa_offset 4
 578               		.cfi_offset 0, -3
 579 0124 0FB6      		in r0,__SREG__
 580 0126 0F92      		push r0
 581 0128 1124      		clr __zero_reg__
 582 012a 2F93      		push r18
 583               	.LCFI28:
 584               		.cfi_def_cfa_offset 5
 585               		.cfi_offset 18, -4
 586 012c 3F93      		push r19
 587               	.LCFI29:
 588               		.cfi_def_cfa_offset 6
 589               		.cfi_offset 19, -5
 590 012e 4F93      		push r20
 591               	.LCFI30:
 592               		.cfi_def_cfa_offset 7
 593               		.cfi_offset 20, -6
 594 0130 5F93      		push r21
 595               	.LCFI31:
 596               		.cfi_def_cfa_offset 8
 597               		.cfi_offset 21, -7
 598 0132 6F93      		push r22
 599               	.LCFI32:
 600               		.cfi_def_cfa_offset 9
 601               		.cfi_offset 22, -8
 602 0134 7F93      		push r23
 603               	.LCFI33:
 604               		.cfi_def_cfa_offset 10
 605               		.cfi_offset 23, -9
 606 0136 8F93      		push r24
 607               	.LCFI34:
 608               		.cfi_def_cfa_offset 11
 609               		.cfi_offset 24, -10
 610 0138 9F93      		push r25
 611               	.LCFI35:
 612               		.cfi_def_cfa_offset 12
 613               		.cfi_offset 25, -11
 614 013a AF93      		push r26
 615               	.LCFI36:
 616               		.cfi_def_cfa_offset 13
 617               		.cfi_offset 26, -12
 618 013c BF93      		push r27
 619               	.LCFI37:
 620               		.cfi_def_cfa_offset 14
 621               		.cfi_offset 27, -13
 622 013e EF93      		push r30
 623               	.LCFI38:
 624               		.cfi_def_cfa_offset 15
 625               		.cfi_offset 30, -14
 626 0140 FF93      		push r31
 627               	.LCFI39:
 628               		.cfi_def_cfa_offset 16
 629               		.cfi_offset 31, -15
 630               	/* prologue: Signal */
 631               	/* frame size = 0 */
 632               	/* stack size = 15 */
 633               	.L__stack_usage = 15
  95:main.c        ****     switch(state){
 634               		.loc 1 95 0
 635 0142 8091 0000 		lds r24,state
 636 0146 8230      		cpi r24,lo8(2)
 637 0148 01F0      		breq .L29
 638 014a 00F4      		brsh .L30
 639 014c 8823      		tst r24
 640 014e 01F0      		breq .L31
 641 0150 8130      		cpi r24,lo8(1)
 642 0152 01F0      		breq .+2
 643 0154 00C0      		rjmp .L28
  96:main.c        ****         case 0:
  97:main.c        ****             sendData(R2 | getDataByColor(tcolor(1,0,0),0,leds));
  98:main.c        ****             break;
  99:main.c        ****         case 1:
 100:main.c        ****             sendData(R1 | getDataByColor(tcolor(1,0,0),1,leds));
 644               		.loc 1 100 0
 645 0156 40E0      		ldi r20,0
 646 0158 60E0      		ldi r22,0
 647 015a 81E0      		ldi r24,lo8(1)
 648 015c 00D0      		rcall tcolor
 649               	.LVL29:
 650 015e 20E0      		ldi r18,lo8(leds)
 651 0160 30E0      		ldi r19,hi8(leds)
 652 0162 41E0      		ldi r20,lo8(1)
 653 0164 00D0      		rcall getDataByColor
 654               	.LVL30:
 655 0166 7068      		ori r23,128
 656 0168 00C0      		rjmp .L37
 657               	.L30:
  95:main.c        ****     switch(state){
 658               		.loc 1 95 0
 659 016a 8430      		cpi r24,lo8(4)
 660 016c 01F0      		breq .L33
 661 016e 00F0      		brlo .L34
 662 0170 8530      		cpi r24,lo8(5)
 663 0172 01F4      		brne .L28
 101:main.c        ****             break;
 102:main.c        ****         case 2:
 103:main.c        ****             sendData(G2 | getDataByColor(tcolor(0,1,0),0,leds));
 104:main.c        ****             break;
 105:main.c        ****         case 3:
 106:main.c        ****             sendData(G1 | getDataByColor(tcolor(0,1,0),1,leds));
 107:main.c        ****             break;
 108:main.c        ****         case 4:
 109:main.c        ****             sendData(B2 | getDataByColor(tcolor(0,0,1),0,leds));
 110:main.c        ****             break;
 111:main.c        ****         case 5:
 112:main.c        ****             sendData(B1 | getDataByColor(tcolor(0,0,1),1,leds));
 664               		.loc 1 112 0
 665 0174 41E0      		ldi r20,lo8(1)
 666 0176 60E0      		ldi r22,0
 667 0178 80E0      		ldi r24,0
 668 017a 00D0      		rcall tcolor
 669               	.LVL31:
 670 017c 20E0      		ldi r18,lo8(leds)
 671 017e 30E0      		ldi r19,hi8(leds)
 672 0180 41E0      		ldi r20,lo8(1)
 673 0182 00D0      		rcall getDataByColor
 674               	.LVL32:
 675 0184 8260      		ori r24,2
 676 0186 00C0      		rjmp .L37
 677               	.L31:
  97:main.c        ****             break;
 678               		.loc 1 97 0
 679 0188 40E0      		ldi r20,0
 680 018a 60E0      		ldi r22,0
 681 018c 81E0      		ldi r24,lo8(1)
 682 018e 00D0      		rcall tcolor
 683               	.LVL33:
 684 0190 20E0      		ldi r18,lo8(leds)
 685 0192 30E0      		ldi r19,hi8(leds)
 686 0194 40E0      		ldi r20,0
 687 0196 00D0      		rcall getDataByColor
 688               	.LVL34:
 689 0198 7064      		ori r23,64
 690 019a 00C0      		rjmp .L37
 691               	.L29:
 103:main.c        ****             break;
 692               		.loc 1 103 0
 693 019c 40E0      		ldi r20,0
 694 019e 61E0      		ldi r22,lo8(1)
 695 01a0 80E0      		ldi r24,0
 696 01a2 00D0      		rcall tcolor
 697               	.LVL35:
 698 01a4 20E0      		ldi r18,lo8(leds)
 699 01a6 30E0      		ldi r19,hi8(leds)
 700 01a8 40E0      		ldi r20,0
 701 01aa 00D0      		rcall getDataByColor
 702               	.LVL36:
 703 01ac 8460      		ori r24,4
 704 01ae 00C0      		rjmp .L37
 705               	.L34:
 106:main.c        ****             break;
 706               		.loc 1 106 0
 707 01b0 40E0      		ldi r20,0
 708 01b2 61E0      		ldi r22,lo8(1)
 709 01b4 80E0      		ldi r24,0
 710 01b6 00D0      		rcall tcolor
 711               	.LVL37:
 712 01b8 20E0      		ldi r18,lo8(leds)
 713 01ba 30E0      		ldi r19,hi8(leds)
 714 01bc 41E0      		ldi r20,lo8(1)
 715 01be 00D0      		rcall getDataByColor
 716               	.LVL38:
 717 01c0 8860      		ori r24,8
 718 01c2 00C0      		rjmp .L37
 719               	.L33:
 109:main.c        ****             break;
 720               		.loc 1 109 0
 721 01c4 41E0      		ldi r20,lo8(1)
 722 01c6 60E0      		ldi r22,0
 723 01c8 80E0      		ldi r24,0
 724 01ca 00D0      		rcall tcolor
 725               	.LVL39:
 726 01cc 20E0      		ldi r18,lo8(leds)
 727 01ce 30E0      		ldi r19,hi8(leds)
 728 01d0 40E0      		ldi r20,0
 729 01d2 00D0      		rcall getDataByColor
 730               	.LVL40:
 731 01d4 8160      		ori r24,1
 732               	.L37:
 733               		.loc 1 112 0
 734 01d6 00D0      		rcall sendData
 735               	.LVL41:
 736               	.L28:
 113:main.c        ****             break;
 114:main.c        ****     }
 115:main.c        ****     state++;
 737               		.loc 1 115 0
 738 01d8 8091 0000 		lds r24,state
 739 01dc 8F5F      		subi r24,lo8(-(1))
 740 01de 8093 0000 		sts state,r24
 116:main.c        ****     if(state>5)state=0;
 741               		.loc 1 116 0
 742 01e2 8091 0000 		lds r24,state
 743 01e6 8630      		cpi r24,lo8(6)
 744 01e8 00F0      		brlo .L27
 745               		.loc 1 116 0 is_stmt 0 discriminator 1
 746 01ea 1092 0000 		sts state,__zero_reg__
 747               	.L27:
 748               	/* epilogue start */
 117:main.c        **** }
 749               		.loc 1 117 0 is_stmt 1
 750 01ee FF91      		pop r31
 751 01f0 EF91      		pop r30
 752 01f2 BF91      		pop r27
 753 01f4 AF91      		pop r26
 754 01f6 9F91      		pop r25
 755 01f8 8F91      		pop r24
 756 01fa 7F91      		pop r23
 757 01fc 6F91      		pop r22
 758 01fe 5F91      		pop r21
 759 0200 4F91      		pop r20
 760 0202 3F91      		pop r19
 761 0204 2F91      		pop r18
 762 0206 0F90      		pop r0
 763 0208 0FBE      		out __SREG__,r0
 764 020a 0F90      		pop r0
 765 020c 1F90      		pop r1
 766 020e 1895      		reti
 767               		.cfi_endproc
 768               	.LFE11:
 770               		.comm	leds,95,1
 771               	.global	Mindex
 772               		.section .bss
 775               	Mindex:
 776 0000 00        		.zero	1
 777               	.global	Mcurrent
 780               	Mcurrent:
 781 0001 0000      		.zero	2
 782               	.global	state
 785               	state:
 786 0003 00        		.zero	1
 787               	.global	ledb
 790               	ledb:
 791 0004 00        		.zero	1
 792               	.global	ledr
 795               	ledr:
 796 0005 00        		.zero	1
 797               		.comm	M1rainbow,3,1
 798               		.comm	M1reset,3,1
 799               		.comm	M1eventMode,3,1
 800               		.comm	M2setminpm,3,1
 801               		.comm	M2setminam,3,1
 802               		.comm	M2sethourpm,3,1
 803               		.comm	M2sethouram,3,1
 804               		.comm	M1setTime,3,1
 805               		.comm	M3onhour,3,1
 806               		.comm	M2offhour,3,1
 807               		.comm	M1nightmode,3,1
 808               		.comm	M1cmode,3,1
 809               		.comm	M1mode,3,1
 810               		.comm	M0main,3,1
 811               		.comm	currentColor,3,1
 812               		.comm	USI_I2C_Master_State,1,1
 813               		.comm	currentTime,5,1
 814               		.text
 815               	.Letext0:
 816               		.file 3 "/usr/lib/avr/include/stdint.h"
 817               		.file 4 "RTC.h"
 818               		.file 5 "Led.h"
 819               		.file 6 "Menu.h"
 820               		.file 7 "defines.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccWdtGrZ.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccWdtGrZ.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccWdtGrZ.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccWdtGrZ.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccWdtGrZ.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccWdtGrZ.s:12     .text:0000000000000000 sendData
     /tmp/ccWdtGrZ.s:795    .bss:0000000000000005 ledr
     /tmp/ccWdtGrZ.s:790    .bss:0000000000000004 ledb
     /tmp/ccWdtGrZ.s:45     .text.startup:0000000000000000 main
                            *COM*:000000000000005f leds
                            *COM*:0000000000000003 currentColor
                            *COM*:0000000000000005 currentTime
     /tmp/ccWdtGrZ.s:300    .text:0000000000000012 __vector_3
     /tmp/ccWdtGrZ.s:352    .text:0000000000000042 __vector_2
     /tmp/ccWdtGrZ.s:404    .text:0000000000000076 __vector_8
     /tmp/ccWdtGrZ.s:567    .text:0000000000000120 __vector_11
     /tmp/ccWdtGrZ.s:785    .bss:0000000000000003 state
     /tmp/ccWdtGrZ.s:775    .bss:0000000000000000 Mindex
     /tmp/ccWdtGrZ.s:780    .bss:0000000000000001 Mcurrent
                            *COM*:0000000000000003 M1rainbow
                            *COM*:0000000000000003 M1reset
                            *COM*:0000000000000003 M1eventMode
                            *COM*:0000000000000003 M2setminpm
                            *COM*:0000000000000003 M2setminam
                            *COM*:0000000000000003 M2sethourpm
                            *COM*:0000000000000003 M2sethouram
                            *COM*:0000000000000003 M1setTime
                            *COM*:0000000000000003 M3onhour
                            *COM*:0000000000000003 M2offhour
                            *COM*:0000000000000003 M1nightmode
                            *COM*:0000000000000003 M1cmode
                            *COM*:0000000000000003 M1mode
                            *COM*:0000000000000003 M0main
                            *COM*:0000000000000001 USI_I2C_Master_State

UNDEFINED SYMBOLS
sendRawData
ledInit
tcolorV
setCurrentTime
RTC_readTime
setLeds
RTC_readTemp
setLedsNb
tcolor
getDataByColor
__do_clear_bss
