   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	sendData
  12               	sendData:
  13               	.LFB6:
  14               		.file 1 "main.c"
   1:main.c        **** #define F_CPU 16000000UL
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** #include <util/delay.h>
   5:main.c        **** #include "defines.h"
   6:main.c        **** #include "Led.h"
   7:main.c        **** #include "RTC.h"
   8:main.c        **** #include "Menu.h"
   9:main.c        **** 
  10:main.c        **** uint8_t ledr=0;
  11:main.c        **** uint8_t ledb=0;
  12:main.c        **** void sendData(uint32_t data){
  15               		.loc 1 12 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  13:main.c        ****     if(ledr)data|=LEDR;
  22               		.loc 1 13 0
  23 0000 2091 0000 		lds r18,ledr
  24 0004 2111      		cpse r18,__zero_reg__
  25               		.loc 1 13 0 is_stmt 0 discriminator 1
  26 0006 7860      		ori r23,8
  27               	.LVL1:
  28               	.L2:
  14:main.c        ****     if(ledb)data|=LEDB;
  29               		.loc 1 14 0 is_stmt 1
  30 0008 2091 0000 		lds r18,ledb
  31 000c 2111      		cpse r18,__zero_reg__
  32               		.loc 1 14 0 is_stmt 0 discriminator 1
  33 000e 7460      		ori r23,4
  34               	.LVL2:
  35               	.L3:
  15:main.c        ****     sendRawData(data);
  36               		.loc 1 15 0 is_stmt 1
  37 0010 00C0      		rjmp sendRawData
  38               	.LVL3:
  39               		.cfi_endproc
  40               	.LFE6:
  42               		.section	.text.startup,"ax",@progbits
  43               	.global	main
  45               	main:
  46               	.LFB7:
  16:main.c        **** }
  17:main.c        **** 
  18:main.c        **** 
  19:main.c        **** volatile uint8_t state=0;
  20:main.c        **** volatile struct Menu* Mcurrent=0;
  21:main.c        **** volatile uint8_t Mindex=0;
  22:main.c        **** Led leds[NBLEDS];
  23:main.c        **** 
  24:main.c        **** int main(void){    
  47               		.loc 1 24 0
  48               		.cfi_startproc
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
  25:main.c        ****     ledInit(leds);
  53               		.loc 1 25 0
  54 0000 80E0      		ldi r24,lo8(leds)
  55 0002 90E0      		ldi r25,hi8(leds)
  56 0004 00D0      		rcall ledInit
  57               	.LVL4:
  26:main.c        ****     DDRA&=~(BTNSELECT|BTNOK);
  58               		.loc 1 26 0
  59 0006 8AB3      		in r24,0x1a
  60 0008 8F75      		andi r24,lo8(95)
  61 000a 8ABB      		out 0x1a,r24
  27:main.c        ****     PORTA|=(BTNSELECT|BTNOK);
  62               		.loc 1 27 0
  63 000c 8BB3      		in r24,0x1b
  64 000e 806A      		ori r24,lo8(-96)
  65 0010 8BBB      		out 0x1b,r24
  28:main.c        ****     TIMSK1|=(1<<TOIE1);
  66               		.loc 1 28 0
  67 0012 609A      		sbi 0xc,0
  29:main.c        ****     TIMSK0|=(1<<TOIE0);
  68               		.loc 1 29 0
  69 0014 89B7      		in r24,0x39
  70 0016 8160      		ori r24,lo8(1)
  71 0018 89BF      		out 0x39,r24
  30:main.c        ****     GIMSK|=(1<<PCIE0);
  72               		.loc 1 30 0
  73 001a 8BB7      		in r24,0x3b
  74 001c 8061      		ori r24,lo8(16)
  75 001e 8BBF      		out 0x3b,r24
  31:main.c        ****     PCMSK0|=(1<<PCINT5);
  76               		.loc 1 31 0
  77 0020 959A      		sbi 0x12,5
  32:main.c        ****     sei();
  78               		.loc 1 32 0
  79               	/* #APP */
  80               	 ;  32 "main.c" 1
  81 0022 7894      		sei
  82               	 ;  0 "" 2
  33:main.c        ****     
  34:main.c        ****     sendData(0b11111100001111111111);//white
  83               		.loc 1 34 0
  84               	/* #NOAPP */
  85 0024 6FEF      		ldi r22,lo8(-1)
  86 0026 73EC      		ldi r23,lo8(-61)
  87 0028 8FE0      		ldi r24,lo8(15)
  88 002a 90E0      		ldi r25,0
  89 002c 00D0      		rcall sendData
  90               	.LVL5:
  91               	.LBB16:
  92               	.LBB17:
  93               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  94               		.loc 2 187 0
  95 002e 2FEF      		ldi r18,lo8(1599999)
  96 0030 89E6      		ldi r24,hi8(1599999)
  97 0032 98E1      		ldi r25,hlo8(1599999)
  98 0034 2150      	1:	subi r18,1
  99 0036 8040      		sbci r24,0
 100 0038 9040      		sbci r25,0
 101 003a 01F4      		brne 1b
 102 003c 00C0      		rjmp .
 103 003e 0000      		nop
 104               	.LVL6:
 105               	.LBE17:
 106               	.LBE16:
  35:main.c        ****     _delay_ms(500);
  36:main.c        ****     sendData(0b11000000001111111111);//green
 107               		.loc 1 36 0
 108 0040 6FEF      		ldi r22,lo8(-1)
 109 0042 73E0      		ldi r23,lo8(3)
 110 0044 8CE0      		ldi r24,lo8(12)
 111 0046 90E0      		ldi r25,0
 112 0048 00D0      		rcall sendData
 113               	.LVL7:
 114               	.LBB18:
 115               	.LBB19:
 116               		.loc 2 187 0
 117 004a 2FEF      		ldi r18,lo8(1599999)
 118 004c 89E6      		ldi r24,hi8(1599999)
 119 004e 98E1      		ldi r25,hlo8(1599999)
 120 0050 2150      	1:	subi r18,1
 121 0052 8040      		sbci r24,0
 122 0054 9040      		sbci r25,0
 123 0056 01F4      		brne 1b
 124 0058 00C0      		rjmp .
 125 005a 0000      		nop
 126               	.LVL8:
 127               	.LBE19:
 128               	.LBE18:
  37:main.c        ****     _delay_ms(500);
  38:main.c        ****     sendData(0b00001100001111111111);//red
 129               		.loc 1 38 0
 130 005c 6FEF      		ldi r22,lo8(-1)
 131 005e 73EC      		ldi r23,lo8(-61)
 132 0060 80E0      		ldi r24,0
 133 0062 90E0      		ldi r25,0
 134 0064 00D0      		rcall sendData
 135               	.LVL9:
 136               	.LBB20:
 137               	.LBB21:
 138               		.loc 2 187 0
 139 0066 2FEF      		ldi r18,lo8(1599999)
 140 0068 89E6      		ldi r24,hi8(1599999)
 141 006a 98E1      		ldi r25,hlo8(1599999)
 142 006c 2150      	1:	subi r18,1
 143 006e 8040      		sbci r24,0
 144 0070 9040      		sbci r25,0
 145 0072 01F4      		brne 1b
 146 0074 00C0      		rjmp .
 147 0076 0000      		nop
 148               	.LVL10:
 149               	.LBE21:
 150               	.LBE20:
  39:main.c        ****     _delay_ms(500);
  40:main.c        ****     sendData(0b00110000001111111111);//blue
 151               		.loc 1 40 0
 152 0078 6FEF      		ldi r22,lo8(-1)
 153 007a 73E0      		ldi r23,lo8(3)
 154 007c 83E0      		ldi r24,lo8(3)
 155 007e 90E0      		ldi r25,0
 156 0080 00D0      		rcall sendData
 157               	.LVL11:
 158               	.LBB22:
 159               	.LBB23:
 160               		.loc 2 187 0
 161 0082 2FEF      		ldi r18,lo8(1599999)
 162 0084 89E6      		ldi r24,hi8(1599999)
 163 0086 98E1      		ldi r25,hlo8(1599999)
 164 0088 2150      	1:	subi r18,1
 165 008a 8040      		sbci r24,0
 166 008c 9040      		sbci r25,0
 167 008e 01F4      		brne 1b
 168 0090 00C0      		rjmp .
 169 0092 0000      		nop
 170               	.LVL12:
 171               	.LBE23:
 172               	.LBE22:
  41:main.c        ****     _delay_ms(500);
  42:main.c        ****     sendData(0b11110000001111111111);//cyan
 173               		.loc 1 42 0
 174 0094 6FEF      		ldi r22,lo8(-1)
 175 0096 73E0      		ldi r23,lo8(3)
 176 0098 8FE0      		ldi r24,lo8(15)
 177 009a 90E0      		ldi r25,0
 178 009c 00D0      		rcall sendData
 179               	.LVL13:
 180               	.LBB24:
 181               	.LBB25:
 182               		.loc 2 187 0
 183 009e 2FEF      		ldi r18,lo8(1599999)
 184 00a0 89E6      		ldi r24,hi8(1599999)
 185 00a2 98E1      		ldi r25,hlo8(1599999)
 186 00a4 2150      	1:	subi r18,1
 187 00a6 8040      		sbci r24,0
 188 00a8 9040      		sbci r25,0
 189 00aa 01F4      		brne 1b
 190 00ac 00C0      		rjmp .
 191 00ae 0000      		nop
 192               	.LVL14:
 193               	.LBE25:
 194               	.LBE24:
  43:main.c        ****     _delay_ms(500);
  44:main.c        ****     sendData(0b00111100001111111111);//magenta
 195               		.loc 1 44 0
 196 00b0 6FEF      		ldi r22,lo8(-1)
 197 00b2 73EC      		ldi r23,lo8(-61)
 198 00b4 83E0      		ldi r24,lo8(3)
 199 00b6 90E0      		ldi r25,0
 200 00b8 00D0      		rcall sendData
 201               	.LVL15:
 202               	.LBB26:
 203               	.LBB27:
 204               		.loc 2 187 0
 205 00ba 2FEF      		ldi r18,lo8(1599999)
 206 00bc 89E6      		ldi r24,hi8(1599999)
 207 00be 98E1      		ldi r25,hlo8(1599999)
 208 00c0 2150      	1:	subi r18,1
 209 00c2 8040      		sbci r24,0
 210 00c4 9040      		sbci r25,0
 211 00c6 01F4      		brne 1b
 212 00c8 00C0      		rjmp .
 213 00ca 0000      		nop
 214               	.LVL16:
 215               	.LBE27:
 216               	.LBE26:
  45:main.c        ****     _delay_ms(500);
  46:main.c        ****     sendData(0b11001100001111111111);//yellow
 217               		.loc 1 46 0
 218 00cc 6FEF      		ldi r22,lo8(-1)
 219 00ce 73EC      		ldi r23,lo8(-61)
 220 00d0 8CE0      		ldi r24,lo8(12)
 221 00d2 90E0      		ldi r25,0
 222 00d4 00D0      		rcall sendData
 223               	.LVL17:
 224               	.LBB28:
 225               	.LBB29:
 226               		.loc 2 187 0
 227 00d6 2FEF      		ldi r18,lo8(1599999)
 228 00d8 89E6      		ldi r24,hi8(1599999)
 229 00da 98E1      		ldi r25,hlo8(1599999)
 230 00dc 2150      	1:	subi r18,1
 231 00de 8040      		sbci r24,0
 232 00e0 9040      		sbci r25,0
 233 00e2 01F4      		brne 1b
 234 00e4 00C0      		rjmp .
 235 00e6 0000      		nop
 236               	.LVL18:
 237               	.LBE29:
 238               	.LBE28:
  47:main.c        ****     _delay_ms(500);
  48:main.c        ****     
  49:main.c        ****     #ifdef DELLONG
  50:main.c        ****     TCCR1B|=(1<<CS12)|(1<<CS10);
 239               		.loc 1 50 0
 240 00e8 8EB5      		in r24,0x2e
 241 00ea 8560      		ori r24,lo8(5)
 242 00ec 8EBD      		out 0x2e,r24
  51:main.c        ****     #else
  52:main.c        ****     TCCR1B|=(1<<CS12);//|(1<<CS10);
  53:main.c        ****     #endif
  54:main.c        ****     
  55:main.c        ****     TCCR0B|=(1<<CS01)|(1<<CS00);
 243               		.loc 1 55 0
 244 00ee 83B7      		in r24,0x33
 245 00f0 8360      		ori r24,lo8(3)
 246 00f2 83BF      		out 0x33,r24
  56:main.c        ****     
  57:main.c        ****     currentColor=tcolorV(WHITE);
 247               		.loc 1 57 0
 248 00f4 6FEF      		ldi r22,lo8(-1)
 249 00f6 7FEF      		ldi r23,lo8(-1)
 250 00f8 8FEF      		ldi r24,lo8(-1)
 251 00fa 90E0      		ldi r25,0
 252 00fc 00D0      		rcall tcolorV
 253               	.LVL19:
 254 00fe 6093 0000 		sts currentColor,r22
 255 0102 7093 0000 		sts currentColor+1,r23
 256 0106 8093 0000 		sts currentColor+2,r24
  58:main.c        ****     setCurrentTime(0,10,7,12);
 257               		.loc 1 58 0
 258 010a 2CE0      		ldi r18,lo8(12)
 259 010c 47E0      		ldi r20,lo8(7)
 260 010e 6AE0      		ldi r22,lo8(10)
 261 0110 80E0      		ldi r24,0
 262 0112 00D0      		rcall setCurrentTime
 263               	.LVL20:
  59:main.c        ****    // //RTC_setTime(currentTime,6,18);
  60:main.c        ****     //RTC_readTime(&currentTime);
  61:main.c        ****     setLeds(currentTime,leds,currentColor);
 264               		.loc 1 61 0
 265 0114 E090 0000 		lds r14,currentColor
 266 0118 F090 0000 		lds r15,currentColor+1
 267 011c 0091 0000 		lds r16,currentColor+2
 268 0120 20E0      		ldi r18,lo8(leds)
 269 0122 30E0      		ldi r19,hi8(leds)
 270 0124 4091 0000 		lds r20,currentTime
 271 0128 5091 0000 		lds r21,currentTime+1
 272 012c 6091 0000 		lds r22,currentTime+2
 273 0130 7091 0000 		lds r23,currentTime+3
 274 0134 8091 0000 		lds r24,currentTime+4
 275 0138 00D0      		rcall setLeds
 276               	.LVL21:
 277               	.L12:
 278 013a 00C0      		rjmp .L12
 279               		.cfi_endproc
 280               	.LFE7:
 282               		.text
 283               	.global	__vector_2
 285               	__vector_2:
 286               	.LFB8:
  62:main.c        ****     //setLedsNb(currentTime.temp,leds,currentColor);
  63:main.c        ****     while(1){
  64:main.c        ****        /* if(PINA&BTNSELECT){//PCINT5
  65:main.c        ****             ledb=1;
  66:main.c        ****         }else{
  67:main.c        ****             ledb=0;
  68:main.c        ****         }*/
  69:main.c        ****     }
  70:main.c        ****     return(0);
  71:main.c        ****     
  72:main.c        **** }
  73:main.c        **** ISR( PCINT0_vect){
 287               		.loc 1 73 0
 288               		.cfi_startproc
 289 0012 1F92      		push r1
 290               	.LCFI0:
 291               		.cfi_def_cfa_offset 3
 292               		.cfi_offset 1, -2
 293 0014 0F92      		push r0
 294               	.LCFI1:
 295               		.cfi_def_cfa_offset 4
 296               		.cfi_offset 0, -3
 297 0016 0FB6      		in r0,__SREG__
 298 0018 0F92      		push r0
 299 001a 1124      		clr __zero_reg__
 300 001c 8F93      		push r24
 301               	.LCFI2:
 302               		.cfi_def_cfa_offset 5
 303               		.cfi_offset 24, -4
 304 001e 9F93      		push r25
 305               	.LCFI3:
 306               		.cfi_def_cfa_offset 6
 307               		.cfi_offset 25, -5
 308               	/* prologue: Signal */
 309               	/* frame size = 0 */
 310               	/* stack size = 5 */
 311               	.L__stack_usage = 5
  74:main.c        ****     if(PINA&BTNSELECT){
 312               		.loc 1 74 0
 313 0020 CD9B      		sbis 0x19,5
 314 0022 00C0      		rjmp .L13
  75:main.c        ****         ledb=1-ledb;
 315               		.loc 1 75 0
 316 0024 9091 0000 		lds r25,ledb
 317 0028 81E0      		ldi r24,lo8(1)
 318 002a 891B      		sub r24,r25
 319 002c 8093 0000 		sts ledb,r24
 320               	.L13:
 321               	/* epilogue start */
  76:main.c        ****     }
  77:main.c        **** }
 322               		.loc 1 77 0
 323 0030 9F91      		pop r25
 324 0032 8F91      		pop r24
 325 0034 0F90      		pop r0
 326 0036 0FBE      		out __SREG__,r0
 327 0038 0F90      		pop r0
 328 003a 1F90      		pop r1
 329 003c 1895      		reti
 330               		.cfi_endproc
 331               	.LFE8:
 333               	.global	__vector_8
 335               	__vector_8:
 336               	.LFB9:
  78:main.c        **** ISR( TIM1_OVF_vect ){
 337               		.loc 1 78 0
 338               		.cfi_startproc
 339 003e 1F92      		push r1
 340               	.LCFI4:
 341               		.cfi_def_cfa_offset 3
 342               		.cfi_offset 1, -2
 343 0040 0F92      		push r0
 344               	.LCFI5:
 345               		.cfi_def_cfa_offset 4
 346               		.cfi_offset 0, -3
 347 0042 0FB6      		in r0,__SREG__
 348 0044 0F92      		push r0
 349 0046 1124      		clr __zero_reg__
 350 0048 EF92      		push r14
 351               	.LCFI6:
 352               		.cfi_def_cfa_offset 5
 353               		.cfi_offset 14, -4
 354 004a FF92      		push r15
 355               	.LCFI7:
 356               		.cfi_def_cfa_offset 6
 357               		.cfi_offset 15, -5
 358 004c 0F93      		push r16
 359               	.LCFI8:
 360               		.cfi_def_cfa_offset 7
 361               		.cfi_offset 16, -6
 362 004e 2F93      		push r18
 363               	.LCFI9:
 364               		.cfi_def_cfa_offset 8
 365               		.cfi_offset 18, -7
 366 0050 3F93      		push r19
 367               	.LCFI10:
 368               		.cfi_def_cfa_offset 9
 369               		.cfi_offset 19, -8
 370 0052 4F93      		push r20
 371               	.LCFI11:
 372               		.cfi_def_cfa_offset 10
 373               		.cfi_offset 20, -9
 374 0054 5F93      		push r21
 375               	.LCFI12:
 376               		.cfi_def_cfa_offset 11
 377               		.cfi_offset 21, -10
 378 0056 6F93      		push r22
 379               	.LCFI13:
 380               		.cfi_def_cfa_offset 12
 381               		.cfi_offset 22, -11
 382 0058 7F93      		push r23
 383               	.LCFI14:
 384               		.cfi_def_cfa_offset 13
 385               		.cfi_offset 23, -12
 386 005a 8F93      		push r24
 387               	.LCFI15:
 388               		.cfi_def_cfa_offset 14
 389               		.cfi_offset 24, -13
 390 005c 9F93      		push r25
 391               	.LCFI16:
 392               		.cfi_def_cfa_offset 15
 393               		.cfi_offset 25, -14
 394 005e AF93      		push r26
 395               	.LCFI17:
 396               		.cfi_def_cfa_offset 16
 397               		.cfi_offset 26, -15
 398 0060 BF93      		push r27
 399               	.LCFI18:
 400               		.cfi_def_cfa_offset 17
 401               		.cfi_offset 27, -16
 402 0062 EF93      		push r30
 403               	.LCFI19:
 404               		.cfi_def_cfa_offset 18
 405               		.cfi_offset 30, -17
 406 0064 FF93      		push r31
 407               	.LCFI20:
 408               		.cfi_def_cfa_offset 19
 409               		.cfi_offset 31, -18
 410               	/* prologue: Signal */
 411               	/* frame size = 0 */
 412               	/* stack size = 18 */
 413               	.L__stack_usage = 18
  79:main.c        ****     ledr=!ledr;
 414               		.loc 1 79 0
 415 0066 8091 0000 		lds r24,ledr
 416 006a 91E0      		ldi r25,lo8(1)
 417 006c 8111      		cpse r24,__zero_reg__
 418 006e 90E0      		ldi r25,0
 419               	.L19:
 420 0070 9093 0000 		sts ledr,r25
  80:main.c        ****     if(ledr){
 421               		.loc 1 80 0
 422 0074 8111      		cpse r24,__zero_reg__
 423 0076 00C0      		rjmp .L20
  81:main.c        ****         //RTC_readTime(&currentTime);
  82:main.c        ****         setLeds(currentTime,leds,tcolorV(YELLOW));
 424               		.loc 1 82 0
 425 0078 60E0      		ldi r22,0
 426 007a 7FEF      		ldi r23,lo8(-1)
 427 007c 8FEF      		ldi r24,lo8(-1)
 428 007e 90E0      		ldi r25,0
 429 0080 00D0      		rcall tcolorV
 430               	.LVL22:
 431 0082 7B01      		movw r14,r22
 432 0084 082F      		mov r16,r24
 433 0086 20E0      		ldi r18,lo8(leds)
 434 0088 30E0      		ldi r19,hi8(leds)
 435 008a 4091 0000 		lds r20,currentTime
 436 008e 5091 0000 		lds r21,currentTime+1
 437 0092 6091 0000 		lds r22,currentTime+2
 438 0096 7091 0000 		lds r23,currentTime+3
 439 009a 8091 0000 		lds r24,currentTime+4
 440 009e 00D0      		rcall setLeds
 441               	.LVL23:
 442 00a0 00C0      		rjmp .L18
 443               	.L20:
  83:main.c        ****     }else{
  84:main.c        ****         setLedsNb(10/*RTC_readTemp()*/,leds,tcolorV(CYAN));
 444               		.loc 1 84 0
 445 00a2 6FEF      		ldi r22,lo8(-1)
 446 00a4 7FEF      		ldi r23,lo8(-1)
 447 00a6 80E0      		ldi r24,0
 448 00a8 90E0      		ldi r25,0
 449 00aa 00D0      		rcall tcolorV
 450               	.LVL24:
 451 00ac 9B01      		movw r18,r22
 452 00ae 482F      		mov r20,r24
 453 00b0 60E0      		ldi r22,lo8(leds)
 454 00b2 70E0      		ldi r23,hi8(leds)
 455 00b4 8AE0      		ldi r24,lo8(10)
 456 00b6 00D0      		rcall setLedsNb
 457               	.LVL25:
 458               	.L18:
 459               	/* epilogue start */
  85:main.c        ****     }
  86:main.c        ****     
  87:main.c        **** }
 460               		.loc 1 87 0
 461 00b8 FF91      		pop r31
 462 00ba EF91      		pop r30
 463 00bc BF91      		pop r27
 464 00be AF91      		pop r26
 465 00c0 9F91      		pop r25
 466 00c2 8F91      		pop r24
 467 00c4 7F91      		pop r23
 468 00c6 6F91      		pop r22
 469 00c8 5F91      		pop r21
 470 00ca 4F91      		pop r20
 471 00cc 3F91      		pop r19
 472 00ce 2F91      		pop r18
 473 00d0 0F91      		pop r16
 474 00d2 FF90      		pop r15
 475 00d4 EF90      		pop r14
 476 00d6 0F90      		pop r0
 477 00d8 0FBE      		out __SREG__,r0
 478 00da 0F90      		pop r0
 479 00dc 1F90      		pop r1
 480 00de 1895      		reti
 481               		.cfi_endproc
 482               	.LFE9:
 484               	.global	__vector_11
 486               	__vector_11:
 487               	.LFB10:
  88:main.c        **** ISR( TIM0_OVF_vect ){
 488               		.loc 1 88 0
 489               		.cfi_startproc
 490 00e0 1F92      		push r1
 491               	.LCFI21:
 492               		.cfi_def_cfa_offset 3
 493               		.cfi_offset 1, -2
 494 00e2 0F92      		push r0
 495               	.LCFI22:
 496               		.cfi_def_cfa_offset 4
 497               		.cfi_offset 0, -3
 498 00e4 0FB6      		in r0,__SREG__
 499 00e6 0F92      		push r0
 500 00e8 1124      		clr __zero_reg__
 501 00ea 2F93      		push r18
 502               	.LCFI23:
 503               		.cfi_def_cfa_offset 5
 504               		.cfi_offset 18, -4
 505 00ec 3F93      		push r19
 506               	.LCFI24:
 507               		.cfi_def_cfa_offset 6
 508               		.cfi_offset 19, -5
 509 00ee 4F93      		push r20
 510               	.LCFI25:
 511               		.cfi_def_cfa_offset 7
 512               		.cfi_offset 20, -6
 513 00f0 5F93      		push r21
 514               	.LCFI26:
 515               		.cfi_def_cfa_offset 8
 516               		.cfi_offset 21, -7
 517 00f2 6F93      		push r22
 518               	.LCFI27:
 519               		.cfi_def_cfa_offset 9
 520               		.cfi_offset 22, -8
 521 00f4 7F93      		push r23
 522               	.LCFI28:
 523               		.cfi_def_cfa_offset 10
 524               		.cfi_offset 23, -9
 525 00f6 8F93      		push r24
 526               	.LCFI29:
 527               		.cfi_def_cfa_offset 11
 528               		.cfi_offset 24, -10
 529 00f8 9F93      		push r25
 530               	.LCFI30:
 531               		.cfi_def_cfa_offset 12
 532               		.cfi_offset 25, -11
 533 00fa AF93      		push r26
 534               	.LCFI31:
 535               		.cfi_def_cfa_offset 13
 536               		.cfi_offset 26, -12
 537 00fc BF93      		push r27
 538               	.LCFI32:
 539               		.cfi_def_cfa_offset 14
 540               		.cfi_offset 27, -13
 541 00fe EF93      		push r30
 542               	.LCFI33:
 543               		.cfi_def_cfa_offset 15
 544               		.cfi_offset 30, -14
 545 0100 FF93      		push r31
 546               	.LCFI34:
 547               		.cfi_def_cfa_offset 16
 548               		.cfi_offset 31, -15
 549               	/* prologue: Signal */
 550               	/* frame size = 0 */
 551               	/* stack size = 15 */
 552               	.L__stack_usage = 15
  89:main.c        ****     switch(state){
 553               		.loc 1 89 0
 554 0102 8091 0000 		lds r24,state
 555 0106 8230      		cpi r24,lo8(2)
 556 0108 01F0      		breq .L27
 557 010a 00F4      		brsh .L28
 558 010c 8823      		tst r24
 559 010e 01F0      		breq .L29
 560 0110 8130      		cpi r24,lo8(1)
 561 0112 01F0      		breq .+2
 562 0114 00C0      		rjmp .L26
  90:main.c        ****         case 0:
  91:main.c        ****             sendData(R2 | getDataByColor(tcolor(1,0,0),0,leds));
  92:main.c        ****             break;
  93:main.c        ****         case 1:
  94:main.c        ****             sendData(R1 | getDataByColor(tcolor(1,0,0),1,leds));
 563               		.loc 1 94 0
 564 0116 40E0      		ldi r20,0
 565 0118 60E0      		ldi r22,0
 566 011a 81E0      		ldi r24,lo8(1)
 567 011c 00D0      		rcall tcolor
 568               	.LVL26:
 569 011e 20E0      		ldi r18,lo8(leds)
 570 0120 30E0      		ldi r19,hi8(leds)
 571 0122 41E0      		ldi r20,lo8(1)
 572 0124 00D0      		rcall getDataByColor
 573               	.LVL27:
 574 0126 7068      		ori r23,128
 575 0128 00C0      		rjmp .L35
 576               	.L28:
  89:main.c        ****     switch(state){
 577               		.loc 1 89 0
 578 012a 8430      		cpi r24,lo8(4)
 579 012c 01F0      		breq .L31
 580 012e 00F0      		brlo .L32
 581 0130 8530      		cpi r24,lo8(5)
 582 0132 01F4      		brne .L26
  95:main.c        ****             break;
  96:main.c        ****         case 2:
  97:main.c        ****             sendData(G2 | getDataByColor(tcolor(0,1,0),0,leds));
  98:main.c        ****             break;
  99:main.c        ****         case 3:
 100:main.c        ****             sendData(G1 | getDataByColor(tcolor(0,1,0),1,leds));
 101:main.c        ****             break;
 102:main.c        ****         case 4:
 103:main.c        ****             sendData(B2 | getDataByColor(tcolor(0,0,1),0,leds));
 104:main.c        ****             break;
 105:main.c        ****         case 5:
 106:main.c        ****             sendData(B1 | getDataByColor(tcolor(0,0,1),1,leds));
 583               		.loc 1 106 0
 584 0134 41E0      		ldi r20,lo8(1)
 585 0136 60E0      		ldi r22,0
 586 0138 80E0      		ldi r24,0
 587 013a 00D0      		rcall tcolor
 588               	.LVL28:
 589 013c 20E0      		ldi r18,lo8(leds)
 590 013e 30E0      		ldi r19,hi8(leds)
 591 0140 41E0      		ldi r20,lo8(1)
 592 0142 00D0      		rcall getDataByColor
 593               	.LVL29:
 594 0144 8260      		ori r24,2
 595 0146 00C0      		rjmp .L35
 596               	.L29:
  91:main.c        ****             break;
 597               		.loc 1 91 0
 598 0148 40E0      		ldi r20,0
 599 014a 60E0      		ldi r22,0
 600 014c 81E0      		ldi r24,lo8(1)
 601 014e 00D0      		rcall tcolor
 602               	.LVL30:
 603 0150 20E0      		ldi r18,lo8(leds)
 604 0152 30E0      		ldi r19,hi8(leds)
 605 0154 40E0      		ldi r20,0
 606 0156 00D0      		rcall getDataByColor
 607               	.LVL31:
 608 0158 7064      		ori r23,64
 609 015a 00C0      		rjmp .L35
 610               	.L27:
  97:main.c        ****             break;
 611               		.loc 1 97 0
 612 015c 40E0      		ldi r20,0
 613 015e 61E0      		ldi r22,lo8(1)
 614 0160 80E0      		ldi r24,0
 615 0162 00D0      		rcall tcolor
 616               	.LVL32:
 617 0164 20E0      		ldi r18,lo8(leds)
 618 0166 30E0      		ldi r19,hi8(leds)
 619 0168 40E0      		ldi r20,0
 620 016a 00D0      		rcall getDataByColor
 621               	.LVL33:
 622 016c 8460      		ori r24,4
 623 016e 00C0      		rjmp .L35
 624               	.L32:
 100:main.c        ****             break;
 625               		.loc 1 100 0
 626 0170 40E0      		ldi r20,0
 627 0172 61E0      		ldi r22,lo8(1)
 628 0174 80E0      		ldi r24,0
 629 0176 00D0      		rcall tcolor
 630               	.LVL34:
 631 0178 20E0      		ldi r18,lo8(leds)
 632 017a 30E0      		ldi r19,hi8(leds)
 633 017c 41E0      		ldi r20,lo8(1)
 634 017e 00D0      		rcall getDataByColor
 635               	.LVL35:
 636 0180 8860      		ori r24,8
 637 0182 00C0      		rjmp .L35
 638               	.L31:
 103:main.c        ****             break;
 639               		.loc 1 103 0
 640 0184 41E0      		ldi r20,lo8(1)
 641 0186 60E0      		ldi r22,0
 642 0188 80E0      		ldi r24,0
 643 018a 00D0      		rcall tcolor
 644               	.LVL36:
 645 018c 20E0      		ldi r18,lo8(leds)
 646 018e 30E0      		ldi r19,hi8(leds)
 647 0190 40E0      		ldi r20,0
 648 0192 00D0      		rcall getDataByColor
 649               	.LVL37:
 650 0194 8160      		ori r24,1
 651               	.L35:
 652               		.loc 1 106 0
 653 0196 00D0      		rcall sendData
 654               	.LVL38:
 655               	.L26:
 107:main.c        ****             break;
 108:main.c        ****     }
 109:main.c        ****     state++;
 656               		.loc 1 109 0
 657 0198 8091 0000 		lds r24,state
 658 019c 8F5F      		subi r24,lo8(-(1))
 659 019e 8093 0000 		sts state,r24
 110:main.c        ****     if(state>5)state=0;
 660               		.loc 1 110 0
 661 01a2 8091 0000 		lds r24,state
 662 01a6 8630      		cpi r24,lo8(6)
 663 01a8 00F0      		brlo .L25
 664               		.loc 1 110 0 is_stmt 0 discriminator 1
 665 01aa 1092 0000 		sts state,__zero_reg__
 666               	.L25:
 667               	/* epilogue start */
 111:main.c        **** }
 668               		.loc 1 111 0 is_stmt 1
 669 01ae FF91      		pop r31
 670 01b0 EF91      		pop r30
 671 01b2 BF91      		pop r27
 672 01b4 AF91      		pop r26
 673 01b6 9F91      		pop r25
 674 01b8 8F91      		pop r24
 675 01ba 7F91      		pop r23
 676 01bc 6F91      		pop r22
 677 01be 5F91      		pop r21
 678 01c0 4F91      		pop r20
 679 01c2 3F91      		pop r19
 680 01c4 2F91      		pop r18
 681 01c6 0F90      		pop r0
 682 01c8 0FBE      		out __SREG__,r0
 683 01ca 0F90      		pop r0
 684 01cc 1F90      		pop r1
 685 01ce 1895      		reti
 686               		.cfi_endproc
 687               	.LFE10:
 689               		.comm	leds,95,1
 690               	.global	Mindex
 691               		.section .bss
 694               	Mindex:
 695 0000 00        		.zero	1
 696               	.global	Mcurrent
 699               	Mcurrent:
 700 0001 0000      		.zero	2
 701               	.global	state
 704               	state:
 705 0003 00        		.zero	1
 706               	.global	ledb
 709               	ledb:
 710 0004 00        		.zero	1
 711               	.global	ledr
 714               	ledr:
 715 0005 00        		.zero	1
 716               		.comm	M1rainbow,3,1
 717               		.comm	M1reset,3,1
 718               		.comm	M1eventMode,3,1
 719               		.comm	M2setminpm,3,1
 720               		.comm	M2setminam,3,1
 721               		.comm	M2sethourpm,3,1
 722               		.comm	M2sethouram,3,1
 723               		.comm	M1setTime,3,1
 724               		.comm	M3onhour,3,1
 725               		.comm	M2offhour,3,1
 726               		.comm	M1nightmode,3,1
 727               		.comm	M1cmode,3,1
 728               		.comm	M1mode,3,1
 729               		.comm	M0main,3,1
 730               		.comm	currentColor,3,1
 731               		.comm	USI_I2C_Master_State,1,1
 732               		.comm	currentTime,5,1
 733               		.text
 734               	.Letext0:
 735               		.file 3 "/usr/lib/avr/include/stdint.h"
 736               		.file 4 "RTC.h"
 737               		.file 5 "Led.h"
 738               		.file 6 "Menu.h"
 739               		.file 7 "defines.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccIPE5QU.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccIPE5QU.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccIPE5QU.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccIPE5QU.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccIPE5QU.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccIPE5QU.s:12     .text:0000000000000000 sendData
     /tmp/ccIPE5QU.s:714    .bss:0000000000000005 ledr
     /tmp/ccIPE5QU.s:709    .bss:0000000000000004 ledb
     /tmp/ccIPE5QU.s:45     .text.startup:0000000000000000 main
                            *COM*:000000000000005f leds
                            *COM*:0000000000000003 currentColor
                            *COM*:0000000000000005 currentTime
     /tmp/ccIPE5QU.s:285    .text:0000000000000012 __vector_2
     /tmp/ccIPE5QU.s:335    .text:000000000000003e __vector_8
     /tmp/ccIPE5QU.s:486    .text:00000000000000e0 __vector_11
     /tmp/ccIPE5QU.s:704    .bss:0000000000000003 state
     /tmp/ccIPE5QU.s:694    .bss:0000000000000000 Mindex
     /tmp/ccIPE5QU.s:699    .bss:0000000000000001 Mcurrent
                            *COM*:0000000000000003 M1rainbow
                            *COM*:0000000000000003 M1reset
                            *COM*:0000000000000003 M1eventMode
                            *COM*:0000000000000003 M2setminpm
                            *COM*:0000000000000003 M2setminam
                            *COM*:0000000000000003 M2sethourpm
                            *COM*:0000000000000003 M2sethouram
                            *COM*:0000000000000003 M1setTime
                            *COM*:0000000000000003 M3onhour
                            *COM*:0000000000000003 M2offhour
                            *COM*:0000000000000003 M1nightmode
                            *COM*:0000000000000003 M1cmode
                            *COM*:0000000000000003 M1mode
                            *COM*:0000000000000003 M0main
                            *COM*:0000000000000001 USI_I2C_Master_State

UNDEFINED SYMBOLS
sendRawData
ledInit
tcolorV
setCurrentTime
setLeds
setLedsNb
tcolor
getDataByColor
__do_clear_bss
