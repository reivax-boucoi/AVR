   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	sendData
  12               	sendData:
  13               	.LFB6:
  14               		.file 1 "main.c"
   1:main.c        **** #define F_CPU 16000000UL
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** #include <util/delay.h>
   5:main.c        **** #include "defines.h"
   6:main.c        **** #include "Led.h"
   7:main.c        **** #include "RTC.h"
   8:main.c        **** #include "Menu.h"
   9:main.c        **** 
  10:main.c        **** uint8_t ledr=0;
  11:main.c        **** uint8_t ledb=0;
  12:main.c        **** void sendData(uint32_t data){
  15               		.loc 1 12 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  13:main.c        ****     if(ledr)data|=LEDR;
  22               		.loc 1 13 0
  23 0000 2091 0000 		lds r18,ledr
  24 0004 2111      		cpse r18,__zero_reg__
  25               		.loc 1 13 0 is_stmt 0 discriminator 1
  26 0006 7860      		ori r23,8
  27               	.LVL1:
  28               	.L2:
  14:main.c        ****     if(ledb)data|=LEDB;
  29               		.loc 1 14 0 is_stmt 1
  30 0008 2091 0000 		lds r18,ledb
  31 000c 2111      		cpse r18,__zero_reg__
  32               		.loc 1 14 0 is_stmt 0 discriminator 1
  33 000e 7460      		ori r23,4
  34               	.LVL2:
  35               	.L3:
  15:main.c        ****     sendRawData(data);
  36               		.loc 1 15 0 is_stmt 1
  37 0010 00C0      		rjmp sendRawData
  38               	.LVL3:
  39               		.cfi_endproc
  40               	.LFE6:
  42               		.section	.text.startup,"ax",@progbits
  43               	.global	main
  45               	main:
  46               	.LFB7:
  16:main.c        **** }
  17:main.c        **** 
  18:main.c        **** 
  19:main.c        **** volatile uint8_t state=0;
  20:main.c        **** volatile struct Menu* Mcurrent=0;
  21:main.c        **** volatile uint8_t Mindex=0;
  22:main.c        **** Led leds[NBLEDS];
  23:main.c        **** 
  24:main.c        **** int main(void){    
  47               		.loc 1 24 0
  48               		.cfi_startproc
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
  25:main.c        ****     ledInit(leds);
  53               		.loc 1 25 0
  54 0000 80E0      		ldi r24,lo8(leds)
  55 0002 90E0      		ldi r25,hi8(leds)
  56 0004 00D0      		rcall ledInit
  57               	.LVL4:
  26:main.c        ****     
  27:main.c        ****     TIMSK1|=(1<<TOIE1);
  58               		.loc 1 27 0
  59 0006 609A      		sbi 0xc,0
  28:main.c        ****     TIMSK0|=(1<<TOIE0);
  60               		.loc 1 28 0
  61 0008 89B7      		in r24,0x39
  62 000a 8160      		ori r24,lo8(1)
  63 000c 89BF      		out 0x39,r24
  29:main.c        ****     sei();
  64               		.loc 1 29 0
  65               	/* #APP */
  66               	 ;  29 "main.c" 1
  67 000e 7894      		sei
  68               	 ;  0 "" 2
  30:main.c        ****     
  31:main.c        ****     sendData(0b11111100001111111111);//white
  69               		.loc 1 31 0
  70               	/* #NOAPP */
  71 0010 6FEF      		ldi r22,lo8(-1)
  72 0012 73EC      		ldi r23,lo8(-61)
  73 0014 8FE0      		ldi r24,lo8(15)
  74 0016 90E0      		ldi r25,0
  75 0018 00D0      		rcall sendData
  76               	.LVL5:
  77               	.LBB16:
  78               	.LBB17:
  79               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  80               		.loc 2 187 0
  81 001a 2FEF      		ldi r18,lo8(1599999)
  82 001c 89E6      		ldi r24,hi8(1599999)
  83 001e 98E1      		ldi r25,hlo8(1599999)
  84 0020 2150      	1:	subi r18,1
  85 0022 8040      		sbci r24,0
  86 0024 9040      		sbci r25,0
  87 0026 01F4      		brne 1b
  88 0028 00C0      		rjmp .
  89 002a 0000      		nop
  90               	.LVL6:
  91               	.LBE17:
  92               	.LBE16:
  32:main.c        ****     _delay_ms(500);
  33:main.c        ****     sendData(0b11000000001111111111);//green
  93               		.loc 1 33 0
  94 002c 6FEF      		ldi r22,lo8(-1)
  95 002e 73E0      		ldi r23,lo8(3)
  96 0030 8CE0      		ldi r24,lo8(12)
  97 0032 90E0      		ldi r25,0
  98 0034 00D0      		rcall sendData
  99               	.LVL7:
 100               	.LBB18:
 101               	.LBB19:
 102               		.loc 2 187 0
 103 0036 2FEF      		ldi r18,lo8(1599999)
 104 0038 89E6      		ldi r24,hi8(1599999)
 105 003a 98E1      		ldi r25,hlo8(1599999)
 106 003c 2150      	1:	subi r18,1
 107 003e 8040      		sbci r24,0
 108 0040 9040      		sbci r25,0
 109 0042 01F4      		brne 1b
 110 0044 00C0      		rjmp .
 111 0046 0000      		nop
 112               	.LVL8:
 113               	.LBE19:
 114               	.LBE18:
  34:main.c        ****     _delay_ms(500);
  35:main.c        ****     sendData(0b00001100001111111111);//red
 115               		.loc 1 35 0
 116 0048 6FEF      		ldi r22,lo8(-1)
 117 004a 73EC      		ldi r23,lo8(-61)
 118 004c 80E0      		ldi r24,0
 119 004e 90E0      		ldi r25,0
 120 0050 00D0      		rcall sendData
 121               	.LVL9:
 122               	.LBB20:
 123               	.LBB21:
 124               		.loc 2 187 0
 125 0052 2FEF      		ldi r18,lo8(1599999)
 126 0054 89E6      		ldi r24,hi8(1599999)
 127 0056 98E1      		ldi r25,hlo8(1599999)
 128 0058 2150      	1:	subi r18,1
 129 005a 8040      		sbci r24,0
 130 005c 9040      		sbci r25,0
 131 005e 01F4      		brne 1b
 132 0060 00C0      		rjmp .
 133 0062 0000      		nop
 134               	.LVL10:
 135               	.LBE21:
 136               	.LBE20:
  36:main.c        ****     _delay_ms(500);
  37:main.c        ****     sendData(0b00110000001111111111);//blue
 137               		.loc 1 37 0
 138 0064 6FEF      		ldi r22,lo8(-1)
 139 0066 73E0      		ldi r23,lo8(3)
 140 0068 83E0      		ldi r24,lo8(3)
 141 006a 90E0      		ldi r25,0
 142 006c 00D0      		rcall sendData
 143               	.LVL11:
 144               	.LBB22:
 145               	.LBB23:
 146               		.loc 2 187 0
 147 006e 2FEF      		ldi r18,lo8(1599999)
 148 0070 89E6      		ldi r24,hi8(1599999)
 149 0072 98E1      		ldi r25,hlo8(1599999)
 150 0074 2150      	1:	subi r18,1
 151 0076 8040      		sbci r24,0
 152 0078 9040      		sbci r25,0
 153 007a 01F4      		brne 1b
 154 007c 00C0      		rjmp .
 155 007e 0000      		nop
 156               	.LVL12:
 157               	.LBE23:
 158               	.LBE22:
  38:main.c        ****     _delay_ms(500);
  39:main.c        ****     sendData(0b11110000001111111111);//cyan
 159               		.loc 1 39 0
 160 0080 6FEF      		ldi r22,lo8(-1)
 161 0082 73E0      		ldi r23,lo8(3)
 162 0084 8FE0      		ldi r24,lo8(15)
 163 0086 90E0      		ldi r25,0
 164 0088 00D0      		rcall sendData
 165               	.LVL13:
 166               	.LBB24:
 167               	.LBB25:
 168               		.loc 2 187 0
 169 008a 2FEF      		ldi r18,lo8(1599999)
 170 008c 89E6      		ldi r24,hi8(1599999)
 171 008e 98E1      		ldi r25,hlo8(1599999)
 172 0090 2150      	1:	subi r18,1
 173 0092 8040      		sbci r24,0
 174 0094 9040      		sbci r25,0
 175 0096 01F4      		brne 1b
 176 0098 00C0      		rjmp .
 177 009a 0000      		nop
 178               	.LVL14:
 179               	.LBE25:
 180               	.LBE24:
  40:main.c        ****     _delay_ms(500);
  41:main.c        ****     sendData(0b00111100001111111111);//magenta
 181               		.loc 1 41 0
 182 009c 6FEF      		ldi r22,lo8(-1)
 183 009e 73EC      		ldi r23,lo8(-61)
 184 00a0 83E0      		ldi r24,lo8(3)
 185 00a2 90E0      		ldi r25,0
 186 00a4 00D0      		rcall sendData
 187               	.LVL15:
 188               	.LBB26:
 189               	.LBB27:
 190               		.loc 2 187 0
 191 00a6 2FEF      		ldi r18,lo8(1599999)
 192 00a8 89E6      		ldi r24,hi8(1599999)
 193 00aa 98E1      		ldi r25,hlo8(1599999)
 194 00ac 2150      	1:	subi r18,1
 195 00ae 8040      		sbci r24,0
 196 00b0 9040      		sbci r25,0
 197 00b2 01F4      		brne 1b
 198 00b4 00C0      		rjmp .
 199 00b6 0000      		nop
 200               	.LVL16:
 201               	.LBE27:
 202               	.LBE26:
  42:main.c        ****     _delay_ms(500);
  43:main.c        ****     sendData(0b11001100001111111111);//yellow
 203               		.loc 1 43 0
 204 00b8 6FEF      		ldi r22,lo8(-1)
 205 00ba 73EC      		ldi r23,lo8(-61)
 206 00bc 8CE0      		ldi r24,lo8(12)
 207 00be 90E0      		ldi r25,0
 208 00c0 00D0      		rcall sendData
 209               	.LVL17:
 210               	.LBB28:
 211               	.LBB29:
 212               		.loc 2 187 0
 213 00c2 2FEF      		ldi r18,lo8(1599999)
 214 00c4 89E6      		ldi r24,hi8(1599999)
 215 00c6 98E1      		ldi r25,hlo8(1599999)
 216 00c8 2150      	1:	subi r18,1
 217 00ca 8040      		sbci r24,0
 218 00cc 9040      		sbci r25,0
 219 00ce 01F4      		brne 1b
 220 00d0 00C0      		rjmp .
 221 00d2 0000      		nop
 222               	.LVL18:
 223               	.LBE29:
 224               	.LBE28:
  44:main.c        ****     _delay_ms(500);
  45:main.c        ****     
  46:main.c        ****     #ifdef DELLONG
  47:main.c        ****     TCCR1B|=(1<<CS12)|(1<<CS10);
 225               		.loc 1 47 0
 226 00d4 8EB5      		in r24,0x2e
 227 00d6 8560      		ori r24,lo8(5)
 228 00d8 8EBD      		out 0x2e,r24
  48:main.c        ****     #else
  49:main.c        ****     TCCR1B|=(1<<CS12);//|(1<<CS10);
  50:main.c        ****     #endif
  51:main.c        ****     
  52:main.c        ****     TCCR0B|=(1<<CS01)|(1<<CS00);
 229               		.loc 1 52 0
 230 00da 83B7      		in r24,0x33
 231 00dc 8360      		ori r24,lo8(3)
 232 00de 83BF      		out 0x33,r24
  53:main.c        ****     
  54:main.c        ****     currentColor=tcolorV(WHITE);
 233               		.loc 1 54 0
 234 00e0 6FEF      		ldi r22,lo8(-1)
 235 00e2 7FEF      		ldi r23,lo8(-1)
 236 00e4 8FEF      		ldi r24,lo8(-1)
 237 00e6 90E0      		ldi r25,0
 238 00e8 00D0      		rcall tcolorV
 239               	.LVL19:
 240 00ea 6093 0000 		sts currentColor,r22
 241 00ee 7093 0000 		sts currentColor+1,r23
 242 00f2 8093 0000 		sts currentColor+2,r24
  55:main.c        ****     //setCurrentTime(0,10,7,12);
  56:main.c        ****    // //RTC_setTime(currentTime,6,18);
  57:main.c        ****     RTC_readTime(&currentTime);
 243               		.loc 1 57 0
 244 00f6 80E0      		ldi r24,lo8(currentTime)
 245 00f8 90E0      		ldi r25,hi8(currentTime)
 246 00fa 00D0      		rcall RTC_readTime
 247               	.LVL20:
  58:main.c        ****     setLeds(currentTime,leds,currentColor);
 248               		.loc 1 58 0
 249 00fc E090 0000 		lds r14,currentColor
 250 0100 F090 0000 		lds r15,currentColor+1
 251 0104 0091 0000 		lds r16,currentColor+2
 252 0108 20E0      		ldi r18,lo8(leds)
 253 010a 30E0      		ldi r19,hi8(leds)
 254 010c 4091 0000 		lds r20,currentTime
 255 0110 5091 0000 		lds r21,currentTime+1
 256 0114 6091 0000 		lds r22,currentTime+2
 257 0118 7091 0000 		lds r23,currentTime+3
 258 011c 8091 0000 		lds r24,currentTime+4
 259 0120 00D0      		rcall setLeds
 260               	.LVL21:
 261               	.L12:
 262 0122 00C0      		rjmp .L12
 263               		.cfi_endproc
 264               	.LFE7:
 266               		.text
 267               	.global	__vector_8
 269               	__vector_8:
 270               	.LFB8:
  59:main.c        ****     //setLedsNb(currentTime.temp,leds,currentColor);
  60:main.c        ****     while(1){
  61:main.c        ****         
  62:main.c        ****     }
  63:main.c        ****     return(0);
  64:main.c        ****     
  65:main.c        **** }
  66:main.c        **** ISR( TIM1_OVF_vect ){
 271               		.loc 1 66 0
 272               		.cfi_startproc
 273 0012 1F92      		push r1
 274               	.LCFI0:
 275               		.cfi_def_cfa_offset 3
 276               		.cfi_offset 1, -2
 277 0014 0F92      		push r0
 278               	.LCFI1:
 279               		.cfi_def_cfa_offset 4
 280               		.cfi_offset 0, -3
 281 0016 0FB6      		in r0,__SREG__
 282 0018 0F92      		push r0
 283 001a 1124      		clr __zero_reg__
 284 001c CF92      		push r12
 285               	.LCFI2:
 286               		.cfi_def_cfa_offset 5
 287               		.cfi_offset 12, -4
 288 001e DF92      		push r13
 289               	.LCFI3:
 290               		.cfi_def_cfa_offset 6
 291               		.cfi_offset 13, -5
 292 0020 EF92      		push r14
 293               	.LCFI4:
 294               		.cfi_def_cfa_offset 7
 295               		.cfi_offset 14, -6
 296 0022 FF92      		push r15
 297               	.LCFI5:
 298               		.cfi_def_cfa_offset 8
 299               		.cfi_offset 15, -7
 300 0024 0F93      		push r16
 301               	.LCFI6:
 302               		.cfi_def_cfa_offset 9
 303               		.cfi_offset 16, -8
 304 0026 2F93      		push r18
 305               	.LCFI7:
 306               		.cfi_def_cfa_offset 10
 307               		.cfi_offset 18, -9
 308 0028 3F93      		push r19
 309               	.LCFI8:
 310               		.cfi_def_cfa_offset 11
 311               		.cfi_offset 19, -10
 312 002a 4F93      		push r20
 313               	.LCFI9:
 314               		.cfi_def_cfa_offset 12
 315               		.cfi_offset 20, -11
 316 002c 5F93      		push r21
 317               	.LCFI10:
 318               		.cfi_def_cfa_offset 13
 319               		.cfi_offset 21, -12
 320 002e 6F93      		push r22
 321               	.LCFI11:
 322               		.cfi_def_cfa_offset 14
 323               		.cfi_offset 22, -13
 324 0030 7F93      		push r23
 325               	.LCFI12:
 326               		.cfi_def_cfa_offset 15
 327               		.cfi_offset 23, -14
 328 0032 8F93      		push r24
 329               	.LCFI13:
 330               		.cfi_def_cfa_offset 16
 331               		.cfi_offset 24, -15
 332 0034 9F93      		push r25
 333               	.LCFI14:
 334               		.cfi_def_cfa_offset 17
 335               		.cfi_offset 25, -16
 336 0036 AF93      		push r26
 337               	.LCFI15:
 338               		.cfi_def_cfa_offset 18
 339               		.cfi_offset 26, -17
 340 0038 BF93      		push r27
 341               	.LCFI16:
 342               		.cfi_def_cfa_offset 19
 343               		.cfi_offset 27, -18
 344 003a EF93      		push r30
 345               	.LCFI17:
 346               		.cfi_def_cfa_offset 20
 347               		.cfi_offset 30, -19
 348 003c FF93      		push r31
 349               	.LCFI18:
 350               		.cfi_def_cfa_offset 21
 351               		.cfi_offset 31, -20
 352               	/* prologue: Signal */
 353               	/* frame size = 0 */
 354               	/* stack size = 20 */
 355               	.L__stack_usage = 20
  67:main.c        ****     ledr=!ledr;
 356               		.loc 1 67 0
 357 003e 8091 0000 		lds r24,ledr
 358 0042 91E0      		ldi r25,lo8(1)
 359 0044 8111      		cpse r24,__zero_reg__
 360 0046 90E0      		ldi r25,0
 361               	.L14:
 362 0048 9093 0000 		sts ledr,r25
  68:main.c        ****     if(ledr){
 363               		.loc 1 68 0
 364 004c 8111      		cpse r24,__zero_reg__
 365 004e 00C0      		rjmp .L15
  69:main.c        ****         RTC_readTime(&currentTime);
 366               		.loc 1 69 0
 367 0050 80E0      		ldi r24,lo8(currentTime)
 368 0052 90E0      		ldi r25,hi8(currentTime)
 369 0054 00D0      		rcall RTC_readTime
 370               	.LVL22:
  70:main.c        ****         setLeds(currentTime,leds,tcolorV(YELLOW));
 371               		.loc 1 70 0
 372 0056 60E0      		ldi r22,0
 373 0058 7FEF      		ldi r23,lo8(-1)
 374 005a 8FEF      		ldi r24,lo8(-1)
 375 005c 90E0      		ldi r25,0
 376 005e 00D0      		rcall tcolorV
 377               	.LVL23:
 378 0060 7B01      		movw r14,r22
 379 0062 082F      		mov r16,r24
 380 0064 20E0      		ldi r18,lo8(leds)
 381 0066 30E0      		ldi r19,hi8(leds)
 382 0068 4091 0000 		lds r20,currentTime
 383 006c 5091 0000 		lds r21,currentTime+1
 384 0070 6091 0000 		lds r22,currentTime+2
 385 0074 7091 0000 		lds r23,currentTime+3
 386 0078 8091 0000 		lds r24,currentTime+4
 387 007c 00D0      		rcall setLeds
 388               	.LVL24:
 389 007e 00C0      		rjmp .L13
 390               	.L15:
  71:main.c        ****     }else{
  72:main.c        ****         setLedsNb(RTC_readTemp(),leds,tcolorV(CYAN));
 391               		.loc 1 72 0
 392 0080 6FEF      		ldi r22,lo8(-1)
 393 0082 7FEF      		ldi r23,lo8(-1)
 394 0084 80E0      		ldi r24,0
 395 0086 90E0      		ldi r25,0
 396 0088 00D0      		rcall tcolorV
 397               	.LVL25:
 398 008a 6B01      		movw r12,r22
 399 008c E82E      		mov r14,r24
 400 008e 00D0      		rcall RTC_readTemp
 401               	.LVL26:
 402 0090 4E2D      		mov r20,r14
 403 0092 9601      		movw r18,r12
 404 0094 60E0      		ldi r22,lo8(leds)
 405 0096 70E0      		ldi r23,hi8(leds)
 406 0098 00D0      		rcall setLedsNb
 407               	.LVL27:
 408               	.L13:
 409               	/* epilogue start */
  73:main.c        ****     }
  74:main.c        ****     
  75:main.c        **** }
 410               		.loc 1 75 0
 411 009a FF91      		pop r31
 412 009c EF91      		pop r30
 413 009e BF91      		pop r27
 414 00a0 AF91      		pop r26
 415 00a2 9F91      		pop r25
 416 00a4 8F91      		pop r24
 417 00a6 7F91      		pop r23
 418 00a8 6F91      		pop r22
 419 00aa 5F91      		pop r21
 420 00ac 4F91      		pop r20
 421 00ae 3F91      		pop r19
 422 00b0 2F91      		pop r18
 423 00b2 0F91      		pop r16
 424 00b4 FF90      		pop r15
 425 00b6 EF90      		pop r14
 426 00b8 DF90      		pop r13
 427 00ba CF90      		pop r12
 428 00bc 0F90      		pop r0
 429 00be 0FBE      		out __SREG__,r0
 430 00c0 0F90      		pop r0
 431 00c2 1F90      		pop r1
 432 00c4 1895      		reti
 433               		.cfi_endproc
 434               	.LFE8:
 436               	.global	__vector_11
 438               	__vector_11:
 439               	.LFB9:
  76:main.c        **** ISR( TIM0_OVF_vect ){
 440               		.loc 1 76 0
 441               		.cfi_startproc
 442 00c6 1F92      		push r1
 443               	.LCFI19:
 444               		.cfi_def_cfa_offset 3
 445               		.cfi_offset 1, -2
 446 00c8 0F92      		push r0
 447               	.LCFI20:
 448               		.cfi_def_cfa_offset 4
 449               		.cfi_offset 0, -3
 450 00ca 0FB6      		in r0,__SREG__
 451 00cc 0F92      		push r0
 452 00ce 1124      		clr __zero_reg__
 453 00d0 2F93      		push r18
 454               	.LCFI21:
 455               		.cfi_def_cfa_offset 5
 456               		.cfi_offset 18, -4
 457 00d2 3F93      		push r19
 458               	.LCFI22:
 459               		.cfi_def_cfa_offset 6
 460               		.cfi_offset 19, -5
 461 00d4 4F93      		push r20
 462               	.LCFI23:
 463               		.cfi_def_cfa_offset 7
 464               		.cfi_offset 20, -6
 465 00d6 5F93      		push r21
 466               	.LCFI24:
 467               		.cfi_def_cfa_offset 8
 468               		.cfi_offset 21, -7
 469 00d8 6F93      		push r22
 470               	.LCFI25:
 471               		.cfi_def_cfa_offset 9
 472               		.cfi_offset 22, -8
 473 00da 7F93      		push r23
 474               	.LCFI26:
 475               		.cfi_def_cfa_offset 10
 476               		.cfi_offset 23, -9
 477 00dc 8F93      		push r24
 478               	.LCFI27:
 479               		.cfi_def_cfa_offset 11
 480               		.cfi_offset 24, -10
 481 00de 9F93      		push r25
 482               	.LCFI28:
 483               		.cfi_def_cfa_offset 12
 484               		.cfi_offset 25, -11
 485 00e0 AF93      		push r26
 486               	.LCFI29:
 487               		.cfi_def_cfa_offset 13
 488               		.cfi_offset 26, -12
 489 00e2 BF93      		push r27
 490               	.LCFI30:
 491               		.cfi_def_cfa_offset 14
 492               		.cfi_offset 27, -13
 493 00e4 EF93      		push r30
 494               	.LCFI31:
 495               		.cfi_def_cfa_offset 15
 496               		.cfi_offset 30, -14
 497 00e6 FF93      		push r31
 498               	.LCFI32:
 499               		.cfi_def_cfa_offset 16
 500               		.cfi_offset 31, -15
 501               	/* prologue: Signal */
 502               	/* frame size = 0 */
 503               	/* stack size = 15 */
 504               	.L__stack_usage = 15
  77:main.c        ****     switch(state){
 505               		.loc 1 77 0
 506 00e8 8091 0000 		lds r24,state
 507 00ec 8230      		cpi r24,lo8(2)
 508 00ee 01F0      		breq .L22
 509 00f0 00F4      		brsh .L23
 510 00f2 8823      		tst r24
 511 00f4 01F0      		breq .L24
 512 00f6 8130      		cpi r24,lo8(1)
 513 00f8 01F0      		breq .+2
 514 00fa 00C0      		rjmp .L21
  78:main.c        ****         case 0:
  79:main.c        ****             sendData(R2 | getDataByColor(tcolor(1,0,0),0,leds));
  80:main.c        ****             break;
  81:main.c        ****         case 1:
  82:main.c        ****             sendData(R1 | getDataByColor(tcolor(1,0,0),1,leds));
 515               		.loc 1 82 0
 516 00fc 40E0      		ldi r20,0
 517 00fe 60E0      		ldi r22,0
 518 0100 81E0      		ldi r24,lo8(1)
 519 0102 00D0      		rcall tcolor
 520               	.LVL28:
 521 0104 20E0      		ldi r18,lo8(leds)
 522 0106 30E0      		ldi r19,hi8(leds)
 523 0108 41E0      		ldi r20,lo8(1)
 524 010a 00D0      		rcall getDataByColor
 525               	.LVL29:
 526 010c 7068      		ori r23,128
 527 010e 00C0      		rjmp .L30
 528               	.L23:
  77:main.c        ****     switch(state){
 529               		.loc 1 77 0
 530 0110 8430      		cpi r24,lo8(4)
 531 0112 01F0      		breq .L26
 532 0114 00F0      		brlo .L27
 533 0116 8530      		cpi r24,lo8(5)
 534 0118 01F4      		brne .L21
  83:main.c        ****             break;
  84:main.c        ****         case 2:
  85:main.c        ****             sendData(G2 | getDataByColor(tcolor(0,1,0),0,leds));
  86:main.c        ****             break;
  87:main.c        ****         case 3:
  88:main.c        ****             sendData(G1 | getDataByColor(tcolor(0,1,0),1,leds));
  89:main.c        ****             break;
  90:main.c        ****         case 4:
  91:main.c        ****             sendData(B2 | getDataByColor(tcolor(0,0,1),0,leds));
  92:main.c        ****             break;
  93:main.c        ****         case 5:
  94:main.c        ****             sendData(B1 | getDataByColor(tcolor(0,0,1),1,leds));
 535               		.loc 1 94 0
 536 011a 41E0      		ldi r20,lo8(1)
 537 011c 60E0      		ldi r22,0
 538 011e 80E0      		ldi r24,0
 539 0120 00D0      		rcall tcolor
 540               	.LVL30:
 541 0122 20E0      		ldi r18,lo8(leds)
 542 0124 30E0      		ldi r19,hi8(leds)
 543 0126 41E0      		ldi r20,lo8(1)
 544 0128 00D0      		rcall getDataByColor
 545               	.LVL31:
 546 012a 8260      		ori r24,2
 547 012c 00C0      		rjmp .L30
 548               	.L24:
  79:main.c        ****             break;
 549               		.loc 1 79 0
 550 012e 40E0      		ldi r20,0
 551 0130 60E0      		ldi r22,0
 552 0132 81E0      		ldi r24,lo8(1)
 553 0134 00D0      		rcall tcolor
 554               	.LVL32:
 555 0136 20E0      		ldi r18,lo8(leds)
 556 0138 30E0      		ldi r19,hi8(leds)
 557 013a 40E0      		ldi r20,0
 558 013c 00D0      		rcall getDataByColor
 559               	.LVL33:
 560 013e 7064      		ori r23,64
 561 0140 00C0      		rjmp .L30
 562               	.L22:
  85:main.c        ****             break;
 563               		.loc 1 85 0
 564 0142 40E0      		ldi r20,0
 565 0144 61E0      		ldi r22,lo8(1)
 566 0146 80E0      		ldi r24,0
 567 0148 00D0      		rcall tcolor
 568               	.LVL34:
 569 014a 20E0      		ldi r18,lo8(leds)
 570 014c 30E0      		ldi r19,hi8(leds)
 571 014e 40E0      		ldi r20,0
 572 0150 00D0      		rcall getDataByColor
 573               	.LVL35:
 574 0152 8460      		ori r24,4
 575 0154 00C0      		rjmp .L30
 576               	.L27:
  88:main.c        ****             break;
 577               		.loc 1 88 0
 578 0156 40E0      		ldi r20,0
 579 0158 61E0      		ldi r22,lo8(1)
 580 015a 80E0      		ldi r24,0
 581 015c 00D0      		rcall tcolor
 582               	.LVL36:
 583 015e 20E0      		ldi r18,lo8(leds)
 584 0160 30E0      		ldi r19,hi8(leds)
 585 0162 41E0      		ldi r20,lo8(1)
 586 0164 00D0      		rcall getDataByColor
 587               	.LVL37:
 588 0166 8860      		ori r24,8
 589 0168 00C0      		rjmp .L30
 590               	.L26:
  91:main.c        ****             break;
 591               		.loc 1 91 0
 592 016a 41E0      		ldi r20,lo8(1)
 593 016c 60E0      		ldi r22,0
 594 016e 80E0      		ldi r24,0
 595 0170 00D0      		rcall tcolor
 596               	.LVL38:
 597 0172 20E0      		ldi r18,lo8(leds)
 598 0174 30E0      		ldi r19,hi8(leds)
 599 0176 40E0      		ldi r20,0
 600 0178 00D0      		rcall getDataByColor
 601               	.LVL39:
 602 017a 8160      		ori r24,1
 603               	.L30:
 604               		.loc 1 94 0
 605 017c 00D0      		rcall sendData
 606               	.LVL40:
 607               	.L21:
  95:main.c        ****             break;
  96:main.c        ****     }
  97:main.c        ****     state++;
 608               		.loc 1 97 0
 609 017e 8091 0000 		lds r24,state
 610 0182 8F5F      		subi r24,lo8(-(1))
 611 0184 8093 0000 		sts state,r24
  98:main.c        ****     if(state>5)state=0;
 612               		.loc 1 98 0
 613 0188 8091 0000 		lds r24,state
 614 018c 8630      		cpi r24,lo8(6)
 615 018e 00F0      		brlo .L20
 616               		.loc 1 98 0 is_stmt 0 discriminator 1
 617 0190 1092 0000 		sts state,__zero_reg__
 618               	.L20:
 619               	/* epilogue start */
  99:main.c        **** }
 620               		.loc 1 99 0 is_stmt 1
 621 0194 FF91      		pop r31
 622 0196 EF91      		pop r30
 623 0198 BF91      		pop r27
 624 019a AF91      		pop r26
 625 019c 9F91      		pop r25
 626 019e 8F91      		pop r24
 627 01a0 7F91      		pop r23
 628 01a2 6F91      		pop r22
 629 01a4 5F91      		pop r21
 630 01a6 4F91      		pop r20
 631 01a8 3F91      		pop r19
 632 01aa 2F91      		pop r18
 633 01ac 0F90      		pop r0
 634 01ae 0FBE      		out __SREG__,r0
 635 01b0 0F90      		pop r0
 636 01b2 1F90      		pop r1
 637 01b4 1895      		reti
 638               		.cfi_endproc
 639               	.LFE9:
 641               		.comm	leds,95,1
 642               	.global	Mindex
 643               		.section .bss
 646               	Mindex:
 647 0000 00        		.zero	1
 648               	.global	Mcurrent
 651               	Mcurrent:
 652 0001 0000      		.zero	2
 653               	.global	state
 656               	state:
 657 0003 00        		.zero	1
 658               	.global	ledb
 661               	ledb:
 662 0004 00        		.zero	1
 663               	.global	ledr
 666               	ledr:
 667 0005 00        		.zero	1
 668               		.comm	M1rainbow,3,1
 669               		.comm	M1reset,3,1
 670               		.comm	M1eventMode,3,1
 671               		.comm	M2setminpm,3,1
 672               		.comm	M2setminam,3,1
 673               		.comm	M2sethourpm,3,1
 674               		.comm	M2sethouram,3,1
 675               		.comm	M1setTime,3,1
 676               		.comm	M3onhour,3,1
 677               		.comm	M2offhour,3,1
 678               		.comm	M1nightmode,3,1
 679               		.comm	M1cmode,3,1
 680               		.comm	M1mode,3,1
 681               		.comm	M0main,3,1
 682               		.comm	currentColor,3,1
 683               		.comm	USI_I2C_Master_State,1,1
 684               		.comm	currentTime,5,1
 685               		.text
 686               	.Letext0:
 687               		.file 3 "/usr/lib/avr/include/stdint.h"
 688               		.file 4 "RTC.h"
 689               		.file 5 "Led.h"
 690               		.file 6 "Menu.h"
 691               		.file 7 "defines.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccjNTI7B.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccjNTI7B.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccjNTI7B.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccjNTI7B.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccjNTI7B.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccjNTI7B.s:12     .text:0000000000000000 sendData
     /tmp/ccjNTI7B.s:666    .bss:0000000000000005 ledr
     /tmp/ccjNTI7B.s:661    .bss:0000000000000004 ledb
     /tmp/ccjNTI7B.s:45     .text.startup:0000000000000000 main
                            *COM*:000000000000005f leds
                            *COM*:0000000000000003 currentColor
                            *COM*:0000000000000005 currentTime
     /tmp/ccjNTI7B.s:269    .text:0000000000000012 __vector_8
     /tmp/ccjNTI7B.s:438    .text:00000000000000c6 __vector_11
     /tmp/ccjNTI7B.s:656    .bss:0000000000000003 state
     /tmp/ccjNTI7B.s:646    .bss:0000000000000000 Mindex
     /tmp/ccjNTI7B.s:651    .bss:0000000000000001 Mcurrent
                            *COM*:0000000000000003 M1rainbow
                            *COM*:0000000000000003 M1reset
                            *COM*:0000000000000003 M1eventMode
                            *COM*:0000000000000003 M2setminpm
                            *COM*:0000000000000003 M2setminam
                            *COM*:0000000000000003 M2sethourpm
                            *COM*:0000000000000003 M2sethouram
                            *COM*:0000000000000003 M1setTime
                            *COM*:0000000000000003 M3onhour
                            *COM*:0000000000000003 M2offhour
                            *COM*:0000000000000003 M1nightmode
                            *COM*:0000000000000003 M1cmode
                            *COM*:0000000000000003 M1mode
                            *COM*:0000000000000003 M0main
                            *COM*:0000000000000001 USI_I2C_Master_State

UNDEFINED SYMBOLS
sendRawData
ledInit
tcolorV
RTC_readTime
setLeds
RTC_readTemp
setLedsNb
tcolor
getDataByColor
__do_clear_bss
