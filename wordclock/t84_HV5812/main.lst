   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	sendData
  12               	sendData:
  13               	.LFB6:
  14               		.file 1 "main.c"
   1:main.c        **** #define F_CPU 16000000UL
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** #include <util/delay.h>
   5:main.c        **** #include "defines.h"
   6:main.c        **** #include "Led.h"
   7:main.c        **** #include "RTC.h"
   8:main.c        **** #include "Menu.h"
   9:main.c        **** 
  10:main.c        **** uint8_t ledr=0;
  11:main.c        **** uint8_t ledb=0;
  12:main.c        **** 
  13:main.c        **** void sendData(uint32_t data){
  15               		.loc 1 13 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  14:main.c        ****     if(ledr)data|=LEDR;
  22               		.loc 1 14 0
  23 0000 2091 0000 		lds r18,ledr
  24 0004 2111      		cpse r18,__zero_reg__
  25               		.loc 1 14 0 is_stmt 0 discriminator 1
  26 0006 7860      		ori r23,8
  27               	.LVL1:
  28               	.L2:
  15:main.c        ****     if(ledb)data|=LEDB;
  29               		.loc 1 15 0 is_stmt 1
  30 0008 2091 0000 		lds r18,ledb
  31 000c 2111      		cpse r18,__zero_reg__
  32               		.loc 1 15 0 is_stmt 0 discriminator 1
  33 000e 7460      		ori r23,4
  34               	.LVL2:
  35               	.L3:
  16:main.c        ****     sendRawData(data);
  36               		.loc 1 16 0 is_stmt 1
  37 0010 00C0      		rjmp sendRawData
  38               	.LVL3:
  39               		.cfi_endproc
  40               	.LFE6:
  42               		.section	.text.startup,"ax",@progbits
  43               	.global	main
  45               	main:
  46               	.LFB7:
  17:main.c        **** }
  18:main.c        **** 
  19:main.c        **** 
  20:main.c        **** volatile uint8_t state=0;
  21:main.c        **** const Menu* Mcurrent=0;
  22:main.c        **** uint8_t Mindex=0;
  23:main.c        **** Led leds[NBLEDS];
  24:main.c        **** 
  25:main.c        **** int main(void){    
  47               		.loc 1 25 0
  48               		.cfi_startproc
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
  26:main.c        ****     ledInit(leds);
  53               		.loc 1 26 0
  54 0000 80E0      		ldi r24,lo8(leds)
  55 0002 90E0      		ldi r25,hi8(leds)
  56 0004 00D0      		rcall ledInit
  57               	.LVL4:
  27:main.c        ****     DDRA&=~(BTNINTERNAL|BTNOK);
  58               		.loc 1 27 0
  59 0006 8AB3      		in r24,0x1a
  60 0008 8F75      		andi r24,lo8(95)
  61 000a 8ABB      		out 0x1a,r24
  28:main.c        ****     DDRB&=~BTNSELECT;
  62               		.loc 1 28 0
  63 000c BA98      		cbi 0x17,2
  29:main.c        ****     PORTA|=(BTNINTERNAL|BTNOK);
  64               		.loc 1 29 0
  65 000e 8BB3      		in r24,0x1b
  66 0010 806A      		ori r24,lo8(-96)
  67 0012 8BBB      		out 0x1b,r24
  30:main.c        ****     PORTB|=BTNSELECT;
  68               		.loc 1 30 0
  69 0014 C29A      		sbi 0x18,2
  31:main.c        ****     TIMSK1|=(1<<TOIE1);//|(1<<OCIE1B);
  70               		.loc 1 31 0
  71 0016 609A      		sbi 0xc,0
  32:main.c        ****     // OCR1B=32768;
  33:main.c        ****     TIMSK0|=(1<<TOIE0);
  72               		.loc 1 33 0
  73 0018 89B7      		in r24,0x39
  74 001a 8160      		ori r24,lo8(1)
  75 001c 89BF      		out 0x39,r24
  34:main.c        ****     
  35:main.c        ****     sendData(0b11111100001111111111);//white
  76               		.loc 1 35 0
  77 001e 6FEF      		ldi r22,lo8(-1)
  78 0020 73EC      		ldi r23,lo8(-61)
  79 0022 8FE0      		ldi r24,lo8(15)
  80 0024 90E0      		ldi r25,0
  81 0026 00D0      		rcall sendData
  82               	.LVL5:
  83               	.LBB16:
  84               	.LBB17:
  85               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  86               		.loc 2 187 0
  87 0028 2FEF      		ldi r18,lo8(1599999)
  88 002a 89E6      		ldi r24,hi8(1599999)
  89 002c 98E1      		ldi r25,hlo8(1599999)
  90 002e 2150      	1:	subi r18,1
  91 0030 8040      		sbci r24,0
  92 0032 9040      		sbci r25,0
  93 0034 01F4      		brne 1b
  94 0036 00C0      		rjmp .
  95 0038 0000      		nop
  96               	.LVL6:
  97               	.LBE17:
  98               	.LBE16:
  36:main.c        ****     _delay_ms(500);
  37:main.c        ****     sendData(0b11000000001111111111);//green
  99               		.loc 1 37 0
 100 003a 6FEF      		ldi r22,lo8(-1)
 101 003c 73E0      		ldi r23,lo8(3)
 102 003e 8CE0      		ldi r24,lo8(12)
 103 0040 90E0      		ldi r25,0
 104 0042 00D0      		rcall sendData
 105               	.LVL7:
 106               	.LBB18:
 107               	.LBB19:
 108               		.loc 2 187 0
 109 0044 2FEF      		ldi r18,lo8(1599999)
 110 0046 89E6      		ldi r24,hi8(1599999)
 111 0048 98E1      		ldi r25,hlo8(1599999)
 112 004a 2150      	1:	subi r18,1
 113 004c 8040      		sbci r24,0
 114 004e 9040      		sbci r25,0
 115 0050 01F4      		brne 1b
 116 0052 00C0      		rjmp .
 117 0054 0000      		nop
 118               	.LVL8:
 119               	.LBE19:
 120               	.LBE18:
  38:main.c        ****     _delay_ms(500);
  39:main.c        ****     sendData(0b00001100001111111111);//red
 121               		.loc 1 39 0
 122 0056 6FEF      		ldi r22,lo8(-1)
 123 0058 73EC      		ldi r23,lo8(-61)
 124 005a 80E0      		ldi r24,0
 125 005c 90E0      		ldi r25,0
 126 005e 00D0      		rcall sendData
 127               	.LVL9:
 128               	.LBB20:
 129               	.LBB21:
 130               		.loc 2 187 0
 131 0060 2FEF      		ldi r18,lo8(1599999)
 132 0062 89E6      		ldi r24,hi8(1599999)
 133 0064 98E1      		ldi r25,hlo8(1599999)
 134 0066 2150      	1:	subi r18,1
 135 0068 8040      		sbci r24,0
 136 006a 9040      		sbci r25,0
 137 006c 01F4      		brne 1b
 138 006e 00C0      		rjmp .
 139 0070 0000      		nop
 140               	.LVL10:
 141               	.LBE21:
 142               	.LBE20:
  40:main.c        ****     _delay_ms(500);
  41:main.c        ****     sendData(0b00110000001111111111);//blue
 143               		.loc 1 41 0
 144 0072 6FEF      		ldi r22,lo8(-1)
 145 0074 73E0      		ldi r23,lo8(3)
 146 0076 83E0      		ldi r24,lo8(3)
 147 0078 90E0      		ldi r25,0
 148 007a 00D0      		rcall sendData
 149               	.LVL11:
 150               	.LBB22:
 151               	.LBB23:
 152               		.loc 2 187 0
 153 007c 2FEF      		ldi r18,lo8(1599999)
 154 007e 89E6      		ldi r24,hi8(1599999)
 155 0080 98E1      		ldi r25,hlo8(1599999)
 156 0082 2150      	1:	subi r18,1
 157 0084 8040      		sbci r24,0
 158 0086 9040      		sbci r25,0
 159 0088 01F4      		brne 1b
 160 008a 00C0      		rjmp .
 161 008c 0000      		nop
 162               	.LVL12:
 163               	.LBE23:
 164               	.LBE22:
  42:main.c        ****     _delay_ms(500);
  43:main.c        ****     sendData(0b11110000001111111111);//cyan
 165               		.loc 1 43 0
 166 008e 6FEF      		ldi r22,lo8(-1)
 167 0090 73E0      		ldi r23,lo8(3)
 168 0092 8FE0      		ldi r24,lo8(15)
 169 0094 90E0      		ldi r25,0
 170 0096 00D0      		rcall sendData
 171               	.LVL13:
 172               	.LBB24:
 173               	.LBB25:
 174               		.loc 2 187 0
 175 0098 2FEF      		ldi r18,lo8(1599999)
 176 009a 89E6      		ldi r24,hi8(1599999)
 177 009c 98E1      		ldi r25,hlo8(1599999)
 178 009e 2150      	1:	subi r18,1
 179 00a0 8040      		sbci r24,0
 180 00a2 9040      		sbci r25,0
 181 00a4 01F4      		brne 1b
 182 00a6 00C0      		rjmp .
 183 00a8 0000      		nop
 184               	.LVL14:
 185               	.LBE25:
 186               	.LBE24:
  44:main.c        ****     _delay_ms(500);
  45:main.c        ****     sendData(0b00111100001111111111);//magenta
 187               		.loc 1 45 0
 188 00aa 6FEF      		ldi r22,lo8(-1)
 189 00ac 73EC      		ldi r23,lo8(-61)
 190 00ae 83E0      		ldi r24,lo8(3)
 191 00b0 90E0      		ldi r25,0
 192 00b2 00D0      		rcall sendData
 193               	.LVL15:
 194               	.LBB26:
 195               	.LBB27:
 196               		.loc 2 187 0
 197 00b4 2FEF      		ldi r18,lo8(1599999)
 198 00b6 89E6      		ldi r24,hi8(1599999)
 199 00b8 98E1      		ldi r25,hlo8(1599999)
 200 00ba 2150      	1:	subi r18,1
 201 00bc 8040      		sbci r24,0
 202 00be 9040      		sbci r25,0
 203 00c0 01F4      		brne 1b
 204 00c2 00C0      		rjmp .
 205 00c4 0000      		nop
 206               	.LVL16:
 207               	.LBE27:
 208               	.LBE26:
  46:main.c        ****     _delay_ms(500);
  47:main.c        ****     sendData(0b11001100001111111111);//yellow
 209               		.loc 1 47 0
 210 00c6 6FEF      		ldi r22,lo8(-1)
 211 00c8 73EC      		ldi r23,lo8(-61)
 212 00ca 8CE0      		ldi r24,lo8(12)
 213 00cc 90E0      		ldi r25,0
 214 00ce 00D0      		rcall sendData
 215               	.LVL17:
 216               	.LBB28:
 217               	.LBB29:
 218               		.loc 2 187 0
 219 00d0 2FEF      		ldi r18,lo8(1599999)
 220 00d2 89E6      		ldi r24,hi8(1599999)
 221 00d4 98E1      		ldi r25,hlo8(1599999)
 222 00d6 2150      	1:	subi r18,1
 223 00d8 8040      		sbci r24,0
 224 00da 9040      		sbci r25,0
 225 00dc 01F4      		brne 1b
 226 00de 00C0      		rjmp .
 227 00e0 0000      		nop
 228               	.LVL18:
 229               	.LBE29:
 230               	.LBE28:
  48:main.c        ****     _delay_ms(500);
  49:main.c        ****     
  50:main.c        ****     //no sooner to let inputs debounce
  51:main.c        ****     GIMSK|=(1<<PCIE1)|(1<<PCIE0);
 231               		.loc 1 51 0
 232 00e2 8BB7      		in r24,0x3b
 233 00e4 8063      		ori r24,lo8(48)
 234 00e6 8BBF      		out 0x3b,r24
  52:main.c        ****     PCMSK0|=(1<<PCINT7)|(1<<PCINT5);
 235               		.loc 1 52 0
 236 00e8 82B3      		in r24,0x12
 237 00ea 806A      		ori r24,lo8(-96)
 238 00ec 82BB      		out 0x12,r24
  53:main.c        ****     PCMSK1|=(1<<PCINT10);
 239               		.loc 1 53 0
 240 00ee 80B5      		in r24,0x20
 241 00f0 8460      		ori r24,lo8(4)
 242 00f2 80BD      		out 0x20,r24
  54:main.c        ****     sei();
 243               		.loc 1 54 0
 244               	/* #APP */
 245               	 ;  54 "main.c" 1
 246 00f4 7894      		sei
 247               	 ;  0 "" 2
  55:main.c        ****     
  56:main.c        ****     //update time & UI timer
  57:main.c        ****     #ifdef DELLONG
  58:main.c        ****     TCCR1B|=(1<<CS12)|(1<<CS10);
 248               		.loc 1 58 0
 249               	/* #NOAPP */
 250 00f6 8EB5      		in r24,0x2e
 251 00f8 8560      		ori r24,lo8(5)
 252 00fa 8EBD      		out 0x2e,r24
  59:main.c        ****     #else
  60:main.c        ****     TCCR1B|=(1<<CS12);//|(1<<CS10);
  61:main.c        ****     #endif
  62:main.c        ****     
  63:main.c        ****     //led mux timer
  64:main.c        ****     TCCR0B|=(1<<CS01)|(1<<CS00);
 253               		.loc 1 64 0
 254 00fc 83B7      		in r24,0x33
 255 00fe 8360      		ori r24,lo8(3)
 256 0100 83BF      		out 0x33,r24
  65:main.c        ****     
  66:main.c        ****     Minit();
 257               		.loc 1 66 0
 258 0102 00D0      		rcall Minit
 259               	.LVL19:
  67:main.c        ****     // //RTC_setTime(currentTime,6,18);
  68:main.c        ****     RTC_readTime(&currentTime);
 260               		.loc 1 68 0
 261 0104 80E0      		ldi r24,lo8(currentTime)
 262 0106 90E0      		ldi r25,hi8(currentTime)
 263 0108 00D0      		rcall RTC_readTime
 264               	.LVL20:
 265               	.L12:
 266 010a 00C0      		rjmp .L12
 267               		.cfi_endproc
 268               	.LFE7:
 270               		.text
 271               	.global	__vector_3
 273               	__vector_3:
 274               	.LFB8:
  69:main.c        ****     while(1){
  70:main.c        ****     }
  71:main.c        ****     return(0);
  72:main.c        ****     
  73:main.c        **** }
  74:main.c        **** ISR( PCINT1_vect){
 275               		.loc 1 74 0
 276               		.cfi_startproc
 277 0012 1F92      		push r1
 278               	.LCFI0:
 279               		.cfi_def_cfa_offset 3
 280               		.cfi_offset 1, -2
 281 0014 0F92      		push r0
 282               	.LCFI1:
 283               		.cfi_def_cfa_offset 4
 284               		.cfi_offset 0, -3
 285 0016 0FB6      		in r0,__SREG__
 286 0018 0F92      		push r0
 287 001a 1124      		clr __zero_reg__
 288 001c 2F93      		push r18
 289               	.LCFI2:
 290               		.cfi_def_cfa_offset 5
 291               		.cfi_offset 18, -4
 292 001e 3F93      		push r19
 293               	.LCFI3:
 294               		.cfi_def_cfa_offset 6
 295               		.cfi_offset 19, -5
 296 0020 4F93      		push r20
 297               	.LCFI4:
 298               		.cfi_def_cfa_offset 7
 299               		.cfi_offset 20, -6
 300 0022 5F93      		push r21
 301               	.LCFI5:
 302               		.cfi_def_cfa_offset 8
 303               		.cfi_offset 21, -7
 304 0024 6F93      		push r22
 305               	.LCFI6:
 306               		.cfi_def_cfa_offset 9
 307               		.cfi_offset 22, -8
 308 0026 7F93      		push r23
 309               	.LCFI7:
 310               		.cfi_def_cfa_offset 10
 311               		.cfi_offset 23, -9
 312 0028 8F93      		push r24
 313               	.LCFI8:
 314               		.cfi_def_cfa_offset 11
 315               		.cfi_offset 24, -10
 316 002a 9F93      		push r25
 317               	.LCFI9:
 318               		.cfi_def_cfa_offset 12
 319               		.cfi_offset 25, -11
 320 002c AF93      		push r26
 321               	.LCFI10:
 322               		.cfi_def_cfa_offset 13
 323               		.cfi_offset 26, -12
 324 002e BF93      		push r27
 325               	.LCFI11:
 326               		.cfi_def_cfa_offset 14
 327               		.cfi_offset 27, -13
 328 0030 EF93      		push r30
 329               	.LCFI12:
 330               		.cfi_def_cfa_offset 15
 331               		.cfi_offset 30, -14
 332 0032 FF93      		push r31
 333               	.LCFI13:
 334               		.cfi_def_cfa_offset 16
 335               		.cfi_offset 31, -15
 336               	/* prologue: Signal */
 337               	/* frame size = 0 */
 338               	/* stack size = 15 */
 339               	.L__stack_usage = 15
  75:main.c        ****     if(PINB&BTNSELECT && Mcurrent){
 340               		.loc 1 75 0
 341 0034 B29B      		sbis 0x16,2
 342 0036 00C0      		rjmp .L13
 343               		.loc 1 75 0 is_stmt 0 discriminator 1
 344 0038 8091 0000 		lds r24,Mcurrent
 345 003c 9091 0000 		lds r25,Mcurrent+1
 346 0040 0097      		sbiw r24,0
 347 0042 01F0      		breq .L13
  76:main.c        ****         Mindex=findNextEntry(Mcurrent,Mindex);
 348               		.loc 1 76 0 is_stmt 1
 349 0044 6091 0000 		lds r22,Mindex
 350 0048 00D0      		rcall findNextEntry
 351               	.LVL21:
 352 004a 8093 0000 		sts Mindex,r24
  77:main.c        ****         TCNT1=65534;//get straight to led update
 353               		.loc 1 77 0
 354 004e 8EEF      		ldi r24,lo8(-2)
 355 0050 9FEF      		ldi r25,lo8(-1)
 356 0052 9DBD      		out 0x2c+1,r25
 357 0054 8CBD      		out 0x2c,r24
 358               	.L13:
 359               	/* epilogue start */
  78:main.c        ****     }
  79:main.c        **** }
 360               		.loc 1 79 0
 361 0056 FF91      		pop r31
 362 0058 EF91      		pop r30
 363 005a BF91      		pop r27
 364 005c AF91      		pop r26
 365 005e 9F91      		pop r25
 366 0060 8F91      		pop r24
 367 0062 7F91      		pop r23
 368 0064 6F91      		pop r22
 369 0066 5F91      		pop r21
 370 0068 4F91      		pop r20
 371 006a 3F91      		pop r19
 372 006c 2F91      		pop r18
 373 006e 0F90      		pop r0
 374 0070 0FBE      		out __SREG__,r0
 375 0072 0F90      		pop r0
 376 0074 1F90      		pop r1
 377 0076 1895      		reti
 378               		.cfi_endproc
 379               	.LFE8:
 381               	.global	__vector_2
 383               	__vector_2:
 384               	.LFB9:
  80:main.c        **** ISR( PCINT0_vect){
 385               		.loc 1 80 0
 386               		.cfi_startproc
 387 0078 1F92      		push r1
 388               	.LCFI14:
 389               		.cfi_def_cfa_offset 3
 390               		.cfi_offset 1, -2
 391 007a 0F92      		push r0
 392               	.LCFI15:
 393               		.cfi_def_cfa_offset 4
 394               		.cfi_offset 0, -3
 395 007c 0FB6      		in r0,__SREG__
 396 007e 0F92      		push r0
 397 0080 1124      		clr __zero_reg__
 398 0082 2F93      		push r18
 399               	.LCFI16:
 400               		.cfi_def_cfa_offset 5
 401               		.cfi_offset 18, -4
 402 0084 3F93      		push r19
 403               	.LCFI17:
 404               		.cfi_def_cfa_offset 6
 405               		.cfi_offset 19, -5
 406 0086 4F93      		push r20
 407               	.LCFI18:
 408               		.cfi_def_cfa_offset 7
 409               		.cfi_offset 20, -6
 410 0088 5F93      		push r21
 411               	.LCFI19:
 412               		.cfi_def_cfa_offset 8
 413               		.cfi_offset 21, -7
 414 008a 6F93      		push r22
 415               	.LCFI20:
 416               		.cfi_def_cfa_offset 9
 417               		.cfi_offset 22, -8
 418 008c 7F93      		push r23
 419               	.LCFI21:
 420               		.cfi_def_cfa_offset 10
 421               		.cfi_offset 23, -9
 422 008e 8F93      		push r24
 423               	.LCFI22:
 424               		.cfi_def_cfa_offset 11
 425               		.cfi_offset 24, -10
 426 0090 9F93      		push r25
 427               	.LCFI23:
 428               		.cfi_def_cfa_offset 12
 429               		.cfi_offset 25, -11
 430 0092 AF93      		push r26
 431               	.LCFI24:
 432               		.cfi_def_cfa_offset 13
 433               		.cfi_offset 26, -12
 434 0094 BF93      		push r27
 435               	.LCFI25:
 436               		.cfi_def_cfa_offset 14
 437               		.cfi_offset 27, -13
 438 0096 EF93      		push r30
 439               	.LCFI26:
 440               		.cfi_def_cfa_offset 15
 441               		.cfi_offset 30, -14
 442 0098 FF93      		push r31
 443               	.LCFI27:
 444               		.cfi_def_cfa_offset 16
 445               		.cfi_offset 31, -15
 446               	/* prologue: Signal */
 447               	/* frame size = 0 */
 448               	/* stack size = 15 */
 449               	.L__stack_usage = 15
  81:main.c        ****     if(PINA&BTNOK){
 450               		.loc 1 81 0
 451 009a CF9B      		sbis 0x19,7
 452 009c 00C0      		rjmp .L22
  82:main.c        ****         if(!Mcurrent){
 453               		.loc 1 82 0
 454 009e E091 0000 		lds r30,Mcurrent
 455 00a2 F091 0000 		lds r31,Mcurrent+1
 456 00a6 3097      		sbiw r30,0
 457 00a8 01F4      		brne .L23
  83:main.c        ****             Mcurrent=&M0main;//if not in menu mode
 458               		.loc 1 83 0
 459 00aa 80E0      		ldi r24,lo8(M0main)
 460 00ac 90E0      		ldi r25,hi8(M0main)
 461 00ae 9093 0000 		sts Mcurrent+1,r25
 462 00b2 8093 0000 		sts Mcurrent,r24
 463 00b6 00C0      		rjmp .L24
 464               	.L23:
  84:main.c        ****         }else{//enter menu and execute
  85:main.c        ****             if(Mcurrent->fptr!=0)Mcurrent->fptr(Mindex);//check if function is associated and selec
 465               		.loc 1 85 0
 466 00b8 0180      		ldd __tmp_reg__,Z+1
 467 00ba F281      		ldd r31,Z+2
 468 00bc E02D      		mov r30,__tmp_reg__
 469 00be 3097      		sbiw r30,0
 470 00c0 01F0      		breq .L25
 471               		.loc 1 85 0 is_stmt 0 discriminator 1
 472 00c2 8091 0000 		lds r24,Mindex
 473 00c6 0995      		icall
 474               	.LVL22:
 475               	.L25:
  86:main.c        ****             Mcurrent=getSubMenu(Mcurrent,Mindex);//get new menu
 476               		.loc 1 86 0 is_stmt 1
 477 00c8 6091 0000 		lds r22,Mindex
 478 00cc 8091 0000 		lds r24,Mcurrent
 479 00d0 9091 0000 		lds r25,Mcurrent+1
 480 00d4 00D0      		rcall getSubMenu
 481               	.LVL23:
 482 00d6 9093 0000 		sts Mcurrent+1,r25
 483 00da 8093 0000 		sts Mcurrent,r24
  87:main.c        ****             Mindex=0;
 484               		.loc 1 87 0
 485 00de 1092 0000 		sts Mindex,__zero_reg__
  88:main.c        ****             clearLeds(leds);
 486               		.loc 1 88 0
 487 00e2 80E0      		ldi r24,lo8(leds)
 488 00e4 90E0      		ldi r25,hi8(leds)
 489 00e6 00D0      		rcall clearLeds
 490               	.LVL24:
 491               	.L24:
  89:main.c        ****         }
  90:main.c        ****         TCNT1=65534;//get straight to led update
 492               		.loc 1 90 0
 493 00e8 8EEF      		ldi r24,lo8(-2)
 494 00ea 9FEF      		ldi r25,lo8(-1)
 495 00ec 9DBD      		out 0x2c+1,r25
 496 00ee 8CBD      		out 0x2c,r24
 497               	.L22:
  91:main.c        ****     }
  92:main.c        ****     if(PINA&BTNINTERNAL){//unused secret button
 498               		.loc 1 92 0
 499 00f0 89B3      		in r24,0x19
 500               	/* epilogue start */
  93:main.c        ****     }
  94:main.c        **** }/*
 501               		.loc 1 94 0
 502 00f2 FF91      		pop r31
 503 00f4 EF91      		pop r30
 504 00f6 BF91      		pop r27
 505 00f8 AF91      		pop r26
 506 00fa 9F91      		pop r25
 507 00fc 8F91      		pop r24
 508 00fe 7F91      		pop r23
 509 0100 6F91      		pop r22
 510 0102 5F91      		pop r21
 511 0104 4F91      		pop r20
 512 0106 3F91      		pop r19
 513 0108 2F91      		pop r18
 514 010a 0F90      		pop r0
 515 010c 0FBE      		out __SREG__,r0
 516 010e 0F90      		pop r0
 517 0110 1F90      		pop r1
 518 0112 1895      		reti
 519               		.cfi_endproc
 520               	.LFE9:
 522               	.global	__vector_8
 524               	__vector_8:
 525               	.LFB10:
  95:main.c        **** ISR( TIM1_COMPB_vect){
  96:main.c        **** }*/
  97:main.c        **** ISR( TIM1_OVF_vect ){
 526               		.loc 1 97 0
 527               		.cfi_startproc
 528 0114 1F92      		push r1
 529               	.LCFI28:
 530               		.cfi_def_cfa_offset 3
 531               		.cfi_offset 1, -2
 532 0116 0F92      		push r0
 533               	.LCFI29:
 534               		.cfi_def_cfa_offset 4
 535               		.cfi_offset 0, -3
 536 0118 0FB6      		in r0,__SREG__
 537 011a 0F92      		push r0
 538 011c 1124      		clr __zero_reg__
 539 011e 2F93      		push r18
 540               	.LCFI30:
 541               		.cfi_def_cfa_offset 5
 542               		.cfi_offset 18, -4
 543 0120 3F93      		push r19
 544               	.LCFI31:
 545               		.cfi_def_cfa_offset 6
 546               		.cfi_offset 19, -5
 547 0122 4F93      		push r20
 548               	.LCFI32:
 549               		.cfi_def_cfa_offset 7
 550               		.cfi_offset 20, -6
 551 0124 5F93      		push r21
 552               	.LCFI33:
 553               		.cfi_def_cfa_offset 8
 554               		.cfi_offset 21, -7
 555 0126 6F93      		push r22
 556               	.LCFI34:
 557               		.cfi_def_cfa_offset 9
 558               		.cfi_offset 22, -8
 559 0128 7F93      		push r23
 560               	.LCFI35:
 561               		.cfi_def_cfa_offset 10
 562               		.cfi_offset 23, -9
 563 012a 8F93      		push r24
 564               	.LCFI36:
 565               		.cfi_def_cfa_offset 11
 566               		.cfi_offset 24, -10
 567 012c 9F93      		push r25
 568               	.LCFI37:
 569               		.cfi_def_cfa_offset 12
 570               		.cfi_offset 25, -11
 571 012e AF93      		push r26
 572               	.LCFI38:
 573               		.cfi_def_cfa_offset 13
 574               		.cfi_offset 26, -12
 575 0130 BF93      		push r27
 576               	.LCFI39:
 577               		.cfi_def_cfa_offset 14
 578               		.cfi_offset 27, -13
 579 0132 CF93      		push r28
 580               	.LCFI40:
 581               		.cfi_def_cfa_offset 15
 582               		.cfi_offset 28, -14
 583 0134 EF93      		push r30
 584               	.LCFI41:
 585               		.cfi_def_cfa_offset 16
 586               		.cfi_offset 30, -15
 587 0136 FF93      		push r31
 588               	.LCFI42:
 589               		.cfi_def_cfa_offset 17
 590               		.cfi_offset 31, -16
 591               	/* prologue: Signal */
 592               	/* frame size = 0 */
 593               	/* stack size = 16 */
 594               	.L__stack_usage = 16
  98:main.c        ****     if(!Mcurrent){//if in normal display mode
 595               		.loc 1 98 0
 596 0138 8091 0000 		lds r24,Mcurrent
 597 013c 9091 0000 		lds r25,Mcurrent+1
 598 0140 892B      		or r24,r25
 599 0142 01F4      		brne .L30
 600               	.LBB30:
  99:main.c        ****         uint8_t m=getMode();
 601               		.loc 1 99 0
 602 0144 00D0      		rcall getMode
 603               	.LVL25:
 604 0146 C82F      		mov r28,r24
 605               	.LVL26:
 100:main.c        ****         RTC_readTime(&currentTime);
 606               		.loc 1 100 0
 607 0148 80E0      		ldi r24,lo8(currentTime)
 608 014a 90E0      		ldi r25,hi8(currentTime)
 609               	.LVL27:
 610 014c 00D0      		rcall RTC_readTime
 611               	.LVL28:
 101:main.c        ****         if(isInAllowedTime(currentTime.hour)){
 612               		.loc 1 101 0
 613 014e 8091 0000 		lds r24,currentTime
 614 0152 00D0      		rcall isInAllowedTime
 615               	.LVL29:
 616 0154 8823      		tst r24
 617 0156 01F0      		breq .L31
 102:main.c        ****             if(m<2){
 618               		.loc 1 102 0
 619 0158 C230      		cpi r28,lo8(2)
 620 015a 00F4      		brsh .L32
 103:main.c        ****                 setLeds(currentTime,leds);
 621               		.loc 1 103 0
 622 015c 20E0      		ldi r18,lo8(leds)
 623 015e 30E0      		ldi r19,hi8(leds)
 624 0160 4091 0000 		lds r20,currentTime
 625 0164 5091 0000 		lds r21,currentTime+1
 626 0168 6091 0000 		lds r22,currentTime+2
 627 016c 7091 0000 		lds r23,currentTime+3
 628 0170 8091 0000 		lds r24,currentTime+4
 629 0174 00D0      		rcall setLeds
 630               	.LVL30:
 631 0176 00C0      		rjmp .L33
 632               	.L32:
 104:main.c        ****             }else if(m<4){
 633               		.loc 1 104 0
 634 0178 C430      		cpi r28,lo8(4)
 635 017a 00F4      		brsh .L33
 105:main.c        ****                 setLedsNb(RTC_readTemp(),leds);
 636               		.loc 1 105 0
 637 017c 00D0      		rcall RTC_readTemp
 638               	.LVL31:
 639 017e 60E0      		ldi r22,lo8(leds)
 640 0180 70E0      		ldi r23,hi8(leds)
 641 0182 00D0      		rcall setLedsNb
 642               	.LVL32:
 643 0184 00C0      		rjmp .L33
 644               	.L31:
 106:main.c        ****             }
 107:main.c        ****         }else{
 108:main.c        ****             clearLeds(leds);
 645               		.loc 1 108 0
 646 0186 80E0      		ldi r24,lo8(leds)
 647 0188 90E0      		ldi r25,hi8(leds)
 648 018a 00D0      		rcall clearLeds
 649               	.LVL33:
 650               	.L33:
 109:main.c        ****         }
 110:main.c        ****         ledr=!ledr;
 651               		.loc 1 110 0
 652 018c 81E0      		ldi r24,lo8(1)
 653 018e 9091 0000 		lds r25,ledr
 654 0192 9111      		cpse r25,__zero_reg__
 655 0194 80E0      		ldi r24,0
 656               	.L34:
 657 0196 8093 0000 		sts ledr,r24
 658               	.LBE30:
 659 019a 00C0      		rjmp .L29
 660               	.LVL34:
 661               	.L30:
 111:main.c        ****     }else{//menu settings mode
 112:main.c        ****         clearLeds(leds);
 662               		.loc 1 112 0
 663 019c 80E0      		ldi r24,lo8(leds)
 664 019e 90E0      		ldi r25,hi8(leds)
 665 01a0 00D0      		rcall clearLeds
 666               	.LVL35:
 113:main.c        ****         ledOn(&leds[Mcurrent->sub[Mindex].led],colorArray[Mcurrent->nb_optn>>4]);
 667               		.loc 1 113 0
 668 01a2 A091 0000 		lds r26,Mcurrent
 669 01a6 B091 0000 		lds r27,Mcurrent+1
 670 01aa EC91      		ld r30,X
 671 01ac E295      		swap r30
 672 01ae EF70      		andi r30,lo8(15)
 673 01b0 F0E0      		ldi r31,0
 674 01b2 E050      		subi r30,lo8(-(colorArray))
 675 01b4 F040      		sbci r31,hi8(-(colorArray))
 676 01b6 8091 0000 		lds r24,Mindex
 677 01ba 90E0      		ldi r25,0
 678 01bc 0196      		adiw r24,1
 679 01be 63E0      		ldi r22,lo8(3)
 680 01c0 70E0      		ldi r23,0
 681 01c2 00D0      		rcall __mulhi3
 682 01c4 A80F      		add r26,r24
 683 01c6 B91F      		adc r27,r25
 684 01c8 8C91      		ld r24,X
 685 01ca 90E0      		ldi r25,0
 686 01cc 63E0      		ldi r22,lo8(3)
 687 01ce 70E0      		ldi r23,0
 688 01d0 00D0      		rcall __mulhi3
 689 01d2 6081      		ld r22,Z
 690 01d4 8050      		subi r24,lo8(-(leds))
 691 01d6 9040      		sbci r25,hi8(-(leds))
 692 01d8 00D0      		rcall ledOn
 693               	.LVL36:
 694               	.L29:
 695               	/* epilogue start */
 114:main.c        ****     }
 115:main.c        ****     
 116:main.c        **** }
 696               		.loc 1 116 0
 697 01da FF91      		pop r31
 698 01dc EF91      		pop r30
 699 01de CF91      		pop r28
 700 01e0 BF91      		pop r27
 701 01e2 AF91      		pop r26
 702 01e4 9F91      		pop r25
 703 01e6 8F91      		pop r24
 704 01e8 7F91      		pop r23
 705 01ea 6F91      		pop r22
 706 01ec 5F91      		pop r21
 707 01ee 4F91      		pop r20
 708 01f0 3F91      		pop r19
 709 01f2 2F91      		pop r18
 710 01f4 0F90      		pop r0
 711 01f6 0FBE      		out __SREG__,r0
 712 01f8 0F90      		pop r0
 713 01fa 1F90      		pop r1
 714 01fc 1895      		reti
 715               		.cfi_endproc
 716               	.LFE10:
 718               	.global	__vector_11
 720               	__vector_11:
 721               	.LFB11:
 117:main.c        **** ISR( TIM0_OVF_vect ){//mux for each color, row 0 and 1
 722               		.loc 1 117 0
 723               		.cfi_startproc
 724 01fe 1F92      		push r1
 725               	.LCFI43:
 726               		.cfi_def_cfa_offset 3
 727               		.cfi_offset 1, -2
 728 0200 0F92      		push r0
 729               	.LCFI44:
 730               		.cfi_def_cfa_offset 4
 731               		.cfi_offset 0, -3
 732 0202 0FB6      		in r0,__SREG__
 733 0204 0F92      		push r0
 734 0206 1124      		clr __zero_reg__
 735 0208 2F93      		push r18
 736               	.LCFI45:
 737               		.cfi_def_cfa_offset 5
 738               		.cfi_offset 18, -4
 739 020a 3F93      		push r19
 740               	.LCFI46:
 741               		.cfi_def_cfa_offset 6
 742               		.cfi_offset 19, -5
 743 020c 4F93      		push r20
 744               	.LCFI47:
 745               		.cfi_def_cfa_offset 7
 746               		.cfi_offset 20, -6
 747 020e 5F93      		push r21
 748               	.LCFI48:
 749               		.cfi_def_cfa_offset 8
 750               		.cfi_offset 21, -7
 751 0210 6F93      		push r22
 752               	.LCFI49:
 753               		.cfi_def_cfa_offset 9
 754               		.cfi_offset 22, -8
 755 0212 7F93      		push r23
 756               	.LCFI50:
 757               		.cfi_def_cfa_offset 10
 758               		.cfi_offset 23, -9
 759 0214 8F93      		push r24
 760               	.LCFI51:
 761               		.cfi_def_cfa_offset 11
 762               		.cfi_offset 24, -10
 763 0216 9F93      		push r25
 764               	.LCFI52:
 765               		.cfi_def_cfa_offset 12
 766               		.cfi_offset 25, -11
 767 0218 AF93      		push r26
 768               	.LCFI53:
 769               		.cfi_def_cfa_offset 13
 770               		.cfi_offset 26, -12
 771 021a BF93      		push r27
 772               	.LCFI54:
 773               		.cfi_def_cfa_offset 14
 774               		.cfi_offset 27, -13
 775 021c EF93      		push r30
 776               	.LCFI55:
 777               		.cfi_def_cfa_offset 15
 778               		.cfi_offset 30, -14
 779 021e FF93      		push r31
 780               	.LCFI56:
 781               		.cfi_def_cfa_offset 16
 782               		.cfi_offset 31, -15
 783               	/* prologue: Signal */
 784               	/* frame size = 0 */
 785               	/* stack size = 15 */
 786               	.L__stack_usage = 15
 118:main.c        ****     switch(state){
 787               		.loc 1 118 0
 788 0220 8091 0000 		lds r24,state
 789 0224 8230      		cpi r24,lo8(2)
 790 0226 01F0      		breq .L41
 791 0228 00F4      		brsh .L42
 792 022a 8823      		tst r24
 793 022c 01F0      		breq .L43
 794 022e 8130      		cpi r24,lo8(1)
 795 0230 01F4      		brne .L40
 119:main.c        ****         case 0:
 120:main.c        ****             sendData(R2 | getDataByColor(RED,0,leds));
 121:main.c        ****             break;
 122:main.c        ****         case 1:
 123:main.c        ****             sendData(R1 | getDataByColor(RED,1,leds));
 796               		.loc 1 123 0
 797 0232 40E0      		ldi r20,lo8(leds)
 798 0234 50E0      		ldi r21,hi8(leds)
 799 0236 61E0      		ldi r22,lo8(1)
 800 0238 84E0      		ldi r24,lo8(4)
 801 023a 00D0      		rcall getDataByColor
 802               	.LVL37:
 803 023c 7068      		ori r23,128
 804 023e 00C0      		rjmp .L49
 805               	.L42:
 118:main.c        ****     switch(state){
 806               		.loc 1 118 0
 807 0240 8430      		cpi r24,lo8(4)
 808 0242 01F0      		breq .L45
 809 0244 00F0      		brlo .L46
 810 0246 8530      		cpi r24,lo8(5)
 811 0248 01F4      		brne .L40
 124:main.c        ****             break;
 125:main.c        ****         case 2:
 126:main.c        ****             sendData(G2 | getDataByColor(GREEN,0,leds));
 127:main.c        ****             break;
 128:main.c        ****         case 3:
 129:main.c        ****             sendData(G1 | getDataByColor(GREEN,1,leds));
 130:main.c        ****             break;
 131:main.c        ****         case 4:
 132:main.c        ****             sendData(B2 | getDataByColor(BLUE,0,leds));
 133:main.c        ****             break;
 134:main.c        ****         case 5:
 135:main.c        ****             sendData(B1 | getDataByColor(BLUE,1,leds));
 812               		.loc 1 135 0
 813 024a 40E0      		ldi r20,lo8(leds)
 814 024c 50E0      		ldi r21,hi8(leds)
 815 024e 61E0      		ldi r22,lo8(1)
 816 0250 81E0      		ldi r24,lo8(1)
 817 0252 00D0      		rcall getDataByColor
 818               	.LVL38:
 819 0254 8260      		ori r24,2
 820 0256 00C0      		rjmp .L49
 821               	.L43:
 120:main.c        ****             break;
 822               		.loc 1 120 0
 823 0258 40E0      		ldi r20,lo8(leds)
 824 025a 50E0      		ldi r21,hi8(leds)
 825 025c 60E0      		ldi r22,0
 826 025e 84E0      		ldi r24,lo8(4)
 827 0260 00D0      		rcall getDataByColor
 828               	.LVL39:
 829 0262 7064      		ori r23,64
 830 0264 00C0      		rjmp .L49
 831               	.L41:
 126:main.c        ****             break;
 832               		.loc 1 126 0
 833 0266 40E0      		ldi r20,lo8(leds)
 834 0268 50E0      		ldi r21,hi8(leds)
 835 026a 60E0      		ldi r22,0
 836 026c 82E0      		ldi r24,lo8(2)
 837 026e 00D0      		rcall getDataByColor
 838               	.LVL40:
 839 0270 8460      		ori r24,4
 840 0272 00C0      		rjmp .L49
 841               	.L46:
 129:main.c        ****             break;
 842               		.loc 1 129 0
 843 0274 40E0      		ldi r20,lo8(leds)
 844 0276 50E0      		ldi r21,hi8(leds)
 845 0278 61E0      		ldi r22,lo8(1)
 846 027a 82E0      		ldi r24,lo8(2)
 847 027c 00D0      		rcall getDataByColor
 848               	.LVL41:
 849 027e 8860      		ori r24,8
 850 0280 00C0      		rjmp .L49
 851               	.L45:
 132:main.c        ****             break;
 852               		.loc 1 132 0
 853 0282 40E0      		ldi r20,lo8(leds)
 854 0284 50E0      		ldi r21,hi8(leds)
 855 0286 60E0      		ldi r22,0
 856 0288 81E0      		ldi r24,lo8(1)
 857 028a 00D0      		rcall getDataByColor
 858               	.LVL42:
 859 028c 8160      		ori r24,1
 860               	.L49:
 861               		.loc 1 135 0
 862 028e 00D0      		rcall sendData
 863               	.LVL43:
 864               	.L40:
 136:main.c        ****             break;
 137:main.c        ****     }
 138:main.c        ****     state++;
 865               		.loc 1 138 0
 866 0290 8091 0000 		lds r24,state
 867 0294 8F5F      		subi r24,lo8(-(1))
 868 0296 8093 0000 		sts state,r24
 139:main.c        ****     if(state>5)state=0;
 869               		.loc 1 139 0
 870 029a 8091 0000 		lds r24,state
 871 029e 8630      		cpi r24,lo8(6)
 872 02a0 00F0      		brlo .L39
 873               		.loc 1 139 0 is_stmt 0 discriminator 1
 874 02a2 1092 0000 		sts state,__zero_reg__
 875               	.L39:
 876               	/* epilogue start */
 140:main.c        **** }
 877               		.loc 1 140 0 is_stmt 1
 878 02a6 FF91      		pop r31
 879 02a8 EF91      		pop r30
 880 02aa BF91      		pop r27
 881 02ac AF91      		pop r26
 882 02ae 9F91      		pop r25
 883 02b0 8F91      		pop r24
 884 02b2 7F91      		pop r23
 885 02b4 6F91      		pop r22
 886 02b6 5F91      		pop r21
 887 02b8 4F91      		pop r20
 888 02ba 3F91      		pop r19
 889 02bc 2F91      		pop r18
 890 02be 0F90      		pop r0
 891 02c0 0FBE      		out __SREG__,r0
 892 02c2 0F90      		pop r0
 893 02c4 1F90      		pop r1
 894 02c6 1895      		reti
 895               		.cfi_endproc
 896               	.LFE11:
 898               		.comm	leds,57,1
 899               	.global	Mindex
 900               		.section .bss
 903               	Mindex:
 904 0000 00        		.zero	1
 905               	.global	Mcurrent
 908               	Mcurrent:
 909 0001 0000      		.zero	2
 910               	.global	state
 913               	state:
 914 0003 00        		.zero	1
 915               	.global	ledb
 918               	ledb:
 919 0004 00        		.zero	1
 920               	.global	ledr
 923               	ledr:
 924 0005 00        		.zero	1
 925               		.comm	M1rainbow,3,1
 926               		.comm	M1reset,3,1
 927               		.comm	M1eventMode,3,1
 928               		.comm	M2setminpm,3,1
 929               		.comm	M2setminam,3,1
 930               		.comm	M2sethourpm,3,1
 931               		.comm	M2sethouram,3,1
 932               		.comm	M1setTime,3,1
 933               		.comm	M3onhour,3,1
 934               		.comm	M2offhour,3,1
 935               		.comm	M1nightmode,3,1
 936               		.comm	M1cmode,3,1
 937               		.comm	M1mode,3,1
 938               		.comm	M0main,3,1
 939               		.comm	USI_I2C_Master_State,1,1
 940               		.comm	currentTime,5,1
 941               		.section	.rodata
 944               	colorArray:
 945 0000 07        		.byte	7
 946 0001 03        		.byte	3
 947 0002 01        		.byte	1
 948 0003 05        		.byte	5
 949 0004 04        		.byte	4
 950 0005 06        		.byte	6
 951 0006 02        		.byte	2
 952               		.text
 953               	.Letext0:
 954               		.file 3 "/usr/lib/avr/include/stdint.h"
 955               		.file 4 "RTC.h"
 956               		.file 5 "Menu.h"
 957               		.file 6 "Led.h"
 958               		.file 7 "defines.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccHVEIQX.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccHVEIQX.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccHVEIQX.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccHVEIQX.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccHVEIQX.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccHVEIQX.s:12     .text:0000000000000000 sendData
     /tmp/ccHVEIQX.s:923    .bss:0000000000000005 ledr
     /tmp/ccHVEIQX.s:918    .bss:0000000000000004 ledb
     /tmp/ccHVEIQX.s:45     .text.startup:0000000000000000 main
                            *COM*:0000000000000039 leds
                            *COM*:0000000000000005 currentTime
     /tmp/ccHVEIQX.s:273    .text:0000000000000012 __vector_3
     /tmp/ccHVEIQX.s:908    .bss:0000000000000001 Mcurrent
     /tmp/ccHVEIQX.s:903    .bss:0000000000000000 Mindex
     /tmp/ccHVEIQX.s:383    .text:0000000000000078 __vector_2
                            *COM*:0000000000000003 M0main
     /tmp/ccHVEIQX.s:524    .text:0000000000000114 __vector_8
     /tmp/ccHVEIQX.s:944    .rodata:0000000000000000 colorArray
     /tmp/ccHVEIQX.s:720    .text:00000000000001fe __vector_11
     /tmp/ccHVEIQX.s:913    .bss:0000000000000003 state
                            *COM*:0000000000000003 M1rainbow
                            *COM*:0000000000000003 M1reset
                            *COM*:0000000000000003 M1eventMode
                            *COM*:0000000000000003 M2setminpm
                            *COM*:0000000000000003 M2setminam
                            *COM*:0000000000000003 M2sethourpm
                            *COM*:0000000000000003 M2sethouram
                            *COM*:0000000000000003 M1setTime
                            *COM*:0000000000000003 M3onhour
                            *COM*:0000000000000003 M2offhour
                            *COM*:0000000000000003 M1nightmode
                            *COM*:0000000000000003 M1cmode
                            *COM*:0000000000000003 M1mode
                            *COM*:0000000000000001 USI_I2C_Master_State

UNDEFINED SYMBOLS
sendRawData
ledInit
Minit
RTC_readTime
findNextEntry
getSubMenu
clearLeds
getMode
isInAllowedTime
setLeds
RTC_readTemp
setLedsNb
__mulhi3
ledOn
getDataByColor
__do_copy_data
__do_clear_bss
