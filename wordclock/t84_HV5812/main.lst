   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	sendData
  12               	sendData:
  13               	.LFB6:
  14               		.file 1 "main.c"
   1:main.c        **** #define F_CPU 16000000UL
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** #include <util/delay.h>
   5:main.c        **** #include "defines.h"
   6:main.c        **** #include "Led.h"
   7:main.c        **** #include "RTC.h"
   8:main.c        **** 
   9:main.c        **** void sendData(uint32_t data){
  15               		.loc 1 9 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26               	/* prologue: function */
  27               	/* frame size = 0 */
  28               	/* stack size = 2 */
  29               	.L__stack_usage = 2
  10:main.c        ****     PORTA &=~(STROBE|CLK);
  30               		.loc 1 10 0
  31 0004 2BB3      		in r18,0x1b
  32 0006 237F      		andi r18,lo8(-13)
  33 0008 2BBB      		out 0x1b,r18
  34               	.LVL1:
  35 000a 40E0      		ldi r20,0
  36 000c 50E0      		ldi r21,0
  37               	.LVL2:
  38               	.L4:
  39               	.LBB6:
  11:main.c        ****     for(uint8_t i=0;i<20;i++){
  12:main.c        ****         if((data>>i) & 0x00000001){
  40               		.loc 1 12 0
  41 000e 8B01      		movw r16,r22
  42 0010 9C01      		movw r18,r24
  43 0012 042E      		mov r0,r20
  44 0014 00C0      		rjmp 2f
  45               		1:
  46 0016 3695      		lsr r19
  47 0018 2795      		ror r18
  48 001a 1795      		ror r17
  49 001c 0795      		ror r16
  50               		2:
  51 001e 0A94      		dec r0
  52 0020 02F4      		brpl 1b
  53 0022 00FF      		sbrs r16,0
  54 0024 00C0      		rjmp .L2
  13:main.c        ****             PORTA|=DATA;
  55               		.loc 1 13 0
  56 0026 D99A      		sbi 0x1b,1
  57 0028 00C0      		rjmp .L3
  58               	.L2:
  14:main.c        ****         }else{
  15:main.c        ****             PORTA&=~DATA;
  59               		.loc 1 15 0
  60 002a D998      		cbi 0x1b,1
  61               	.L3:
  16:main.c        ****         }
  17:main.c        ****         PORTA|=CLK;
  62               		.loc 1 17 0 discriminator 2
  63 002c DB9A      		sbi 0x1b,3
  18:main.c        ****         PORTA&=~CLK;
  64               		.loc 1 18 0 discriminator 2
  65 002e DB98      		cbi 0x1b,3
  66               	.LVL3:
  67 0030 4F5F      		subi r20,-1
  68 0032 5F4F      		sbci r21,-1
  69               	.LVL4:
  11:main.c        ****         if((data>>i) & 0x00000001){
  70               		.loc 1 11 0 discriminator 2
  71 0034 4431      		cpi r20,20
  72 0036 5105      		cpc r21,__zero_reg__
  73 0038 01F4      		brne .L4
  74               	.LBE6:
  19:main.c        ****     }
  20:main.c        ****     PORTA|=STROBE;
  75               		.loc 1 20 0
  76 003a DA9A      		sbi 0x1b,2
  21:main.c        ****     PORTA&=~STROBE;
  77               		.loc 1 21 0
  78 003c DA98      		cbi 0x1b,2
  79               	/* epilogue start */
  22:main.c        **** }
  80               		.loc 1 22 0
  81 003e 1F91      		pop r17
  82 0040 0F91      		pop r16
  83 0042 0895      		ret
  84               		.cfi_endproc
  85               	.LFE6:
  87               		.section	.text.startup,"ax",@progbits
  88               	.global	main
  90               	main:
  91               	.LFB7:
  23:main.c        **** 
  24:main.c        **** volatile uint8_t state=0;
  25:main.c        **** Led leds[NBLEDS];
  26:main.c        **** 
  27:main.c        **** int main(void){    
  92               		.loc 1 27 0
  93               		.cfi_startproc
  94               	/* prologue: function */
  95               	/* frame size = 0 */
  96               	/* stack size = 0 */
  97               	.L__stack_usage = 0
  28:main.c        ****     DDRA |= CLK|DATA|STROBE|LED;
  98               		.loc 1 28 0
  99 0000 8AB3      		in r24,0x1a
 100 0002 8F60      		ori r24,lo8(15)
 101 0004 8ABB      		out 0x1a,r24
  29:main.c        ****     PORTA &= ~(CLK|DATA|STROBE|LED);
 102               		.loc 1 29 0
 103 0006 8BB3      		in r24,0x1b
 104 0008 807F      		andi r24,lo8(-16)
 105 000a 8BBB      		out 0x1b,r24
  30:main.c        ****     ledInit(leds);
 106               		.loc 1 30 0
 107 000c 80E0      		ldi r24,lo8(leds)
 108 000e 90E0      		ldi r25,hi8(leds)
 109 0010 00D0      		rcall ledInit
 110               	.LVL5:
  31:main.c        ****     
  32:main.c        ****     TIMSK1|=(1<<TOIE1);
 111               		.loc 1 32 0
 112 0012 609A      		sbi 0xc,0
  33:main.c        ****     TIMSK0|=(1<<TOIE0);
 113               		.loc 1 33 0
 114 0014 89B7      		in r24,0x39
 115 0016 8160      		ori r24,lo8(1)
 116 0018 89BF      		out 0x39,r24
  34:main.c        ****     sei();
 117               		.loc 1 34 0
 118               	/* #APP */
 119               	 ;  34 "main.c" 1
 120 001a 7894      		sei
 121               	 ;  0 "" 2
  35:main.c        ****     
  36:main.c        ****     /*sendData(0b11111100001111111111);
  37:main.c        ****     _delay_ms(250);
  38:main.c        ****     sendData(0b11000000001111111111);
  39:main.c        ****     _delay_ms(250);
  40:main.c        ****     sendData(0b00001100001111111111);
  41:main.c        ****     _delay_ms(250);
  42:main.c        ****     sendData(0b00110000001111111111);
  43:main.c        ****     _delay_ms(250);*/
  44:main.c        ****     sendData(0b00000000000000000000);
 122               		.loc 1 44 0
 123               	/* #NOAPP */
 124 001c 60E0      		ldi r22,0
 125 001e 70E0      		ldi r23,0
 126 0020 CB01      		movw r24,r22
 127 0022 00D0      		rcall sendData
 128               	.LVL6:
 129               	.LBB7:
 130               	.LBB8:
 131               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 132               		.loc 2 187 0
 133 0024 2FEF      		ldi r18,lo8(799999)
 134 0026 84E3      		ldi r24,hi8(799999)
 135 0028 9CE0      		ldi r25,hlo8(799999)
 136 002a 2150      	1:	subi r18,1
 137 002c 8040      		sbci r24,0
 138 002e 9040      		sbci r25,0
 139 0030 01F4      		brne 1b
 140 0032 00C0      		rjmp .
 141 0034 0000      		nop
 142               	.LVL7:
 143               	.LBE8:
 144               	.LBE7:
  45:main.c        **** 	_delay_ms(250);
  46:main.c        ****     sendData(0b11111111111111111111);
 145               		.loc 1 46 0
 146 0036 6FEF      		ldi r22,lo8(-1)
 147 0038 7FEF      		ldi r23,lo8(-1)
 148 003a 8FE0      		ldi r24,lo8(15)
 149 003c 90E0      		ldi r25,0
 150 003e 00D0      		rcall sendData
 151               	.LVL8:
 152               	.LBB9:
 153               	.LBB10:
 154               		.loc 2 187 0
 155 0040 2FEF      		ldi r18,lo8(799999)
 156 0042 84E3      		ldi r24,hi8(799999)
 157 0044 9CE0      		ldi r25,hlo8(799999)
 158 0046 2150      	1:	subi r18,1
 159 0048 8040      		sbci r24,0
 160 004a 9040      		sbci r25,0
 161 004c 01F4      		brne 1b
 162 004e 00C0      		rjmp .
 163 0050 0000      		nop
 164               	.LVL9:
 165               	.LBE10:
 166               	.LBE9:
  47:main.c        ****     _delay_ms(250);
  48:main.c        ****     sendData(0b00000000000000000000);
 167               		.loc 1 48 0
 168 0052 60E0      		ldi r22,0
 169 0054 70E0      		ldi r23,0
 170 0056 CB01      		movw r24,r22
 171 0058 00D0      		rcall sendData
 172               	.LVL10:
  49:main.c        ****     #ifdef DELLONG
  50:main.c        **** 		TCCR1B|=(1<<CS12)|(1<<CS10);
 173               		.loc 1 50 0
 174 005a 8EB5      		in r24,0x2e
 175 005c 8560      		ori r24,lo8(5)
 176 005e 8EBD      		out 0x2e,r24
  51:main.c        **** 	#else
  52:main.c        **** 		TCCR1B|=(1<<CS12);//|(1<<CS10);
  53:main.c        **** 	#endif
  54:main.c        **** 	
  55:main.c        **** 	TCCR0B|=(1<<CS01)|(1<<CS00);
 177               		.loc 1 55 0
 178 0060 83B7      		in r24,0x33
 179 0062 8360      		ori r24,lo8(3)
 180 0064 83BF      		out 0x33,r24
  56:main.c        ****     
  57:main.c        ****     currentColor=tcolorV(RED);
 181               		.loc 1 57 0
 182 0066 60E0      		ldi r22,0
 183 0068 70E0      		ldi r23,0
 184 006a 8FEF      		ldi r24,lo8(-1)
 185 006c 90E0      		ldi r25,0
 186 006e 00D0      		rcall tcolorV
 187               	.LVL11:
 188 0070 6093 0000 		sts currentColor,r22
 189 0074 7093 0000 		sts currentColor+1,r23
 190 0078 8093 0000 		sts currentColor+2,r24
  58:main.c        ****     setCurrentTime(15,45,7,11);
 191               		.loc 1 58 0
 192 007c 2BE0      		ldi r18,lo8(11)
 193 007e 47E0      		ldi r20,lo8(7)
 194 0080 6DE2      		ldi r22,lo8(45)
 195 0082 8FE0      		ldi r24,lo8(15)
 196 0084 00D0      		rcall setCurrentTime
 197               	.LVL12:
  59:main.c        **** 	//RTC_readTime(&currentTime);
  60:main.c        ****     currentTime.temp=11;
 198               		.loc 1 60 0
 199 0086 8BE0      		ldi r24,lo8(11)
 200 0088 8093 0000 		sts currentTime+4,r24
 201               	.L8:
 202 008c 00C0      		rjmp .L8
 203               		.cfi_endproc
 204               	.LFE7:
 206               		.text
 207               	.global	__vector_8
 209               	__vector_8:
 210               	.LFB8:
  61:main.c        ****     //setLeds(currentTime,leds,currentColor);
  62:main.c        ****     
  63:main.c        ****     while(1){
  64:main.c        ****        
  65:main.c        ****     }
  66:main.c        ****     return(0);
  67:main.c        ****     
  68:main.c        **** }
  69:main.c        **** ISR( TIM1_OVF_vect ){
 211               		.loc 1 69 0
 212               		.cfi_startproc
 213 0044 1F92      		push r1
 214               	.LCFI2:
 215               		.cfi_def_cfa_offset 3
 216               		.cfi_offset 1, -2
 217 0046 0F92      		push r0
 218               	.LCFI3:
 219               		.cfi_def_cfa_offset 4
 220               		.cfi_offset 0, -3
 221 0048 0FB6      		in r0,__SREG__
 222 004a 0F92      		push r0
 223 004c 1124      		clr __zero_reg__
 224 004e 2F93      		push r18
 225               	.LCFI4:
 226               		.cfi_def_cfa_offset 5
 227               		.cfi_offset 18, -4
 228 0050 3F93      		push r19
 229               	.LCFI5:
 230               		.cfi_def_cfa_offset 6
 231               		.cfi_offset 19, -5
 232 0052 4F93      		push r20
 233               	.LCFI6:
 234               		.cfi_def_cfa_offset 7
 235               		.cfi_offset 20, -6
 236 0054 5F93      		push r21
 237               	.LCFI7:
 238               		.cfi_def_cfa_offset 8
 239               		.cfi_offset 21, -7
 240 0056 6F93      		push r22
 241               	.LCFI8:
 242               		.cfi_def_cfa_offset 9
 243               		.cfi_offset 22, -8
 244 0058 7F93      		push r23
 245               	.LCFI9:
 246               		.cfi_def_cfa_offset 10
 247               		.cfi_offset 23, -9
 248 005a 8F93      		push r24
 249               	.LCFI10:
 250               		.cfi_def_cfa_offset 11
 251               		.cfi_offset 24, -10
 252 005c 9F93      		push r25
 253               	.LCFI11:
 254               		.cfi_def_cfa_offset 12
 255               		.cfi_offset 25, -11
 256 005e AF93      		push r26
 257               	.LCFI12:
 258               		.cfi_def_cfa_offset 13
 259               		.cfi_offset 26, -12
 260 0060 BF93      		push r27
 261               	.LCFI13:
 262               		.cfi_def_cfa_offset 14
 263               		.cfi_offset 27, -13
 264 0062 EF93      		push r30
 265               	.LCFI14:
 266               		.cfi_def_cfa_offset 15
 267               		.cfi_offset 30, -14
 268 0064 FF93      		push r31
 269               	.LCFI15:
 270               		.cfi_def_cfa_offset 16
 271               		.cfi_offset 31, -15
 272               	/* prologue: Signal */
 273               	/* frame size = 0 */
 274               	/* stack size = 15 */
 275               	.L__stack_usage = 15
  70:main.c        ****     PORTA^=LED;
 276               		.loc 1 70 0
 277 0066 9BB3      		in r25,0x1b
 278 0068 81E0      		ldi r24,lo8(1)
 279 006a 8927      		eor r24,r25
 280 006c 8BBB      		out 0x1b,r24
  71:main.c        ****     //RTC_readTime(&currentTime);
  72:main.c        ****     //setLeds(currentTime,leds,currentColor);
  73:main.c        ****     if(state){
 281               		.loc 1 73 0
 282 006e 8091 0000 		lds r24,state
 283 0072 8823      		tst r24
 284 0074 01F0      		breq .L10
  74:main.c        ****     sendData(0b11111111111111111111);
 285               		.loc 1 74 0
 286 0076 6FEF      		ldi r22,lo8(-1)
 287 0078 7FEF      		ldi r23,lo8(-1)
 288 007a 8FE0      		ldi r24,lo8(15)
 289 007c 90E0      		ldi r25,0
 290 007e 00C0      		rjmp .L12
 291               	.L10:
  75:main.c        ****     }else{
  76:main.c        ****     sendData(0b00000000000000000000);
 292               		.loc 1 76 0
 293 0080 60E0      		ldi r22,0
 294 0082 70E0      		ldi r23,0
 295 0084 CB01      		movw r24,r22
 296               	.L12:
 297 0086 00D0      		rcall sendData
 298               	.LVL13:
  77:main.c        ****     }state=1-state;
 299               		.loc 1 77 0
 300 0088 9091 0000 		lds r25,state
 301 008c 81E0      		ldi r24,lo8(1)
 302 008e 891B      		sub r24,r25
 303 0090 8093 0000 		sts state,r24
 304               	/* epilogue start */
  78:main.c        **** }
 305               		.loc 1 78 0
 306 0094 FF91      		pop r31
 307 0096 EF91      		pop r30
 308 0098 BF91      		pop r27
 309 009a AF91      		pop r26
 310 009c 9F91      		pop r25
 311 009e 8F91      		pop r24
 312 00a0 7F91      		pop r23
 313 00a2 6F91      		pop r22
 314 00a4 5F91      		pop r21
 315 00a6 4F91      		pop r20
 316 00a8 3F91      		pop r19
 317 00aa 2F91      		pop r18
 318 00ac 0F90      		pop r0
 319 00ae 0FBE      		out __SREG__,r0
 320 00b0 0F90      		pop r0
 321 00b2 1F90      		pop r1
 322 00b4 1895      		reti
 323               		.cfi_endproc
 324               	.LFE8:
 326               	.global	__vector_11
 328               	__vector_11:
 329               	.LFB9:
  79:main.c        **** ISR( TIM0_OVF_vect ){
 330               		.loc 1 79 0
 331               		.cfi_startproc
 332 00b6 1F92      		push r1
 333               	.LCFI16:
 334               		.cfi_def_cfa_offset 3
 335               		.cfi_offset 1, -2
 336 00b8 0F92      		push r0
 337               	.LCFI17:
 338               		.cfi_def_cfa_offset 4
 339               		.cfi_offset 0, -3
 340 00ba 0FB6      		in r0,__SREG__
 341 00bc 0F92      		push r0
 342 00be 1124      		clr __zero_reg__
 343               	/* prologue: Signal */
 344               	/* frame size = 0 */
 345               	/* stack size = 3 */
 346               	.L__stack_usage = 3
 347               	/* epilogue start */
  80:main.c        ****    /* switch(state){
  81:main.c        ****         case 0:
  82:main.c        ****             sendData(R2 | getDataByColor(tcolor(1,0,0),0,leds));
  83:main.c        ****             break;
  84:main.c        ****         case 1:
  85:main.c        ****             sendData(R1 | getDataByColor(tcolor(1,0,0),1,leds));
  86:main.c        ****             break;
  87:main.c        ****         case 2:
  88:main.c        ****             sendData(G2 | getDataByColor(tcolor(0,1,0),0,leds));
  89:main.c        ****             break;
  90:main.c        ****         case 3:
  91:main.c        ****             sendData(G1 | getDataByColor(tcolor(0,1,0),1,leds));
  92:main.c        ****             break;
  93:main.c        ****         case 4:
  94:main.c        ****             sendData(B2 | getDataByColor(tcolor(0,0,1),0,leds));
  95:main.c        ****             break;
  96:main.c        ****         case 5:
  97:main.c        ****             sendData(B1 | getDataByColor(tcolor(0,0,1),1,leds));
  98:main.c        ****             break;
  99:main.c        ****     }
 100:main.c        ****     state++;
 101:main.c        ****     if(state>5)state=0;*/
 102:main.c        **** }
 348               		.loc 1 102 0
 349 00c0 0F90      		pop r0
 350 00c2 0FBE      		out __SREG__,r0
 351 00c4 0F90      		pop r0
 352 00c6 1F90      		pop r1
 353 00c8 1895      		reti
 354               		.cfi_endproc
 355               	.LFE9:
 357               		.comm	leds,95,1
 358               	.global	state
 359               		.section .bss
 362               	state:
 363 0000 00        		.zero	1
 364               		.comm	currentColor,3,1
 365               		.comm	USI_I2C_Master_State,1,1
 366               		.comm	currentTime,5,1
 367               		.text
 368               	.Letext0:
 369               		.file 3 "/usr/lib/avr/include/stdint.h"
 370               		.file 4 "RTC.h"
 371               		.file 5 "Led.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccwjXkAl.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccwjXkAl.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccwjXkAl.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccwjXkAl.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccwjXkAl.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccwjXkAl.s:12     .text:0000000000000000 sendData
     /tmp/ccwjXkAl.s:90     .text.startup:0000000000000000 main
                            *COM*:000000000000005f leds
                            *COM*:0000000000000003 currentColor
                            *COM*:0000000000000005 currentTime
     /tmp/ccwjXkAl.s:209    .text:0000000000000044 __vector_8
     /tmp/ccwjXkAl.s:362    .bss:0000000000000000 state
     /tmp/ccwjXkAl.s:328    .text:00000000000000b6 __vector_11
                            *COM*:0000000000000001 USI_I2C_Master_State

UNDEFINED SYMBOLS
ledInit
tcolorV
setCurrentTime
__do_clear_bss
