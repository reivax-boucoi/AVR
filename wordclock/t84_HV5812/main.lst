   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	sendData
  12               	sendData:
  13               	.LFB6:
  14               		.file 1 "main.c"
   1:main.c        **** #define F_CPU 16000000UL
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** #include <util/delay.h>
   5:main.c        **** #include "defines.h"
   6:main.c        **** #include "Led.h"
   7:main.c        **** #include "RTC.h"
   8:main.c        **** 
   9:main.c        **** void sendData(uint32_t data){
  15               		.loc 1 9 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26               	/* prologue: function */
  27               	/* frame size = 0 */
  28               	/* stack size = 2 */
  29               	.L__stack_usage = 2
  10:main.c        ****     PORTA &=~(STROBE|CLK);
  30               		.loc 1 10 0
  31 0004 2BB3      		in r18,0x1b
  32 0006 237F      		andi r18,lo8(-13)
  33 0008 2BBB      		out 0x1b,r18
  34               	.LVL1:
  35 000a 40E0      		ldi r20,0
  36 000c 50E0      		ldi r21,0
  37               	.LVL2:
  38               	.L4:
  39               	.LBB10:
  11:main.c        ****     for(uint8_t i=0;i<20;i++){
  12:main.c        ****         if((data>>i) & 0x00000001){
  40               		.loc 1 12 0
  41 000e 8B01      		movw r16,r22
  42 0010 9C01      		movw r18,r24
  43 0012 042E      		mov r0,r20
  44 0014 00C0      		rjmp 2f
  45               		1:
  46 0016 3695      		lsr r19
  47 0018 2795      		ror r18
  48 001a 1795      		ror r17
  49 001c 0795      		ror r16
  50               		2:
  51 001e 0A94      		dec r0
  52 0020 02F4      		brpl 1b
  53 0022 00FF      		sbrs r16,0
  54 0024 00C0      		rjmp .L2
  13:main.c        ****             PORTA|=DATA;
  55               		.loc 1 13 0
  56 0026 D99A      		sbi 0x1b,1
  57 0028 00C0      		rjmp .L3
  58               	.L2:
  14:main.c        ****         }else{
  15:main.c        ****             PORTA&=~DATA;
  59               		.loc 1 15 0
  60 002a D998      		cbi 0x1b,1
  61               	.L3:
  16:main.c        ****         }
  17:main.c        ****         PORTA|=CLK;
  62               		.loc 1 17 0 discriminator 2
  63 002c DB9A      		sbi 0x1b,3
  18:main.c        ****         PORTA&=~CLK;
  64               		.loc 1 18 0 discriminator 2
  65 002e DB98      		cbi 0x1b,3
  66               	.LVL3:
  67 0030 4F5F      		subi r20,-1
  68 0032 5F4F      		sbci r21,-1
  69               	.LVL4:
  11:main.c        ****         if((data>>i) & 0x00000001){
  70               		.loc 1 11 0 discriminator 2
  71 0034 4431      		cpi r20,20
  72 0036 5105      		cpc r21,__zero_reg__
  73 0038 01F4      		brne .L4
  74               	.LBE10:
  19:main.c        ****     }
  20:main.c        ****     PORTA|=STROBE;
  75               		.loc 1 20 0
  76 003a DA9A      		sbi 0x1b,2
  21:main.c        ****     PORTA&=~STROBE;
  77               		.loc 1 21 0
  78 003c DA98      		cbi 0x1b,2
  79               	/* epilogue start */
  22:main.c        **** }
  80               		.loc 1 22 0
  81 003e 1F91      		pop r17
  82 0040 0F91      		pop r16
  83 0042 0895      		ret
  84               		.cfi_endproc
  85               	.LFE6:
  87               		.section	.text.startup,"ax",@progbits
  88               	.global	main
  90               	main:
  91               	.LFB7:
  23:main.c        **** 
  24:main.c        **** volatile uint8_t state=0;
  25:main.c        **** Led leds[NBLEDS];
  26:main.c        **** 
  27:main.c        **** int main(void){    
  92               		.loc 1 27 0
  93               		.cfi_startproc
  94               	/* prologue: function */
  95               	/* frame size = 0 */
  96               	/* stack size = 0 */
  97               	.L__stack_usage = 0
  28:main.c        ****     DDRA |= CLK|DATA|STROBE|LED;
  98               		.loc 1 28 0
  99 0000 8AB3      		in r24,0x1a
 100 0002 8F60      		ori r24,lo8(15)
 101 0004 8ABB      		out 0x1a,r24
  29:main.c        ****     PORTA &= ~(CLK|DATA|STROBE|LED);
 102               		.loc 1 29 0
 103 0006 8BB3      		in r24,0x1b
 104 0008 807F      		andi r24,lo8(-16)
 105 000a 8BBB      		out 0x1b,r24
  30:main.c        ****     ledInit(leds);
 106               		.loc 1 30 0
 107 000c 80E0      		ldi r24,lo8(leds)
 108 000e 90E0      		ldi r25,hi8(leds)
 109 0010 00D0      		rcall ledInit
 110               	.LVL5:
  31:main.c        ****     
  32:main.c        ****     TIMSK1|=(1<<TOIE1);
 111               		.loc 1 32 0
 112 0012 609A      		sbi 0xc,0
  33:main.c        ****     TIMSK0|=(1<<TOIE0);
 113               		.loc 1 33 0
 114 0014 89B7      		in r24,0x39
 115 0016 8160      		ori r24,lo8(1)
 116 0018 89BF      		out 0x39,r24
  34:main.c        ****     sei();
 117               		.loc 1 34 0
 118               	/* #APP */
 119               	 ;  34 "main.c" 1
 120 001a 7894      		sei
 121               	 ;  0 "" 2
  35:main.c        ****     
  36:main.c        ****     sendData(0b11111100001111111111);
 122               		.loc 1 36 0
 123               	/* #NOAPP */
 124 001c 6FEF      		ldi r22,lo8(-1)
 125 001e 73EC      		ldi r23,lo8(-61)
 126 0020 8FE0      		ldi r24,lo8(15)
 127 0022 90E0      		ldi r25,0
 128 0024 00D0      		rcall sendData
 129               	.LVL6:
 130               	.LBB11:
 131               	.LBB12:
 132               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 133               		.loc 2 187 0
 134 0026 2FEF      		ldi r18,lo8(799999)
 135 0028 84E3      		ldi r24,hi8(799999)
 136 002a 9CE0      		ldi r25,hlo8(799999)
 137 002c 2150      	1:	subi r18,1
 138 002e 8040      		sbci r24,0
 139 0030 9040      		sbci r25,0
 140 0032 01F4      		brne 1b
 141 0034 00C0      		rjmp .
 142 0036 0000      		nop
 143               	.LVL7:
 144               	.LBE12:
 145               	.LBE11:
  37:main.c        ****     _delay_ms(250);
  38:main.c        ****     sendData(0b11000000001111111111);
 146               		.loc 1 38 0
 147 0038 6FEF      		ldi r22,lo8(-1)
 148 003a 73E0      		ldi r23,lo8(3)
 149 003c 8CE0      		ldi r24,lo8(12)
 150 003e 90E0      		ldi r25,0
 151 0040 00D0      		rcall sendData
 152               	.LVL8:
 153               	.LBB13:
 154               	.LBB14:
 155               		.loc 2 187 0
 156 0042 2FEF      		ldi r18,lo8(799999)
 157 0044 84E3      		ldi r24,hi8(799999)
 158 0046 9CE0      		ldi r25,hlo8(799999)
 159 0048 2150      	1:	subi r18,1
 160 004a 8040      		sbci r24,0
 161 004c 9040      		sbci r25,0
 162 004e 01F4      		brne 1b
 163 0050 00C0      		rjmp .
 164 0052 0000      		nop
 165               	.LVL9:
 166               	.LBE14:
 167               	.LBE13:
  39:main.c        ****     _delay_ms(250);
  40:main.c        ****     sendData(0b00001100001111111111);
 168               		.loc 1 40 0
 169 0054 6FEF      		ldi r22,lo8(-1)
 170 0056 73EC      		ldi r23,lo8(-61)
 171 0058 80E0      		ldi r24,0
 172 005a 90E0      		ldi r25,0
 173 005c 00D0      		rcall sendData
 174               	.LVL10:
 175               	.LBB15:
 176               	.LBB16:
 177               		.loc 2 187 0
 178 005e 2FEF      		ldi r18,lo8(799999)
 179 0060 84E3      		ldi r24,hi8(799999)
 180 0062 9CE0      		ldi r25,hlo8(799999)
 181 0064 2150      	1:	subi r18,1
 182 0066 8040      		sbci r24,0
 183 0068 9040      		sbci r25,0
 184 006a 01F4      		brne 1b
 185 006c 00C0      		rjmp .
 186 006e 0000      		nop
 187               	.LVL11:
 188               	.LBE16:
 189               	.LBE15:
  41:main.c        ****     _delay_ms(250);
  42:main.c        ****     sendData(0b00110000001111111111);
 190               		.loc 1 42 0
 191 0070 6FEF      		ldi r22,lo8(-1)
 192 0072 73E0      		ldi r23,lo8(3)
 193 0074 83E0      		ldi r24,lo8(3)
 194 0076 90E0      		ldi r25,0
 195 0078 00D0      		rcall sendData
 196               	.LVL12:
 197               	.LBB17:
 198               	.LBB18:
 199               		.loc 2 187 0
 200 007a 2FEF      		ldi r18,lo8(799999)
 201 007c 84E3      		ldi r24,hi8(799999)
 202 007e 9CE0      		ldi r25,hlo8(799999)
 203 0080 2150      	1:	subi r18,1
 204 0082 8040      		sbci r24,0
 205 0084 9040      		sbci r25,0
 206 0086 01F4      		brne 1b
 207 0088 00C0      		rjmp .
 208 008a 0000      		nop
 209               	.LVL13:
 210               	.LBE18:
 211               	.LBE17:
  43:main.c        ****     _delay_ms(250);
  44:main.c        **** 	
  45:main.c        ****     #ifdef DELLONG
  46:main.c        **** 		TCCR1B|=(1<<CS12)|(1<<CS10);
 212               		.loc 1 46 0
 213 008c 8EB5      		in r24,0x2e
 214 008e 8560      		ori r24,lo8(5)
 215 0090 8EBD      		out 0x2e,r24
  47:main.c        **** 	#else
  48:main.c        **** 		TCCR1B|=(1<<CS12);//|(1<<CS10);
  49:main.c        **** 	#endif
  50:main.c        **** 	
  51:main.c        **** 	TCCR0B|=(1<<CS01)|(1<<CS00);
 216               		.loc 1 51 0
 217 0092 83B7      		in r24,0x33
 218 0094 8360      		ori r24,lo8(3)
 219 0096 83BF      		out 0x33,r24
  52:main.c        ****     
  53:main.c        ****     currentColor=tcolorV(RED);
 220               		.loc 1 53 0
 221 0098 60E0      		ldi r22,0
 222 009a 70E0      		ldi r23,0
 223 009c 8FEF      		ldi r24,lo8(-1)
 224 009e 90E0      		ldi r25,0
 225 00a0 00D0      		rcall tcolorV
 226               	.LVL14:
 227 00a2 6093 0000 		sts currentColor,r22
 228 00a6 7093 0000 		sts currentColor+1,r23
 229 00aa 8093 0000 		sts currentColor+2,r24
  54:main.c        ****     setCurrentTime(15,45,7,11);
 230               		.loc 1 54 0
 231 00ae 2BE0      		ldi r18,lo8(11)
 232 00b0 47E0      		ldi r20,lo8(7)
 233 00b2 6DE2      		ldi r22,lo8(45)
 234 00b4 8FE0      		ldi r24,lo8(15)
 235 00b6 00D0      		rcall setCurrentTime
 236               	.LVL15:
  55:main.c        **** 	//RTC_readTime(&currentTime);
  56:main.c        ****     currentTime.temp=11;
 237               		.loc 1 56 0
 238 00b8 8BE0      		ldi r24,lo8(11)
 239 00ba 8093 0000 		sts currentTime+4,r24
  57:main.c        ****     setLeds(currentTime,leds,currentColor);
 240               		.loc 1 57 0
 241 00be E090 0000 		lds r14,currentColor
 242 00c2 F090 0000 		lds r15,currentColor+1
 243 00c6 0091 0000 		lds r16,currentColor+2
 244 00ca 20E0      		ldi r18,lo8(leds)
 245 00cc 30E0      		ldi r19,hi8(leds)
 246 00ce 4091 0000 		lds r20,currentTime
 247 00d2 5091 0000 		lds r21,currentTime+1
 248 00d6 6091 0000 		lds r22,currentTime+2
 249 00da 7091 0000 		lds r23,currentTime+3
 250 00de 00D0      		rcall setLeds
 251               	.LVL16:
 252               	.L8:
 253 00e0 00C0      		rjmp .L8
 254               		.cfi_endproc
 255               	.LFE7:
 257               		.text
 258               	.global	__vector_8
 260               	__vector_8:
 261               	.LFB8:
  58:main.c        ****     
  59:main.c        ****     while(1){
  60:main.c        ****        
  61:main.c        ****     }
  62:main.c        ****     return(0);
  63:main.c        ****     
  64:main.c        **** }
  65:main.c        **** ISR( TIM1_OVF_vect ){
 262               		.loc 1 65 0
 263               		.cfi_startproc
 264 0044 1F92      		push r1
 265               	.LCFI2:
 266               		.cfi_def_cfa_offset 3
 267               		.cfi_offset 1, -2
 268 0046 0F92      		push r0
 269               	.LCFI3:
 270               		.cfi_def_cfa_offset 4
 271               		.cfi_offset 0, -3
 272 0048 0FB6      		in r0,__SREG__
 273 004a 0F92      		push r0
 274 004c 1124      		clr __zero_reg__
 275 004e EF92      		push r14
 276               	.LCFI4:
 277               		.cfi_def_cfa_offset 5
 278               		.cfi_offset 14, -4
 279 0050 FF92      		push r15
 280               	.LCFI5:
 281               		.cfi_def_cfa_offset 6
 282               		.cfi_offset 15, -5
 283 0052 0F93      		push r16
 284               	.LCFI6:
 285               		.cfi_def_cfa_offset 7
 286               		.cfi_offset 16, -6
 287 0054 2F93      		push r18
 288               	.LCFI7:
 289               		.cfi_def_cfa_offset 8
 290               		.cfi_offset 18, -7
 291 0056 3F93      		push r19
 292               	.LCFI8:
 293               		.cfi_def_cfa_offset 9
 294               		.cfi_offset 19, -8
 295 0058 4F93      		push r20
 296               	.LCFI9:
 297               		.cfi_def_cfa_offset 10
 298               		.cfi_offset 20, -9
 299 005a 5F93      		push r21
 300               	.LCFI10:
 301               		.cfi_def_cfa_offset 11
 302               		.cfi_offset 21, -10
 303 005c 6F93      		push r22
 304               	.LCFI11:
 305               		.cfi_def_cfa_offset 12
 306               		.cfi_offset 22, -11
 307 005e 7F93      		push r23
 308               	.LCFI12:
 309               		.cfi_def_cfa_offset 13
 310               		.cfi_offset 23, -12
 311 0060 8F93      		push r24
 312               	.LCFI13:
 313               		.cfi_def_cfa_offset 14
 314               		.cfi_offset 24, -13
 315 0062 9F93      		push r25
 316               	.LCFI14:
 317               		.cfi_def_cfa_offset 15
 318               		.cfi_offset 25, -14
 319 0064 AF93      		push r26
 320               	.LCFI15:
 321               		.cfi_def_cfa_offset 16
 322               		.cfi_offset 26, -15
 323 0066 BF93      		push r27
 324               	.LCFI16:
 325               		.cfi_def_cfa_offset 17
 326               		.cfi_offset 27, -16
 327 0068 EF93      		push r30
 328               	.LCFI17:
 329               		.cfi_def_cfa_offset 18
 330               		.cfi_offset 30, -17
 331 006a FF93      		push r31
 332               	.LCFI18:
 333               		.cfi_def_cfa_offset 19
 334               		.cfi_offset 31, -18
 335               	/* prologue: Signal */
 336               	/* frame size = 0 */
 337               	/* stack size = 18 */
 338               	.L__stack_usage = 18
  66:main.c        ****     PORTA^=LED;
 339               		.loc 1 66 0
 340 006c 9BB3      		in r25,0x1b
 341 006e 81E0      		ldi r24,lo8(1)
 342 0070 8927      		eor r24,r25
 343 0072 8BBB      		out 0x1b,r24
  67:main.c        ****     //RTC_readTime(&currentTime);
  68:main.c        ****     setLeds(currentTime,leds,currentColor);
 344               		.loc 1 68 0
 345 0074 E090 0000 		lds r14,currentColor
 346 0078 F090 0000 		lds r15,currentColor+1
 347 007c 0091 0000 		lds r16,currentColor+2
 348 0080 20E0      		ldi r18,lo8(leds)
 349 0082 30E0      		ldi r19,hi8(leds)
 350 0084 4091 0000 		lds r20,currentTime
 351 0088 5091 0000 		lds r21,currentTime+1
 352 008c 6091 0000 		lds r22,currentTime+2
 353 0090 7091 0000 		lds r23,currentTime+3
 354 0094 8091 0000 		lds r24,currentTime+4
 355 0098 00D0      		rcall setLeds
 356               	.LVL17:
 357               	/* epilogue start */
  69:main.c        **** }
 358               		.loc 1 69 0
 359 009a FF91      		pop r31
 360 009c EF91      		pop r30
 361 009e BF91      		pop r27
 362 00a0 AF91      		pop r26
 363 00a2 9F91      		pop r25
 364 00a4 8F91      		pop r24
 365 00a6 7F91      		pop r23
 366 00a8 6F91      		pop r22
 367 00aa 5F91      		pop r21
 368 00ac 4F91      		pop r20
 369 00ae 3F91      		pop r19
 370 00b0 2F91      		pop r18
 371 00b2 0F91      		pop r16
 372 00b4 FF90      		pop r15
 373 00b6 EF90      		pop r14
 374 00b8 0F90      		pop r0
 375 00ba 0FBE      		out __SREG__,r0
 376 00bc 0F90      		pop r0
 377 00be 1F90      		pop r1
 378 00c0 1895      		reti
 379               		.cfi_endproc
 380               	.LFE8:
 382               	.global	__vector_11
 384               	__vector_11:
 385               	.LFB9:
  70:main.c        **** ISR( TIM0_OVF_vect ){
 386               		.loc 1 70 0
 387               		.cfi_startproc
 388 00c2 1F92      		push r1
 389               	.LCFI19:
 390               		.cfi_def_cfa_offset 3
 391               		.cfi_offset 1, -2
 392 00c4 0F92      		push r0
 393               	.LCFI20:
 394               		.cfi_def_cfa_offset 4
 395               		.cfi_offset 0, -3
 396 00c6 0FB6      		in r0,__SREG__
 397 00c8 0F92      		push r0
 398 00ca 1124      		clr __zero_reg__
 399 00cc 2F93      		push r18
 400               	.LCFI21:
 401               		.cfi_def_cfa_offset 5
 402               		.cfi_offset 18, -4
 403 00ce 3F93      		push r19
 404               	.LCFI22:
 405               		.cfi_def_cfa_offset 6
 406               		.cfi_offset 19, -5
 407 00d0 4F93      		push r20
 408               	.LCFI23:
 409               		.cfi_def_cfa_offset 7
 410               		.cfi_offset 20, -6
 411 00d2 5F93      		push r21
 412               	.LCFI24:
 413               		.cfi_def_cfa_offset 8
 414               		.cfi_offset 21, -7
 415 00d4 6F93      		push r22
 416               	.LCFI25:
 417               		.cfi_def_cfa_offset 9
 418               		.cfi_offset 22, -8
 419 00d6 7F93      		push r23
 420               	.LCFI26:
 421               		.cfi_def_cfa_offset 10
 422               		.cfi_offset 23, -9
 423 00d8 8F93      		push r24
 424               	.LCFI27:
 425               		.cfi_def_cfa_offset 11
 426               		.cfi_offset 24, -10
 427 00da 9F93      		push r25
 428               	.LCFI28:
 429               		.cfi_def_cfa_offset 12
 430               		.cfi_offset 25, -11
 431 00dc AF93      		push r26
 432               	.LCFI29:
 433               		.cfi_def_cfa_offset 13
 434               		.cfi_offset 26, -12
 435 00de BF93      		push r27
 436               	.LCFI30:
 437               		.cfi_def_cfa_offset 14
 438               		.cfi_offset 27, -13
 439 00e0 EF93      		push r30
 440               	.LCFI31:
 441               		.cfi_def_cfa_offset 15
 442               		.cfi_offset 30, -14
 443 00e2 FF93      		push r31
 444               	.LCFI32:
 445               		.cfi_def_cfa_offset 16
 446               		.cfi_offset 31, -15
 447               	/* prologue: Signal */
 448               	/* frame size = 0 */
 449               	/* stack size = 15 */
 450               	.L__stack_usage = 15
  71:main.c        ****     switch(state){
 451               		.loc 1 71 0
 452 00e4 8091 0000 		lds r24,state
 453 00e8 8230      		cpi r24,lo8(2)
 454 00ea 01F0      		breq .L12
 455 00ec 00F4      		brsh .L13
 456 00ee 8823      		tst r24
 457 00f0 01F0      		breq .L14
 458 00f2 8130      		cpi r24,lo8(1)
 459 00f4 01F0      		breq .+2
 460 00f6 00C0      		rjmp .L11
  72:main.c        ****         case 0:
  73:main.c        ****             sendData(R2 | getDataByColor(tcolor(1,0,0),0,leds));
  74:main.c        ****             break;
  75:main.c        ****         case 1:
  76:main.c        ****             sendData(R1 | getDataByColor(tcolor(1,0,0),1,leds));
 461               		.loc 1 76 0
 462 00f8 40E0      		ldi r20,0
 463 00fa 60E0      		ldi r22,0
 464 00fc 81E0      		ldi r24,lo8(1)
 465 00fe 00D0      		rcall tcolor
 466               	.LVL18:
 467 0100 20E0      		ldi r18,lo8(leds)
 468 0102 30E0      		ldi r19,hi8(leds)
 469 0104 41E0      		ldi r20,lo8(1)
 470 0106 00D0      		rcall getDataByColor
 471               	.LVL19:
 472 0108 7068      		ori r23,128
 473 010a 00C0      		rjmp .L20
 474               	.L13:
  71:main.c        ****     switch(state){
 475               		.loc 1 71 0
 476 010c 8430      		cpi r24,lo8(4)
 477 010e 01F0      		breq .L16
 478 0110 00F0      		brlo .L17
 479 0112 8530      		cpi r24,lo8(5)
 480 0114 01F4      		brne .L11
  77:main.c        ****             break;
  78:main.c        ****         case 2:
  79:main.c        ****             sendData(G2 | getDataByColor(tcolor(0,1,0),0,leds));
  80:main.c        ****             break;
  81:main.c        ****         case 3:
  82:main.c        ****             sendData(G1 | getDataByColor(tcolor(0,1,0),1,leds));
  83:main.c        ****             break;
  84:main.c        ****         case 4:
  85:main.c        ****             sendData(B2 | getDataByColor(tcolor(0,0,1),0,leds));
  86:main.c        ****             break;
  87:main.c        ****         case 5:
  88:main.c        ****             sendData(B1 | getDataByColor(tcolor(0,0,1),1,leds));
 481               		.loc 1 88 0
 482 0116 41E0      		ldi r20,lo8(1)
 483 0118 60E0      		ldi r22,0
 484 011a 80E0      		ldi r24,0
 485 011c 00D0      		rcall tcolor
 486               	.LVL20:
 487 011e 20E0      		ldi r18,lo8(leds)
 488 0120 30E0      		ldi r19,hi8(leds)
 489 0122 41E0      		ldi r20,lo8(1)
 490 0124 00D0      		rcall getDataByColor
 491               	.LVL21:
 492 0126 8160      		ori r24,1
 493 0128 00C0      		rjmp .L20
 494               	.L14:
  73:main.c        ****             break;
 495               		.loc 1 73 0
 496 012a 40E0      		ldi r20,0
 497 012c 60E0      		ldi r22,0
 498 012e 81E0      		ldi r24,lo8(1)
 499 0130 00D0      		rcall tcolor
 500               	.LVL22:
 501 0132 20E0      		ldi r18,lo8(leds)
 502 0134 30E0      		ldi r19,hi8(leds)
 503 0136 40E0      		ldi r20,0
 504 0138 00D0      		rcall getDataByColor
 505               	.LVL23:
 506 013a 7064      		ori r23,64
 507 013c 00C0      		rjmp .L20
 508               	.L12:
  79:main.c        ****             break;
 509               		.loc 1 79 0
 510 013e 40E0      		ldi r20,0
 511 0140 61E0      		ldi r22,lo8(1)
 512 0142 80E0      		ldi r24,0
 513 0144 00D0      		rcall tcolor
 514               	.LVL24:
 515 0146 20E0      		ldi r18,lo8(leds)
 516 0148 30E0      		ldi r19,hi8(leds)
 517 014a 40E0      		ldi r20,0
 518 014c 00D0      		rcall getDataByColor
 519               	.LVL25:
 520 014e 8460      		ori r24,4
 521 0150 00C0      		rjmp .L20
 522               	.L17:
  82:main.c        ****             break;
 523               		.loc 1 82 0
 524 0152 40E0      		ldi r20,0
 525 0154 61E0      		ldi r22,lo8(1)
 526 0156 80E0      		ldi r24,0
 527 0158 00D0      		rcall tcolor
 528               	.LVL26:
 529 015a 20E0      		ldi r18,lo8(leds)
 530 015c 30E0      		ldi r19,hi8(leds)
 531 015e 41E0      		ldi r20,lo8(1)
 532 0160 00D0      		rcall getDataByColor
 533               	.LVL27:
 534 0162 8860      		ori r24,8
 535 0164 00C0      		rjmp .L20
 536               	.L16:
  85:main.c        ****             break;
 537               		.loc 1 85 0
 538 0166 41E0      		ldi r20,lo8(1)
 539 0168 60E0      		ldi r22,0
 540 016a 80E0      		ldi r24,0
 541 016c 00D0      		rcall tcolor
 542               	.LVL28:
 543 016e 20E0      		ldi r18,lo8(leds)
 544 0170 30E0      		ldi r19,hi8(leds)
 545 0172 40E0      		ldi r20,0
 546 0174 00D0      		rcall getDataByColor
 547               	.LVL29:
 548 0176 8260      		ori r24,2
 549               	.L20:
 550               		.loc 1 88 0
 551 0178 00D0      		rcall sendData
 552               	.LVL30:
 553               	.L11:
  89:main.c        ****             break;
  90:main.c        ****     }
  91:main.c        ****     state++;
 554               		.loc 1 91 0
 555 017a 8091 0000 		lds r24,state
 556 017e 8F5F      		subi r24,lo8(-(1))
 557 0180 8093 0000 		sts state,r24
  92:main.c        ****     if(state>5)state=0;
 558               		.loc 1 92 0
 559 0184 8091 0000 		lds r24,state
 560 0188 8630      		cpi r24,lo8(6)
 561 018a 00F0      		brlo .L10
 562               		.loc 1 92 0 is_stmt 0 discriminator 1
 563 018c 1092 0000 		sts state,__zero_reg__
 564               	.L10:
 565               	/* epilogue start */
  93:main.c        **** }
 566               		.loc 1 93 0 is_stmt 1
 567 0190 FF91      		pop r31
 568 0192 EF91      		pop r30
 569 0194 BF91      		pop r27
 570 0196 AF91      		pop r26
 571 0198 9F91      		pop r25
 572 019a 8F91      		pop r24
 573 019c 7F91      		pop r23
 574 019e 6F91      		pop r22
 575 01a0 5F91      		pop r21
 576 01a2 4F91      		pop r20
 577 01a4 3F91      		pop r19
 578 01a6 2F91      		pop r18
 579 01a8 0F90      		pop r0
 580 01aa 0FBE      		out __SREG__,r0
 581 01ac 0F90      		pop r0
 582 01ae 1F90      		pop r1
 583 01b0 1895      		reti
 584               		.cfi_endproc
 585               	.LFE9:
 587               		.comm	leds,95,1
 588               	.global	state
 589               		.section .bss
 592               	state:
 593 0000 00        		.zero	1
 594               		.comm	currentColor,3,1
 595               		.comm	USI_I2C_Master_State,1,1
 596               		.comm	currentTime,5,1
 597               		.text
 598               	.Letext0:
 599               		.file 3 "/usr/lib/avr/include/stdint.h"
 600               		.file 4 "RTC.h"
 601               		.file 5 "Led.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cclfHANb.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cclfHANb.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cclfHANb.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cclfHANb.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cclfHANb.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cclfHANb.s:12     .text:0000000000000000 sendData
     /tmp/cclfHANb.s:90     .text.startup:0000000000000000 main
                            *COM*:000000000000005f leds
                            *COM*:0000000000000003 currentColor
                            *COM*:0000000000000005 currentTime
     /tmp/cclfHANb.s:260    .text:0000000000000044 __vector_8
     /tmp/cclfHANb.s:384    .text:00000000000000c2 __vector_11
     /tmp/cclfHANb.s:592    .bss:0000000000000000 state
                            *COM*:0000000000000001 USI_I2C_Master_State

UNDEFINED SYMBOLS
ledInit
tcolorV
setCurrentTime
setLeds
tcolor
getDataByColor
__do_clear_bss
