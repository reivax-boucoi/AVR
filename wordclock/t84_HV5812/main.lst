   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	sendData
  12               	sendData:
  13               	.LFB6:
  14               		.file 1 "main.c"
   1:main.c        **** #define F_CPU 16000000UL
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** #include <util/delay.h>
   5:main.c        **** #include "defines.h"
   6:main.c        **** #include "Led.h"
   7:main.c        **** #include "RTC.h"
   8:main.c        **** #include "Menu.h"
   9:main.c        **** 
  10:main.c        **** uint8_t ledr=0;
  11:main.c        **** uint8_t ledb=0;
  12:main.c        **** 
  13:main.c        **** void sendData(uint32_t data){
  15               		.loc 1 13 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  14:main.c        ****     if(ledr)data|=LEDR;
  22               		.loc 1 14 0
  23 0000 2091 0000 		lds r18,ledr
  24 0004 2111      		cpse r18,__zero_reg__
  25               		.loc 1 14 0 is_stmt 0 discriminator 1
  26 0006 7860      		ori r23,8
  27               	.LVL1:
  28               	.L2:
  15:main.c        ****     if(ledb)data|=LEDB;
  29               		.loc 1 15 0 is_stmt 1
  30 0008 2091 0000 		lds r18,ledb
  31 000c 2111      		cpse r18,__zero_reg__
  32               		.loc 1 15 0 is_stmt 0 discriminator 1
  33 000e 7460      		ori r23,4
  34               	.LVL2:
  35               	.L3:
  16:main.c        ****     sendRawData(data);
  36               		.loc 1 16 0 is_stmt 1
  37 0010 00C0      		rjmp sendRawData
  38               	.LVL3:
  39               		.cfi_endproc
  40               	.LFE6:
  42               		.section	.text.startup,"ax",@progbits
  43               	.global	main
  45               	main:
  46               	.LFB7:
  17:main.c        **** }
  18:main.c        **** 
  19:main.c        **** 
  20:main.c        **** volatile uint8_t state=0;
  21:main.c        **** const Menu* Mcurrent=0;
  22:main.c        **** uint8_t Mindex=0;
  23:main.c        **** Led leds[NBLEDS];
  24:main.c        **** 
  25:main.c        **** int main(void){    
  47               		.loc 1 25 0
  48               		.cfi_startproc
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
  26:main.c        ****     ledInit(leds);
  53               		.loc 1 26 0
  54 0000 80E0      		ldi r24,lo8(leds)
  55 0002 90E0      		ldi r25,hi8(leds)
  56 0004 00D0      		rcall ledInit
  57               	.LVL4:
  27:main.c        ****     DDRA&=~(BTNINTERNAL|BTNOK);
  58               		.loc 1 27 0
  59 0006 8AB3      		in r24,0x1a
  60 0008 8F75      		andi r24,lo8(95)
  61 000a 8ABB      		out 0x1a,r24
  28:main.c        ****     DDRB&=~BTNSELECT;
  62               		.loc 1 28 0
  63 000c BA98      		cbi 0x17,2
  29:main.c        ****     PORTA|=(BTNINTERNAL|BTNOK);
  64               		.loc 1 29 0
  65 000e 8BB3      		in r24,0x1b
  66 0010 806A      		ori r24,lo8(-96)
  67 0012 8BBB      		out 0x1b,r24
  30:main.c        ****     PORTB|=BTNSELECT;
  68               		.loc 1 30 0
  69 0014 C29A      		sbi 0x18,2
  31:main.c        ****     TIMSK1|=(1<<TOIE1);//|(1<<OCIE1B);
  70               		.loc 1 31 0
  71 0016 609A      		sbi 0xc,0
  32:main.c        ****    // OCR1B=32768;
  33:main.c        ****     TIMSK0|=(1<<TOIE0);
  72               		.loc 1 33 0
  73 0018 89B7      		in r24,0x39
  74 001a 8160      		ori r24,lo8(1)
  75 001c 89BF      		out 0x39,r24
  34:main.c        ****     
  35:main.c        ****     sendData(0b11111100001111111111);//white
  76               		.loc 1 35 0
  77 001e 6FEF      		ldi r22,lo8(-1)
  78 0020 73EC      		ldi r23,lo8(-61)
  79 0022 8FE0      		ldi r24,lo8(15)
  80 0024 90E0      		ldi r25,0
  81 0026 00D0      		rcall sendData
  82               	.LVL5:
  83               	.LBB16:
  84               	.LBB17:
  85               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  86               		.loc 2 187 0
  87 0028 2FEF      		ldi r18,lo8(1599999)
  88 002a 89E6      		ldi r24,hi8(1599999)
  89 002c 98E1      		ldi r25,hlo8(1599999)
  90 002e 2150      	1:	subi r18,1
  91 0030 8040      		sbci r24,0
  92 0032 9040      		sbci r25,0
  93 0034 01F4      		brne 1b
  94 0036 00C0      		rjmp .
  95 0038 0000      		nop
  96               	.LVL6:
  97               	.LBE17:
  98               	.LBE16:
  36:main.c        ****     _delay_ms(500);
  37:main.c        ****     sendData(0b11000000001111111111);//green
  99               		.loc 1 37 0
 100 003a 6FEF      		ldi r22,lo8(-1)
 101 003c 73E0      		ldi r23,lo8(3)
 102 003e 8CE0      		ldi r24,lo8(12)
 103 0040 90E0      		ldi r25,0
 104 0042 00D0      		rcall sendData
 105               	.LVL7:
 106               	.LBB18:
 107               	.LBB19:
 108               		.loc 2 187 0
 109 0044 2FEF      		ldi r18,lo8(1599999)
 110 0046 89E6      		ldi r24,hi8(1599999)
 111 0048 98E1      		ldi r25,hlo8(1599999)
 112 004a 2150      	1:	subi r18,1
 113 004c 8040      		sbci r24,0
 114 004e 9040      		sbci r25,0
 115 0050 01F4      		brne 1b
 116 0052 00C0      		rjmp .
 117 0054 0000      		nop
 118               	.LVL8:
 119               	.LBE19:
 120               	.LBE18:
  38:main.c        ****     _delay_ms(500);
  39:main.c        ****     sendData(0b00001100001111111111);//red
 121               		.loc 1 39 0
 122 0056 6FEF      		ldi r22,lo8(-1)
 123 0058 73EC      		ldi r23,lo8(-61)
 124 005a 80E0      		ldi r24,0
 125 005c 90E0      		ldi r25,0
 126 005e 00D0      		rcall sendData
 127               	.LVL9:
 128               	.LBB20:
 129               	.LBB21:
 130               		.loc 2 187 0
 131 0060 2FEF      		ldi r18,lo8(1599999)
 132 0062 89E6      		ldi r24,hi8(1599999)
 133 0064 98E1      		ldi r25,hlo8(1599999)
 134 0066 2150      	1:	subi r18,1
 135 0068 8040      		sbci r24,0
 136 006a 9040      		sbci r25,0
 137 006c 01F4      		brne 1b
 138 006e 00C0      		rjmp .
 139 0070 0000      		nop
 140               	.LVL10:
 141               	.LBE21:
 142               	.LBE20:
  40:main.c        ****     _delay_ms(500);
  41:main.c        ****     sendData(0b00110000001111111111);//blue
 143               		.loc 1 41 0
 144 0072 6FEF      		ldi r22,lo8(-1)
 145 0074 73E0      		ldi r23,lo8(3)
 146 0076 83E0      		ldi r24,lo8(3)
 147 0078 90E0      		ldi r25,0
 148 007a 00D0      		rcall sendData
 149               	.LVL11:
 150               	.LBB22:
 151               	.LBB23:
 152               		.loc 2 187 0
 153 007c 2FEF      		ldi r18,lo8(1599999)
 154 007e 89E6      		ldi r24,hi8(1599999)
 155 0080 98E1      		ldi r25,hlo8(1599999)
 156 0082 2150      	1:	subi r18,1
 157 0084 8040      		sbci r24,0
 158 0086 9040      		sbci r25,0
 159 0088 01F4      		brne 1b
 160 008a 00C0      		rjmp .
 161 008c 0000      		nop
 162               	.LVL12:
 163               	.LBE23:
 164               	.LBE22:
  42:main.c        ****     _delay_ms(500);
  43:main.c        ****     sendData(0b11110000001111111111);//cyan
 165               		.loc 1 43 0
 166 008e 6FEF      		ldi r22,lo8(-1)
 167 0090 73E0      		ldi r23,lo8(3)
 168 0092 8FE0      		ldi r24,lo8(15)
 169 0094 90E0      		ldi r25,0
 170 0096 00D0      		rcall sendData
 171               	.LVL13:
 172               	.LBB24:
 173               	.LBB25:
 174               		.loc 2 187 0
 175 0098 2FEF      		ldi r18,lo8(1599999)
 176 009a 89E6      		ldi r24,hi8(1599999)
 177 009c 98E1      		ldi r25,hlo8(1599999)
 178 009e 2150      	1:	subi r18,1
 179 00a0 8040      		sbci r24,0
 180 00a2 9040      		sbci r25,0
 181 00a4 01F4      		brne 1b
 182 00a6 00C0      		rjmp .
 183 00a8 0000      		nop
 184               	.LVL14:
 185               	.LBE25:
 186               	.LBE24:
  44:main.c        ****     _delay_ms(500);
  45:main.c        ****     sendData(0b00111100001111111111);//magenta
 187               		.loc 1 45 0
 188 00aa 6FEF      		ldi r22,lo8(-1)
 189 00ac 73EC      		ldi r23,lo8(-61)
 190 00ae 83E0      		ldi r24,lo8(3)
 191 00b0 90E0      		ldi r25,0
 192 00b2 00D0      		rcall sendData
 193               	.LVL15:
 194               	.LBB26:
 195               	.LBB27:
 196               		.loc 2 187 0
 197 00b4 2FEF      		ldi r18,lo8(1599999)
 198 00b6 89E6      		ldi r24,hi8(1599999)
 199 00b8 98E1      		ldi r25,hlo8(1599999)
 200 00ba 2150      	1:	subi r18,1
 201 00bc 8040      		sbci r24,0
 202 00be 9040      		sbci r25,0
 203 00c0 01F4      		brne 1b
 204 00c2 00C0      		rjmp .
 205 00c4 0000      		nop
 206               	.LVL16:
 207               	.LBE27:
 208               	.LBE26:
  46:main.c        ****     _delay_ms(500);
  47:main.c        ****     sendData(0b11001100001111111111);//yellow
 209               		.loc 1 47 0
 210 00c6 6FEF      		ldi r22,lo8(-1)
 211 00c8 73EC      		ldi r23,lo8(-61)
 212 00ca 8CE0      		ldi r24,lo8(12)
 213 00cc 90E0      		ldi r25,0
 214 00ce 00D0      		rcall sendData
 215               	.LVL17:
 216               	.LBB28:
 217               	.LBB29:
 218               		.loc 2 187 0
 219 00d0 2FEF      		ldi r18,lo8(1599999)
 220 00d2 89E6      		ldi r24,hi8(1599999)
 221 00d4 98E1      		ldi r25,hlo8(1599999)
 222 00d6 2150      	1:	subi r18,1
 223 00d8 8040      		sbci r24,0
 224 00da 9040      		sbci r25,0
 225 00dc 01F4      		brne 1b
 226 00de 00C0      		rjmp .
 227 00e0 0000      		nop
 228               	.LVL18:
 229               	.LBE29:
 230               	.LBE28:
  48:main.c        ****     _delay_ms(500);
  49:main.c        ****     
  50:main.c        ****     //no sooner to let inputs debounce
  51:main.c        ****     GIMSK|=(1<<PCIE1)|(1<<PCIE0);
 231               		.loc 1 51 0
 232 00e2 8BB7      		in r24,0x3b
 233 00e4 8063      		ori r24,lo8(48)
 234 00e6 8BBF      		out 0x3b,r24
  52:main.c        ****     PCMSK0|=(1<<PCINT7)|(1<<PCINT5);
 235               		.loc 1 52 0
 236 00e8 82B3      		in r24,0x12
 237 00ea 806A      		ori r24,lo8(-96)
 238 00ec 82BB      		out 0x12,r24
  53:main.c        ****     PCMSK1|=(1<<PCINT10);
 239               		.loc 1 53 0
 240 00ee 80B5      		in r24,0x20
 241 00f0 8460      		ori r24,lo8(4)
 242 00f2 80BD      		out 0x20,r24
  54:main.c        ****     sei();
 243               		.loc 1 54 0
 244               	/* #APP */
 245               	 ;  54 "main.c" 1
 246 00f4 7894      		sei
 247               	 ;  0 "" 2
  55:main.c        ****     
  56:main.c        ****     //update time & UI timer
  57:main.c        ****     #ifdef DELLONG
  58:main.c        ****     TCCR1B|=(1<<CS12)|(1<<CS10);
 248               		.loc 1 58 0
 249               	/* #NOAPP */
 250 00f6 8EB5      		in r24,0x2e
 251 00f8 8560      		ori r24,lo8(5)
 252 00fa 8EBD      		out 0x2e,r24
  59:main.c        ****     #else
  60:main.c        ****     TCCR1B|=(1<<CS12);//|(1<<CS10);
  61:main.c        ****     #endif
  62:main.c        ****     
  63:main.c        ****     //led mux timer
  64:main.c        ****     TCCR0B|=(1<<CS01)|(1<<CS00);
 253               		.loc 1 64 0
 254 00fc 83B7      		in r24,0x33
 255 00fe 8360      		ori r24,lo8(3)
 256 0100 83BF      		out 0x33,r24
  65:main.c        ****     
  66:main.c        ****     Minit();
 257               		.loc 1 66 0
 258 0102 00D0      		rcall Minit
 259               	.LVL19:
  67:main.c        ****     // //RTC_setTime(currentTime,6,18);
  68:main.c        ****     RTC_readTime(&currentTime);
 260               		.loc 1 68 0
 261 0104 80E0      		ldi r24,lo8(currentTime)
 262 0106 90E0      		ldi r25,hi8(currentTime)
 263 0108 00D0      		rcall RTC_readTime
 264               	.LVL20:
 265               	.L12:
 266 010a 00C0      		rjmp .L12
 267               		.cfi_endproc
 268               	.LFE7:
 270               		.text
 271               	.global	__vector_3
 273               	__vector_3:
 274               	.LFB8:
  69:main.c        ****     while(1){
  70:main.c        ****     }
  71:main.c        ****     return(0);
  72:main.c        ****     
  73:main.c        **** }
  74:main.c        **** ISR( PCINT1_vect){
 275               		.loc 1 74 0
 276               		.cfi_startproc
 277 0012 1F92      		push r1
 278               	.LCFI0:
 279               		.cfi_def_cfa_offset 3
 280               		.cfi_offset 1, -2
 281 0014 0F92      		push r0
 282               	.LCFI1:
 283               		.cfi_def_cfa_offset 4
 284               		.cfi_offset 0, -3
 285 0016 0FB6      		in r0,__SREG__
 286 0018 0F92      		push r0
 287 001a 1124      		clr __zero_reg__
 288 001c 2F93      		push r18
 289               	.LCFI2:
 290               		.cfi_def_cfa_offset 5
 291               		.cfi_offset 18, -4
 292 001e 3F93      		push r19
 293               	.LCFI3:
 294               		.cfi_def_cfa_offset 6
 295               		.cfi_offset 19, -5
 296 0020 4F93      		push r20
 297               	.LCFI4:
 298               		.cfi_def_cfa_offset 7
 299               		.cfi_offset 20, -6
 300 0022 5F93      		push r21
 301               	.LCFI5:
 302               		.cfi_def_cfa_offset 8
 303               		.cfi_offset 21, -7
 304 0024 6F93      		push r22
 305               	.LCFI6:
 306               		.cfi_def_cfa_offset 9
 307               		.cfi_offset 22, -8
 308 0026 7F93      		push r23
 309               	.LCFI7:
 310               		.cfi_def_cfa_offset 10
 311               		.cfi_offset 23, -9
 312 0028 8F93      		push r24
 313               	.LCFI8:
 314               		.cfi_def_cfa_offset 11
 315               		.cfi_offset 24, -10
 316 002a 9F93      		push r25
 317               	.LCFI9:
 318               		.cfi_def_cfa_offset 12
 319               		.cfi_offset 25, -11
 320 002c AF93      		push r26
 321               	.LCFI10:
 322               		.cfi_def_cfa_offset 13
 323               		.cfi_offset 26, -12
 324 002e BF93      		push r27
 325               	.LCFI11:
 326               		.cfi_def_cfa_offset 14
 327               		.cfi_offset 27, -13
 328 0030 EF93      		push r30
 329               	.LCFI12:
 330               		.cfi_def_cfa_offset 15
 331               		.cfi_offset 30, -14
 332 0032 FF93      		push r31
 333               	.LCFI13:
 334               		.cfi_def_cfa_offset 16
 335               		.cfi_offset 31, -15
 336               	/* prologue: Signal */
 337               	/* frame size = 0 */
 338               	/* stack size = 15 */
 339               	.L__stack_usage = 15
  75:main.c        ****     if(PINB&BTNSELECT && Mcurrent){
 340               		.loc 1 75 0
 341 0034 B29B      		sbis 0x16,2
 342 0036 00C0      		rjmp .L13
 343               		.loc 1 75 0 is_stmt 0 discriminator 1
 344 0038 8091 0000 		lds r24,Mcurrent
 345 003c 9091 0000 		lds r25,Mcurrent+1
 346 0040 0097      		sbiw r24,0
 347 0042 01F0      		breq .L13
  76:main.c        ****         Mindex=findNextEntry(Mcurrent,Mindex);
 348               		.loc 1 76 0 is_stmt 1
 349 0044 6091 0000 		lds r22,Mindex
 350 0048 00D0      		rcall findNextEntry
 351               	.LVL21:
 352 004a 8093 0000 		sts Mindex,r24
  77:main.c        ****         TCNT1=65534;//get straight to led update
 353               		.loc 1 77 0
 354 004e 8EEF      		ldi r24,lo8(-2)
 355 0050 9FEF      		ldi r25,lo8(-1)
 356 0052 9DBD      		out 0x2c+1,r25
 357 0054 8CBD      		out 0x2c,r24
 358               	.L13:
 359               	/* epilogue start */
  78:main.c        ****     }
  79:main.c        **** }
 360               		.loc 1 79 0
 361 0056 FF91      		pop r31
 362 0058 EF91      		pop r30
 363 005a BF91      		pop r27
 364 005c AF91      		pop r26
 365 005e 9F91      		pop r25
 366 0060 8F91      		pop r24
 367 0062 7F91      		pop r23
 368 0064 6F91      		pop r22
 369 0066 5F91      		pop r21
 370 0068 4F91      		pop r20
 371 006a 3F91      		pop r19
 372 006c 2F91      		pop r18
 373 006e 0F90      		pop r0
 374 0070 0FBE      		out __SREG__,r0
 375 0072 0F90      		pop r0
 376 0074 1F90      		pop r1
 377 0076 1895      		reti
 378               		.cfi_endproc
 379               	.LFE8:
 381               	.global	__vector_2
 383               	__vector_2:
 384               	.LFB9:
  80:main.c        **** ISR( PCINT0_vect){
 385               		.loc 1 80 0
 386               		.cfi_startproc
 387 0078 1F92      		push r1
 388               	.LCFI14:
 389               		.cfi_def_cfa_offset 3
 390               		.cfi_offset 1, -2
 391 007a 0F92      		push r0
 392               	.LCFI15:
 393               		.cfi_def_cfa_offset 4
 394               		.cfi_offset 0, -3
 395 007c 0FB6      		in r0,__SREG__
 396 007e 0F92      		push r0
 397 0080 1124      		clr __zero_reg__
 398 0082 2F93      		push r18
 399               	.LCFI16:
 400               		.cfi_def_cfa_offset 5
 401               		.cfi_offset 18, -4
 402 0084 3F93      		push r19
 403               	.LCFI17:
 404               		.cfi_def_cfa_offset 6
 405               		.cfi_offset 19, -5
 406 0086 4F93      		push r20
 407               	.LCFI18:
 408               		.cfi_def_cfa_offset 7
 409               		.cfi_offset 20, -6
 410 0088 5F93      		push r21
 411               	.LCFI19:
 412               		.cfi_def_cfa_offset 8
 413               		.cfi_offset 21, -7
 414 008a 6F93      		push r22
 415               	.LCFI20:
 416               		.cfi_def_cfa_offset 9
 417               		.cfi_offset 22, -8
 418 008c 7F93      		push r23
 419               	.LCFI21:
 420               		.cfi_def_cfa_offset 10
 421               		.cfi_offset 23, -9
 422 008e 8F93      		push r24
 423               	.LCFI22:
 424               		.cfi_def_cfa_offset 11
 425               		.cfi_offset 24, -10
 426 0090 9F93      		push r25
 427               	.LCFI23:
 428               		.cfi_def_cfa_offset 12
 429               		.cfi_offset 25, -11
 430 0092 AF93      		push r26
 431               	.LCFI24:
 432               		.cfi_def_cfa_offset 13
 433               		.cfi_offset 26, -12
 434 0094 BF93      		push r27
 435               	.LCFI25:
 436               		.cfi_def_cfa_offset 14
 437               		.cfi_offset 27, -13
 438 0096 CF93      		push r28
 439               	.LCFI26:
 440               		.cfi_def_cfa_offset 15
 441               		.cfi_offset 28, -14
 442 0098 DF93      		push r29
 443               	.LCFI27:
 444               		.cfi_def_cfa_offset 16
 445               		.cfi_offset 29, -15
 446 009a EF93      		push r30
 447               	.LCFI28:
 448               		.cfi_def_cfa_offset 17
 449               		.cfi_offset 30, -16
 450 009c FF93      		push r31
 451               	.LCFI29:
 452               		.cfi_def_cfa_offset 18
 453               		.cfi_offset 31, -17
 454               	/* prologue: Signal */
 455               	/* frame size = 0 */
 456               	/* stack size = 17 */
 457               	.L__stack_usage = 17
  81:main.c        ****     if(PINA&BTNOK){
 458               		.loc 1 81 0
 459 009e CF9B      		sbis 0x19,7
 460 00a0 00C0      		rjmp .L22
  82:main.c        ****         if(!Mcurrent){
 461               		.loc 1 82 0
 462 00a2 E091 0000 		lds r30,Mcurrent
 463 00a6 F091 0000 		lds r31,Mcurrent+1
 464 00aa 3097      		sbiw r30,0
 465 00ac 01F4      		brne .L23
  83:main.c        ****             Mcurrent=&M0main;//if not in menu mode
 466               		.loc 1 83 0
 467 00ae 80E0      		ldi r24,lo8(M0main)
 468 00b0 90E0      		ldi r25,hi8(M0main)
 469 00b2 9093 0000 		sts Mcurrent+1,r25
 470 00b6 8093 0000 		sts Mcurrent,r24
 471 00ba 00C0      		rjmp .L24
 472               	.L23:
  84:main.c        ****         }else{//enter menu and execute
  85:main.c        ****             if(Mcurrent->fptr!=0)Mcurrent->fptr(Mindex);//check if function is associated and selec
 473               		.loc 1 85 0
 474 00bc 0180      		ldd __tmp_reg__,Z+1
 475 00be F281      		ldd r31,Z+2
 476 00c0 E02D      		mov r30,__tmp_reg__
 477 00c2 3097      		sbiw r30,0
 478 00c4 01F0      		breq .L25
 479               		.loc 1 85 0 is_stmt 0 discriminator 1
 480 00c6 8091 0000 		lds r24,Mindex
 481 00ca 0995      		icall
 482               	.LVL22:
 483               	.L25:
  86:main.c        ****             Mcurrent=getSubMenu(Mcurrent,Mindex);//get new menu
 484               		.loc 1 86 0 is_stmt 1
 485 00cc 6091 0000 		lds r22,Mindex
 486 00d0 8091 0000 		lds r24,Mcurrent
 487 00d4 9091 0000 		lds r25,Mcurrent+1
 488 00d8 00D0      		rcall getSubMenu
 489               	.LVL23:
 490 00da 9093 0000 		sts Mcurrent+1,r25
 491 00de 8093 0000 		sts Mcurrent,r24
  87:main.c        ****             Mindex=0;
 492               		.loc 1 87 0
 493 00e2 1092 0000 		sts Mindex,__zero_reg__
 494               	.LVL24:
 495 00e6 C0E0      		ldi r28,lo8(leds)
 496 00e8 D0E0      		ldi r29,hi8(leds)
 497               	.LVL25:
 498               	.L26:
 499               	.LBB30:
  88:main.c        ****             for(uint8_t i=0;i<NBLEDS;i++){//clear display after changing settings
  89:main.c        ****                 ledOff(&leds[i]);
 500               		.loc 1 89 0 discriminator 3
 501 00ea CE01      		movw r24,r28
 502 00ec 00D0      		rcall ledOff
 503               	.LVL26:
 504 00ee 2396      		adiw r28,3
  88:main.c        ****             for(uint8_t i=0;i<NBLEDS;i++){//clear display after changing settings
 505               		.loc 1 88 0 discriminator 3
 506 00f0 80E0      		ldi r24,hi8(leds+57)
 507 00f2 C030      		cpi r28,lo8(leds+57)
 508 00f4 D807      		cpc r29,r24
 509 00f6 01F4      		brne .L26
 510               	.L24:
 511               	.LBE30:
  90:main.c        ****             }
  91:main.c        ****         }
  92:main.c        ****         TCNT1=65534;//get straight to led update
 512               		.loc 1 92 0
 513 00f8 8EEF      		ldi r24,lo8(-2)
 514 00fa 9FEF      		ldi r25,lo8(-1)
 515 00fc 9DBD      		out 0x2c+1,r25
 516 00fe 8CBD      		out 0x2c,r24
 517               	.L22:
  93:main.c        ****     }
  94:main.c        ****     if(PINA&BTNINTERNAL){//unused secret button
 518               		.loc 1 94 0
 519 0100 89B3      		in r24,0x19
 520               	/* epilogue start */
  95:main.c        ****     }
  96:main.c        **** }/*
 521               		.loc 1 96 0
 522 0102 FF91      		pop r31
 523 0104 EF91      		pop r30
 524 0106 DF91      		pop r29
 525 0108 CF91      		pop r28
 526 010a BF91      		pop r27
 527 010c AF91      		pop r26
 528 010e 9F91      		pop r25
 529 0110 8F91      		pop r24
 530 0112 7F91      		pop r23
 531 0114 6F91      		pop r22
 532 0116 5F91      		pop r21
 533 0118 4F91      		pop r20
 534 011a 3F91      		pop r19
 535 011c 2F91      		pop r18
 536 011e 0F90      		pop r0
 537 0120 0FBE      		out __SREG__,r0
 538 0122 0F90      		pop r0
 539 0124 1F90      		pop r1
 540 0126 1895      		reti
 541               		.cfi_endproc
 542               	.LFE9:
 544               	.global	__vector_8
 546               	__vector_8:
 547               	.LFB10:
  97:main.c        **** ISR( TIM1_COMPB_vect){
  98:main.c        **** }*/
  99:main.c        **** ISR( TIM1_OVF_vect ){
 548               		.loc 1 99 0
 549               		.cfi_startproc
 550 0128 1F92      		push r1
 551               	.LCFI30:
 552               		.cfi_def_cfa_offset 3
 553               		.cfi_offset 1, -2
 554 012a 0F92      		push r0
 555               	.LCFI31:
 556               		.cfi_def_cfa_offset 4
 557               		.cfi_offset 0, -3
 558 012c 0FB6      		in r0,__SREG__
 559 012e 0F92      		push r0
 560 0130 1124      		clr __zero_reg__
 561 0132 0F93      		push r16
 562               	.LCFI32:
 563               		.cfi_def_cfa_offset 5
 564               		.cfi_offset 16, -4
 565 0134 1F93      		push r17
 566               	.LCFI33:
 567               		.cfi_def_cfa_offset 6
 568               		.cfi_offset 17, -5
 569 0136 2F93      		push r18
 570               	.LCFI34:
 571               		.cfi_def_cfa_offset 7
 572               		.cfi_offset 18, -6
 573 0138 3F93      		push r19
 574               	.LCFI35:
 575               		.cfi_def_cfa_offset 8
 576               		.cfi_offset 19, -7
 577 013a 4F93      		push r20
 578               	.LCFI36:
 579               		.cfi_def_cfa_offset 9
 580               		.cfi_offset 20, -8
 581 013c 5F93      		push r21
 582               	.LCFI37:
 583               		.cfi_def_cfa_offset 10
 584               		.cfi_offset 21, -9
 585 013e 6F93      		push r22
 586               	.LCFI38:
 587               		.cfi_def_cfa_offset 11
 588               		.cfi_offset 22, -10
 589 0140 7F93      		push r23
 590               	.LCFI39:
 591               		.cfi_def_cfa_offset 12
 592               		.cfi_offset 23, -11
 593 0142 8F93      		push r24
 594               	.LCFI40:
 595               		.cfi_def_cfa_offset 13
 596               		.cfi_offset 24, -12
 597 0144 9F93      		push r25
 598               	.LCFI41:
 599               		.cfi_def_cfa_offset 14
 600               		.cfi_offset 25, -13
 601 0146 AF93      		push r26
 602               	.LCFI42:
 603               		.cfi_def_cfa_offset 15
 604               		.cfi_offset 26, -14
 605 0148 BF93      		push r27
 606               	.LCFI43:
 607               		.cfi_def_cfa_offset 16
 608               		.cfi_offset 27, -15
 609 014a CF93      		push r28
 610               	.LCFI44:
 611               		.cfi_def_cfa_offset 17
 612               		.cfi_offset 28, -16
 613 014c EF93      		push r30
 614               	.LCFI45:
 615               		.cfi_def_cfa_offset 18
 616               		.cfi_offset 30, -17
 617 014e FF93      		push r31
 618               	.LCFI46:
 619               		.cfi_def_cfa_offset 19
 620               		.cfi_offset 31, -18
 621               	/* prologue: Signal */
 622               	/* frame size = 0 */
 623               	/* stack size = 18 */
 624               	.L__stack_usage = 18
 100:main.c        ****     if(!Mcurrent){//if in normal display mode
 625               		.loc 1 100 0
 626 0150 8091 0000 		lds r24,Mcurrent
 627 0154 9091 0000 		lds r25,Mcurrent+1
 628 0158 892B      		or r24,r25
 629 015a 01F4      		brne .L32
 630               	.LBB31:
 101:main.c        ****         uint8_t m=getMode();
 631               		.loc 1 101 0
 632 015c 00D0      		rcall getMode
 633               	.LVL27:
 634 015e C82F      		mov r28,r24
 635               	.LVL28:
 102:main.c        ****         RTC_readTime(&currentTime);
 636               		.loc 1 102 0
 637 0160 80E0      		ldi r24,lo8(currentTime)
 638 0162 90E0      		ldi r25,hi8(currentTime)
 639               	.LVL29:
 640 0164 00D0      		rcall RTC_readTime
 641               	.LVL30:
 103:main.c        ****         if(isInAllowedTime(currentTime.hour)){
 642               		.loc 1 103 0
 643 0166 8091 0000 		lds r24,currentTime
 644 016a 00D0      		rcall isInAllowedTime
 645               	.LVL31:
 646 016c 8823      		tst r24
 647 016e 01F0      		breq .L33
 104:main.c        ****             if(m<2){
 648               		.loc 1 104 0
 649 0170 C230      		cpi r28,lo8(2)
 650 0172 00F4      		brsh .L34
 105:main.c        ****                 setLeds(currentTime,leds);
 651               		.loc 1 105 0
 652 0174 20E0      		ldi r18,lo8(leds)
 653 0176 30E0      		ldi r19,hi8(leds)
 654 0178 4091 0000 		lds r20,currentTime
 655 017c 5091 0000 		lds r21,currentTime+1
 656 0180 6091 0000 		lds r22,currentTime+2
 657 0184 7091 0000 		lds r23,currentTime+3
 658 0188 8091 0000 		lds r24,currentTime+4
 659 018c 00D0      		rcall setLeds
 660               	.LVL32:
 661 018e 00C0      		rjmp .L33
 662               	.L34:
 106:main.c        ****             }else if(m<4){
 663               		.loc 1 106 0
 664 0190 C430      		cpi r28,lo8(4)
 665 0192 00F4      		brsh .L33
 107:main.c        ****                 setLedsNb(RTC_readTemp(),leds);
 666               		.loc 1 107 0
 667 0194 00D0      		rcall RTC_readTemp
 668               	.LVL33:
 669 0196 60E0      		ldi r22,lo8(leds)
 670 0198 70E0      		ldi r23,hi8(leds)
 671 019a 00D0      		rcall setLedsNb
 672               	.LVL34:
 673               	.L33:
 108:main.c        ****             }
 109:main.c        ****         }
 110:main.c        ****         ledr=!ledr;
 674               		.loc 1 110 0
 675 019c 81E0      		ldi r24,lo8(1)
 676 019e 9091 0000 		lds r25,ledr
 677 01a2 9111      		cpse r25,__zero_reg__
 678 01a4 80E0      		ldi r24,0
 679               	.L35:
 680 01a6 8093 0000 		sts ledr,r24
 681               	.LBE31:
 682 01aa 00C0      		rjmp .L31
 683               	.LVL35:
 684               	.L32:
 685 01ac 00E0      		ldi r16,lo8(leds)
 686 01ae 10E0      		ldi r17,hi8(leds)
 100:main.c        ****         uint8_t m=getMode();
 687               		.loc 1 100 0
 688 01b0 C0E0      		ldi r28,0
 689               	.L39:
 690               	.LVL36:
 691               	.LBB32:
 111:main.c        ****     }else{//menu settings mode
 112:main.c        ****         for(uint8_t i=0;i<NBLEDS;i++){
 113:main.c        ****             if(Mcurrent->sub[Mindex].led==i){
 692               		.loc 1 113 0
 693 01b2 E091 0000 		lds r30,Mcurrent
 694 01b6 F091 0000 		lds r31,Mcurrent+1
 695 01ba 8091 0000 		lds r24,Mindex
 696 01be 90E0      		ldi r25,0
 697 01c0 0196      		adiw r24,1
 698 01c2 63E0      		ldi r22,lo8(3)
 699 01c4 70E0      		ldi r23,0
 700 01c6 00D0      		rcall __mulhi3
 701 01c8 8E0F      		add r24,r30
 702 01ca 9F1F      		adc r25,r31
 703 01cc DC01      		movw r26,r24
 704 01ce 8C91      		ld r24,X
 705 01d0 8C13      		cpse r24,r28
 706 01d2 00C0      		rjmp .L37
 114:main.c        ****                 ledOn(&leds[i],colorArray[Mcurrent->nb_optn>>4]);
 707               		.loc 1 114 0
 708 01d4 E081      		ld r30,Z
 709 01d6 E295      		swap r30
 710 01d8 EF70      		andi r30,lo8(15)
 711 01da F0E0      		ldi r31,0
 712 01dc E050      		subi r30,lo8(-(colorArray))
 713 01de F040      		sbci r31,hi8(-(colorArray))
 714 01e0 6081      		ld r22,Z
 715 01e2 C801      		movw r24,r16
 716 01e4 00D0      		rcall ledOn
 717               	.LVL37:
 718 01e6 00C0      		rjmp .L38
 719               	.L37:
 115:main.c        ****             }else{
 116:main.c        ****                 ledOff(&leds[i]);
 720               		.loc 1 116 0
 721 01e8 C801      		movw r24,r16
 722 01ea 00D0      		rcall ledOff
 723               	.LVL38:
 724               	.L38:
 112:main.c        ****             if(Mcurrent->sub[Mindex].led==i){
 725               		.loc 1 112 0 discriminator 2
 726 01ec CF5F      		subi r28,lo8(-(1))
 727               	.LVL39:
 728 01ee 0D5F      		subi r16,-3
 729 01f0 1F4F      		sbci r17,-1
 730 01f2 C331      		cpi r28,lo8(19)
 731 01f4 01F4      		brne .L39
 732               	.LVL40:
 733               	.L31:
 734               	/* epilogue start */
 735               	.LBE32:
 117:main.c        ****             }
 118:main.c        ****         }
 119:main.c        ****     }
 120:main.c        **** }
 736               		.loc 1 120 0
 737 01f6 FF91      		pop r31
 738 01f8 EF91      		pop r30
 739 01fa CF91      		pop r28
 740 01fc BF91      		pop r27
 741 01fe AF91      		pop r26
 742 0200 9F91      		pop r25
 743 0202 8F91      		pop r24
 744 0204 7F91      		pop r23
 745 0206 6F91      		pop r22
 746 0208 5F91      		pop r21
 747 020a 4F91      		pop r20
 748 020c 3F91      		pop r19
 749 020e 2F91      		pop r18
 750 0210 1F91      		pop r17
 751 0212 0F91      		pop r16
 752 0214 0F90      		pop r0
 753 0216 0FBE      		out __SREG__,r0
 754 0218 0F90      		pop r0
 755 021a 1F90      		pop r1
 756 021c 1895      		reti
 757               		.cfi_endproc
 758               	.LFE10:
 760               	.global	__vector_11
 762               	__vector_11:
 763               	.LFB11:
 121:main.c        **** ISR( TIM0_OVF_vect ){//mux for each color, row 0 and 1
 764               		.loc 1 121 0
 765               		.cfi_startproc
 766 021e 1F92      		push r1
 767               	.LCFI47:
 768               		.cfi_def_cfa_offset 3
 769               		.cfi_offset 1, -2
 770 0220 0F92      		push r0
 771               	.LCFI48:
 772               		.cfi_def_cfa_offset 4
 773               		.cfi_offset 0, -3
 774 0222 0FB6      		in r0,__SREG__
 775 0224 0F92      		push r0
 776 0226 1124      		clr __zero_reg__
 777 0228 2F93      		push r18
 778               	.LCFI49:
 779               		.cfi_def_cfa_offset 5
 780               		.cfi_offset 18, -4
 781 022a 3F93      		push r19
 782               	.LCFI50:
 783               		.cfi_def_cfa_offset 6
 784               		.cfi_offset 19, -5
 785 022c 4F93      		push r20
 786               	.LCFI51:
 787               		.cfi_def_cfa_offset 7
 788               		.cfi_offset 20, -6
 789 022e 5F93      		push r21
 790               	.LCFI52:
 791               		.cfi_def_cfa_offset 8
 792               		.cfi_offset 21, -7
 793 0230 6F93      		push r22
 794               	.LCFI53:
 795               		.cfi_def_cfa_offset 9
 796               		.cfi_offset 22, -8
 797 0232 7F93      		push r23
 798               	.LCFI54:
 799               		.cfi_def_cfa_offset 10
 800               		.cfi_offset 23, -9
 801 0234 8F93      		push r24
 802               	.LCFI55:
 803               		.cfi_def_cfa_offset 11
 804               		.cfi_offset 24, -10
 805 0236 9F93      		push r25
 806               	.LCFI56:
 807               		.cfi_def_cfa_offset 12
 808               		.cfi_offset 25, -11
 809 0238 AF93      		push r26
 810               	.LCFI57:
 811               		.cfi_def_cfa_offset 13
 812               		.cfi_offset 26, -12
 813 023a BF93      		push r27
 814               	.LCFI58:
 815               		.cfi_def_cfa_offset 14
 816               		.cfi_offset 27, -13
 817 023c EF93      		push r30
 818               	.LCFI59:
 819               		.cfi_def_cfa_offset 15
 820               		.cfi_offset 30, -14
 821 023e FF93      		push r31
 822               	.LCFI60:
 823               		.cfi_def_cfa_offset 16
 824               		.cfi_offset 31, -15
 825               	/* prologue: Signal */
 826               	/* frame size = 0 */
 827               	/* stack size = 15 */
 828               	.L__stack_usage = 15
 122:main.c        ****     switch(state){
 829               		.loc 1 122 0
 830 0240 8091 0000 		lds r24,state
 831 0244 8230      		cpi r24,lo8(2)
 832 0246 01F0      		breq .L49
 833 0248 00F4      		brsh .L50
 834 024a 8823      		tst r24
 835 024c 01F0      		breq .L51
 836 024e 8130      		cpi r24,lo8(1)
 837 0250 01F4      		brne .L48
 123:main.c        ****         case 0:
 124:main.c        ****             sendData(R2 | getDataByColor(RED,0,leds));
 125:main.c        ****             break;
 126:main.c        ****         case 1:
 127:main.c        ****             sendData(R1 | getDataByColor(RED,1,leds));
 838               		.loc 1 127 0
 839 0252 40E0      		ldi r20,lo8(leds)
 840 0254 50E0      		ldi r21,hi8(leds)
 841 0256 61E0      		ldi r22,lo8(1)
 842 0258 84E0      		ldi r24,lo8(4)
 843 025a 00D0      		rcall getDataByColor
 844               	.LVL41:
 845 025c 7068      		ori r23,128
 846 025e 00C0      		rjmp .L57
 847               	.L50:
 122:main.c        ****     switch(state){
 848               		.loc 1 122 0
 849 0260 8430      		cpi r24,lo8(4)
 850 0262 01F0      		breq .L53
 851 0264 00F0      		brlo .L54
 852 0266 8530      		cpi r24,lo8(5)
 853 0268 01F4      		brne .L48
 128:main.c        ****             break;
 129:main.c        ****         case 2:
 130:main.c        ****             sendData(G2 | getDataByColor(GREEN,0,leds));
 131:main.c        ****             break;
 132:main.c        ****         case 3:
 133:main.c        ****             sendData(G1 | getDataByColor(GREEN,1,leds));
 134:main.c        ****             break;
 135:main.c        ****         case 4:
 136:main.c        ****             sendData(B2 | getDataByColor(BLUE,0,leds));
 137:main.c        ****             break;
 138:main.c        ****         case 5:
 139:main.c        ****             sendData(B1 | getDataByColor(BLUE,1,leds));
 854               		.loc 1 139 0
 855 026a 40E0      		ldi r20,lo8(leds)
 856 026c 50E0      		ldi r21,hi8(leds)
 857 026e 61E0      		ldi r22,lo8(1)
 858 0270 81E0      		ldi r24,lo8(1)
 859 0272 00D0      		rcall getDataByColor
 860               	.LVL42:
 861 0274 8260      		ori r24,2
 862 0276 00C0      		rjmp .L57
 863               	.L51:
 124:main.c        ****             break;
 864               		.loc 1 124 0
 865 0278 40E0      		ldi r20,lo8(leds)
 866 027a 50E0      		ldi r21,hi8(leds)
 867 027c 60E0      		ldi r22,0
 868 027e 84E0      		ldi r24,lo8(4)
 869 0280 00D0      		rcall getDataByColor
 870               	.LVL43:
 871 0282 7064      		ori r23,64
 872 0284 00C0      		rjmp .L57
 873               	.L49:
 130:main.c        ****             break;
 874               		.loc 1 130 0
 875 0286 40E0      		ldi r20,lo8(leds)
 876 0288 50E0      		ldi r21,hi8(leds)
 877 028a 60E0      		ldi r22,0
 878 028c 82E0      		ldi r24,lo8(2)
 879 028e 00D0      		rcall getDataByColor
 880               	.LVL44:
 881 0290 8460      		ori r24,4
 882 0292 00C0      		rjmp .L57
 883               	.L54:
 133:main.c        ****             break;
 884               		.loc 1 133 0
 885 0294 40E0      		ldi r20,lo8(leds)
 886 0296 50E0      		ldi r21,hi8(leds)
 887 0298 61E0      		ldi r22,lo8(1)
 888 029a 82E0      		ldi r24,lo8(2)
 889 029c 00D0      		rcall getDataByColor
 890               	.LVL45:
 891 029e 8860      		ori r24,8
 892 02a0 00C0      		rjmp .L57
 893               	.L53:
 136:main.c        ****             break;
 894               		.loc 1 136 0
 895 02a2 40E0      		ldi r20,lo8(leds)
 896 02a4 50E0      		ldi r21,hi8(leds)
 897 02a6 60E0      		ldi r22,0
 898 02a8 81E0      		ldi r24,lo8(1)
 899 02aa 00D0      		rcall getDataByColor
 900               	.LVL46:
 901 02ac 8160      		ori r24,1
 902               	.L57:
 903               		.loc 1 139 0
 904 02ae 00D0      		rcall sendData
 905               	.LVL47:
 906               	.L48:
 140:main.c        ****             break;
 141:main.c        ****     }
 142:main.c        ****     state++;
 907               		.loc 1 142 0
 908 02b0 8091 0000 		lds r24,state
 909 02b4 8F5F      		subi r24,lo8(-(1))
 910 02b6 8093 0000 		sts state,r24
 143:main.c        ****     if(state>5)state=0;
 911               		.loc 1 143 0
 912 02ba 8091 0000 		lds r24,state
 913 02be 8630      		cpi r24,lo8(6)
 914 02c0 00F0      		brlo .L47
 915               		.loc 1 143 0 is_stmt 0 discriminator 1
 916 02c2 1092 0000 		sts state,__zero_reg__
 917               	.L47:
 918               	/* epilogue start */
 144:main.c        **** }
 919               		.loc 1 144 0 is_stmt 1
 920 02c6 FF91      		pop r31
 921 02c8 EF91      		pop r30
 922 02ca BF91      		pop r27
 923 02cc AF91      		pop r26
 924 02ce 9F91      		pop r25
 925 02d0 8F91      		pop r24
 926 02d2 7F91      		pop r23
 927 02d4 6F91      		pop r22
 928 02d6 5F91      		pop r21
 929 02d8 4F91      		pop r20
 930 02da 3F91      		pop r19
 931 02dc 2F91      		pop r18
 932 02de 0F90      		pop r0
 933 02e0 0FBE      		out __SREG__,r0
 934 02e2 0F90      		pop r0
 935 02e4 1F90      		pop r1
 936 02e6 1895      		reti
 937               		.cfi_endproc
 938               	.LFE11:
 940               		.comm	leds,57,1
 941               	.global	Mindex
 942               		.section .bss
 945               	Mindex:
 946 0000 00        		.zero	1
 947               	.global	Mcurrent
 950               	Mcurrent:
 951 0001 0000      		.zero	2
 952               	.global	state
 955               	state:
 956 0003 00        		.zero	1
 957               	.global	ledb
 960               	ledb:
 961 0004 00        		.zero	1
 962               	.global	ledr
 965               	ledr:
 966 0005 00        		.zero	1
 967               		.comm	M1rainbow,3,1
 968               		.comm	M1reset,3,1
 969               		.comm	M1eventMode,3,1
 970               		.comm	M2setminpm,3,1
 971               		.comm	M2setminam,3,1
 972               		.comm	M2sethourpm,3,1
 973               		.comm	M2sethouram,3,1
 974               		.comm	M1setTime,3,1
 975               		.comm	M3onhour,3,1
 976               		.comm	M2offhour,3,1
 977               		.comm	M1nightmode,3,1
 978               		.comm	M1cmode,3,1
 979               		.comm	M1mode,3,1
 980               		.comm	M0main,3,1
 981               		.comm	USI_I2C_Master_State,1,1
 982               		.comm	currentTime,5,1
 983               		.section	.rodata
 986               	colorArray:
 987 0000 07        		.byte	7
 988 0001 03        		.byte	3
 989 0002 01        		.byte	1
 990 0003 05        		.byte	5
 991 0004 04        		.byte	4
 992 0005 06        		.byte	6
 993 0006 02        		.byte	2
 994               		.text
 995               	.Letext0:
 996               		.file 3 "/usr/lib/avr/include/stdint.h"
 997               		.file 4 "RTC.h"
 998               		.file 5 "Menu.h"
 999               		.file 6 "Led.h"
 1000               		.file 7 "defines.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccrcxOVO.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccrcxOVO.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccrcxOVO.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccrcxOVO.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccrcxOVO.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccrcxOVO.s:12     .text:0000000000000000 sendData
     /tmp/ccrcxOVO.s:965    .bss:0000000000000005 ledr
     /tmp/ccrcxOVO.s:960    .bss:0000000000000004 ledb
     /tmp/ccrcxOVO.s:45     .text.startup:0000000000000000 main
                            *COM*:0000000000000039 leds
                            *COM*:0000000000000005 currentTime
     /tmp/ccrcxOVO.s:273    .text:0000000000000012 __vector_3
     /tmp/ccrcxOVO.s:950    .bss:0000000000000001 Mcurrent
     /tmp/ccrcxOVO.s:945    .bss:0000000000000000 Mindex
     /tmp/ccrcxOVO.s:383    .text:0000000000000078 __vector_2
                            *COM*:0000000000000003 M0main
     /tmp/ccrcxOVO.s:546    .text:0000000000000128 __vector_8
     /tmp/ccrcxOVO.s:986    .rodata:0000000000000000 colorArray
     /tmp/ccrcxOVO.s:762    .text:000000000000021e __vector_11
     /tmp/ccrcxOVO.s:955    .bss:0000000000000003 state
                            *COM*:0000000000000003 M1rainbow
                            *COM*:0000000000000003 M1reset
                            *COM*:0000000000000003 M1eventMode
                            *COM*:0000000000000003 M2setminpm
                            *COM*:0000000000000003 M2setminam
                            *COM*:0000000000000003 M2sethourpm
                            *COM*:0000000000000003 M2sethouram
                            *COM*:0000000000000003 M1setTime
                            *COM*:0000000000000003 M3onhour
                            *COM*:0000000000000003 M2offhour
                            *COM*:0000000000000003 M1nightmode
                            *COM*:0000000000000003 M1cmode
                            *COM*:0000000000000003 M1mode
                            *COM*:0000000000000001 USI_I2C_Master_State

UNDEFINED SYMBOLS
sendRawData
ledInit
Minit
RTC_readTime
findNextEntry
getSubMenu
ledOff
getMode
isInAllowedTime
setLeds
RTC_readTemp
setLedsNb
__mulhi3
ledOn
getDataByColor
__do_copy_data
__do_clear_bss
