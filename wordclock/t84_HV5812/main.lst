   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	sendRawData
  12               	sendRawData:
  13               	.LFB6:
  14               		.file 1 "main.c"
   1:main.c        **** #define F_CPU 16000000UL
   2:main.c        **** #include <avr/io.h>
   3:main.c        **** #include <avr/interrupt.h>
   4:main.c        **** #include <util/delay.h>
   5:main.c        **** #include "defines.h"
   6:main.c        **** #include "Led.h"
   7:main.c        **** #include "RTC.h"
   8:main.c        **** 
   9:main.c        **** void sendRawData(uint32_t data){
  15               		.loc 1 9 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26               	/* prologue: function */
  27               	/* frame size = 0 */
  28               	/* stack size = 2 */
  29               	.L__stack_usage = 2
  10:main.c        ****     PORTA &=~(STROBE|CLK);
  30               		.loc 1 10 0
  31 0004 2BB3      		in r18,0x1b
  32 0006 237F      		andi r18,lo8(-13)
  33 0008 2BBB      		out 0x1b,r18
  34               	.LVL1:
  35 000a 40E0      		ldi r20,0
  36 000c 50E0      		ldi r21,0
  37               	.LVL2:
  38               	.L4:
  39               	.LBB16:
  11:main.c        ****     for(uint8_t i=0;i<20;i++){
  12:main.c        ****         if((data>>i) & 0x00000001){
  40               		.loc 1 12 0
  41 000e 8B01      		movw r16,r22
  42 0010 9C01      		movw r18,r24
  43 0012 042E      		mov r0,r20
  44 0014 00C0      		rjmp 2f
  45               		1:
  46 0016 3695      		lsr r19
  47 0018 2795      		ror r18
  48 001a 1795      		ror r17
  49 001c 0795      		ror r16
  50               		2:
  51 001e 0A94      		dec r0
  52 0020 02F4      		brpl 1b
  53 0022 00FF      		sbrs r16,0
  54 0024 00C0      		rjmp .L2
  13:main.c        ****             PORTA|=DATA;
  55               		.loc 1 13 0
  56 0026 D99A      		sbi 0x1b,1
  57 0028 00C0      		rjmp .L3
  58               	.L2:
  14:main.c        ****         }else{
  15:main.c        ****             PORTA&=~DATA;
  59               		.loc 1 15 0
  60 002a D998      		cbi 0x1b,1
  61               	.L3:
  16:main.c        ****         }
  17:main.c        ****         PORTA|=CLK;
  62               		.loc 1 17 0 discriminator 2
  63 002c DB9A      		sbi 0x1b,3
  18:main.c        ****         PORTA&=~CLK;
  64               		.loc 1 18 0 discriminator 2
  65 002e DB98      		cbi 0x1b,3
  66               	.LVL3:
  67 0030 4F5F      		subi r20,-1
  68 0032 5F4F      		sbci r21,-1
  69               	.LVL4:
  11:main.c        ****         if((data>>i) & 0x00000001){
  70               		.loc 1 11 0 discriminator 2
  71 0034 4431      		cpi r20,20
  72 0036 5105      		cpc r21,__zero_reg__
  73 0038 01F4      		brne .L4
  74               	.LBE16:
  19:main.c        ****     }
  20:main.c        ****     PORTA|=STROBE;
  75               		.loc 1 20 0
  76 003a DA9A      		sbi 0x1b,2
  21:main.c        ****     PORTA&=~STROBE;
  77               		.loc 1 21 0
  78 003c DA98      		cbi 0x1b,2
  79               	/* epilogue start */
  22:main.c        **** }
  80               		.loc 1 22 0
  81 003e 1F91      		pop r17
  82 0040 0F91      		pop r16
  83 0042 0895      		ret
  84               		.cfi_endproc
  85               	.LFE6:
  87               	.global	sendData
  89               	sendData:
  90               	.LFB7:
  23:main.c        **** uint8_t ledr=0;
  24:main.c        **** uint8_t ledb=0;
  25:main.c        **** void sendData(uint32_t data){
  91               		.loc 1 25 0
  92               		.cfi_startproc
  93               	.LVL5:
  94               	/* prologue: function */
  95               	/* frame size = 0 */
  96               	/* stack size = 0 */
  97               	.L__stack_usage = 0
  26:main.c        ****     if(ledr)data|=LEDR;
  98               		.loc 1 26 0
  99 0044 2091 0000 		lds r18,ledr
 100 0048 2111      		cpse r18,__zero_reg__
 101               		.loc 1 26 0 is_stmt 0 discriminator 1
 102 004a 7860      		ori r23,8
 103               	.LVL6:
 104               	.L8:
  27:main.c        ****     if(ledb)data|=LEDB;
 105               		.loc 1 27 0 is_stmt 1
 106 004c 2091 0000 		lds r18,ledb
 107 0050 2111      		cpse r18,__zero_reg__
 108               		.loc 1 27 0 is_stmt 0 discriminator 1
 109 0052 7460      		ori r23,4
 110               	.LVL7:
 111               	.L9:
  28:main.c        ****     sendRawData(data);
 112               		.loc 1 28 0 is_stmt 1
 113 0054 00C0      		rjmp sendRawData
 114               	.LVL8:
 115               		.cfi_endproc
 116               	.LFE7:
 118               		.section	.text.startup,"ax",@progbits
 119               	.global	main
 121               	main:
 122               	.LFB8:
  29:main.c        **** }
  30:main.c        **** volatile uint8_t state=0;
  31:main.c        **** Led leds[NBLEDS];
  32:main.c        **** 
  33:main.c        **** int main(void){    
 123               		.loc 1 33 0
 124               		.cfi_startproc
 125               	/* prologue: function */
 126               	/* frame size = 0 */
 127               	/* stack size = 0 */
 128               	.L__stack_usage = 0
  34:main.c        ****     DDRA |= CLK|DATA|STROBE|LED;
 129               		.loc 1 34 0
 130 0000 8AB3      		in r24,0x1a
 131 0002 8F60      		ori r24,lo8(15)
 132 0004 8ABB      		out 0x1a,r24
  35:main.c        ****     PORTA &= ~(CLK|DATA|STROBE|LED);
 133               		.loc 1 35 0
 134 0006 8BB3      		in r24,0x1b
 135 0008 807F      		andi r24,lo8(-16)
 136 000a 8BBB      		out 0x1b,r24
  36:main.c        ****     ledInit(leds);
 137               		.loc 1 36 0
 138 000c 80E0      		ldi r24,lo8(leds)
 139 000e 90E0      		ldi r25,hi8(leds)
 140 0010 00D0      		rcall ledInit
 141               	.LVL9:
  37:main.c        ****     
  38:main.c        ****     TIMSK1|=(1<<TOIE1);
 142               		.loc 1 38 0
 143 0012 609A      		sbi 0xc,0
  39:main.c        ****     TIMSK0|=(1<<TOIE0);
 144               		.loc 1 39 0
 145 0014 89B7      		in r24,0x39
 146 0016 8160      		ori r24,lo8(1)
 147 0018 89BF      		out 0x39,r24
  40:main.c        ****     sei();
 148               		.loc 1 40 0
 149               	/* #APP */
 150               	 ;  40 "main.c" 1
 151 001a 7894      		sei
 152               	 ;  0 "" 2
  41:main.c        ****     
  42:main.c        ****     sendData(0b11111100001111111111);//white
 153               		.loc 1 42 0
 154               	/* #NOAPP */
 155 001c 6FEF      		ldi r22,lo8(-1)
 156 001e 73EC      		ldi r23,lo8(-61)
 157 0020 8FE0      		ldi r24,lo8(15)
 158 0022 90E0      		ldi r25,0
 159 0024 00D0      		rcall sendData
 160               	.LVL10:
 161               	.LBB17:
 162               	.LBB18:
 163               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164               		.loc 2 187 0
 165 0026 2FEF      		ldi r18,lo8(7999999)
 166 0028 81E1      		ldi r24,hi8(7999999)
 167 002a 9AE7      		ldi r25,hlo8(7999999)
 168 002c 2150      	1:	subi r18,1
 169 002e 8040      		sbci r24,0
 170 0030 9040      		sbci r25,0
 171 0032 01F4      		brne 1b
 172 0034 00C0      		rjmp .
 173 0036 0000      		nop
 174               	.LVL11:
 175               	.LBE18:
 176               	.LBE17:
  43:main.c        ****     _delay_ms(2500);
  44:main.c        ****     sendData(0b11000000001111111111);//green
 177               		.loc 1 44 0
 178 0038 6FEF      		ldi r22,lo8(-1)
 179 003a 73E0      		ldi r23,lo8(3)
 180 003c 8CE0      		ldi r24,lo8(12)
 181 003e 90E0      		ldi r25,0
 182 0040 00D0      		rcall sendData
 183               	.LVL12:
 184               	.LBB19:
 185               	.LBB20:
 186               		.loc 2 187 0
 187 0042 2FEF      		ldi r18,lo8(7999999)
 188 0044 81E1      		ldi r24,hi8(7999999)
 189 0046 9AE7      		ldi r25,hlo8(7999999)
 190 0048 2150      	1:	subi r18,1
 191 004a 8040      		sbci r24,0
 192 004c 9040      		sbci r25,0
 193 004e 01F4      		brne 1b
 194 0050 00C0      		rjmp .
 195 0052 0000      		nop
 196               	.LVL13:
 197               	.LBE20:
 198               	.LBE19:
  45:main.c        ****     _delay_ms(2500);
  46:main.c        ****     sendData(0b00001100001111111111);//red
 199               		.loc 1 46 0
 200 0054 6FEF      		ldi r22,lo8(-1)
 201 0056 73EC      		ldi r23,lo8(-61)
 202 0058 80E0      		ldi r24,0
 203 005a 90E0      		ldi r25,0
 204 005c 00D0      		rcall sendData
 205               	.LVL14:
 206               	.LBB21:
 207               	.LBB22:
 208               		.loc 2 187 0
 209 005e 2FEF      		ldi r18,lo8(7999999)
 210 0060 81E1      		ldi r24,hi8(7999999)
 211 0062 9AE7      		ldi r25,hlo8(7999999)
 212 0064 2150      	1:	subi r18,1
 213 0066 8040      		sbci r24,0
 214 0068 9040      		sbci r25,0
 215 006a 01F4      		brne 1b
 216 006c 00C0      		rjmp .
 217 006e 0000      		nop
 218               	.LVL15:
 219               	.LBE22:
 220               	.LBE21:
  47:main.c        ****     _delay_ms(2500);
  48:main.c        ****     sendData(0b00110000001111111111);//blue
 221               		.loc 1 48 0
 222 0070 6FEF      		ldi r22,lo8(-1)
 223 0072 73E0      		ldi r23,lo8(3)
 224 0074 83E0      		ldi r24,lo8(3)
 225 0076 90E0      		ldi r25,0
 226 0078 00D0      		rcall sendData
 227               	.LVL16:
 228               	.LBB23:
 229               	.LBB24:
 230               		.loc 2 187 0
 231 007a 2FEF      		ldi r18,lo8(7999999)
 232 007c 81E1      		ldi r24,hi8(7999999)
 233 007e 9AE7      		ldi r25,hlo8(7999999)
 234 0080 2150      	1:	subi r18,1
 235 0082 8040      		sbci r24,0
 236 0084 9040      		sbci r25,0
 237 0086 01F4      		brne 1b
 238 0088 00C0      		rjmp .
 239 008a 0000      		nop
 240               	.LVL17:
 241               	.LBE24:
 242               	.LBE23:
  49:main.c        ****     _delay_ms(2500);
  50:main.c        ****     sendData(0b11110000001111111111);//cyan
 243               		.loc 1 50 0
 244 008c 6FEF      		ldi r22,lo8(-1)
 245 008e 73E0      		ldi r23,lo8(3)
 246 0090 8FE0      		ldi r24,lo8(15)
 247 0092 90E0      		ldi r25,0
 248 0094 00D0      		rcall sendData
 249               	.LVL18:
 250               	.LBB25:
 251               	.LBB26:
 252               		.loc 2 187 0
 253 0096 2FEF      		ldi r18,lo8(7999999)
 254 0098 81E1      		ldi r24,hi8(7999999)
 255 009a 9AE7      		ldi r25,hlo8(7999999)
 256 009c 2150      	1:	subi r18,1
 257 009e 8040      		sbci r24,0
 258 00a0 9040      		sbci r25,0
 259 00a2 01F4      		brne 1b
 260 00a4 00C0      		rjmp .
 261 00a6 0000      		nop
 262               	.LVL19:
 263               	.LBE26:
 264               	.LBE25:
  51:main.c        ****     _delay_ms(2500);
  52:main.c        ****     sendData(0b00111100001111111111);//magenta
 265               		.loc 1 52 0
 266 00a8 6FEF      		ldi r22,lo8(-1)
 267 00aa 73EC      		ldi r23,lo8(-61)
 268 00ac 83E0      		ldi r24,lo8(3)
 269 00ae 90E0      		ldi r25,0
 270 00b0 00D0      		rcall sendData
 271               	.LVL20:
 272               	.LBB27:
 273               	.LBB28:
 274               		.loc 2 187 0
 275 00b2 2FEF      		ldi r18,lo8(7999999)
 276 00b4 81E1      		ldi r24,hi8(7999999)
 277 00b6 9AE7      		ldi r25,hlo8(7999999)
 278 00b8 2150      	1:	subi r18,1
 279 00ba 8040      		sbci r24,0
 280 00bc 9040      		sbci r25,0
 281 00be 01F4      		brne 1b
 282 00c0 00C0      		rjmp .
 283 00c2 0000      		nop
 284               	.LVL21:
 285               	.LBE28:
 286               	.LBE27:
  53:main.c        ****     _delay_ms(2500);
  54:main.c        ****     sendData(0b11001100001111111111);//yellow
 287               		.loc 1 54 0
 288 00c4 6FEF      		ldi r22,lo8(-1)
 289 00c6 73EC      		ldi r23,lo8(-61)
 290 00c8 8CE0      		ldi r24,lo8(12)
 291 00ca 90E0      		ldi r25,0
 292 00cc 00D0      		rcall sendData
 293               	.LVL22:
 294               	.LBB29:
 295               	.LBB30:
 296               		.loc 2 187 0
 297 00ce 2FEF      		ldi r18,lo8(7999999)
 298 00d0 81E1      		ldi r24,hi8(7999999)
 299 00d2 9AE7      		ldi r25,hlo8(7999999)
 300 00d4 2150      	1:	subi r18,1
 301 00d6 8040      		sbci r24,0
 302 00d8 9040      		sbci r25,0
 303 00da 01F4      		brne 1b
 304 00dc 00C0      		rjmp .
 305 00de 0000      		nop
 306               	.LVL23:
 307               	.LBE30:
 308               	.LBE29:
  55:main.c        ****     _delay_ms(2500);
  56:main.c        ****     
  57:main.c        ****     #ifdef DELLONG
  58:main.c        ****     TCCR1B|=(1<<CS12)|(1<<CS10);
  59:main.c        ****     #else
  60:main.c        ****     TCCR1B|=(1<<CS12);//|(1<<CS10);
 309               		.loc 1 60 0
 310 00e0 8EB5      		in r24,0x2e
 311 00e2 8460      		ori r24,lo8(4)
 312 00e4 8EBD      		out 0x2e,r24
  61:main.c        ****     #endif
  62:main.c        ****     
  63:main.c        ****     TCCR0B|=(1<<CS01)|(1<<CS00);
 313               		.loc 1 63 0
 314 00e6 83B7      		in r24,0x33
 315 00e8 8360      		ori r24,lo8(3)
 316 00ea 83BF      		out 0x33,r24
  64:main.c        ****     
  65:main.c        ****     currentColor=tcolorV(WHITE);
 317               		.loc 1 65 0
 318 00ec 6FEF      		ldi r22,lo8(-1)
 319 00ee 7FEF      		ldi r23,lo8(-1)
 320 00f0 8FEF      		ldi r24,lo8(-1)
 321 00f2 90E0      		ldi r25,0
 322 00f4 00D0      		rcall tcolorV
 323               	.LVL24:
 324 00f6 6093 0000 		sts currentColor,r22
 325 00fa 7093 0000 		sts currentColor+1,r23
 326 00fe 8093 0000 		sts currentColor+2,r24
  66:main.c        ****     //setCurrentTime(0,10,7,12);
  67:main.c        ****     //RTC_setTime(currentTime,6,18);
  68:main.c        ****     RTC_readTime(&currentTime);
 327               		.loc 1 68 0
 328 0102 80E0      		ldi r24,lo8(currentTime)
 329 0104 90E0      		ldi r25,hi8(currentTime)
 330 0106 00D0      		rcall RTC_readTime
 331               	.LVL25:
  69:main.c        ****     setLeds(currentTime,leds,currentColor);
 332               		.loc 1 69 0
 333 0108 E090 0000 		lds r14,currentColor
 334 010c F090 0000 		lds r15,currentColor+1
 335 0110 0091 0000 		lds r16,currentColor+2
 336 0114 20E0      		ldi r18,lo8(leds)
 337 0116 30E0      		ldi r19,hi8(leds)
 338 0118 4091 0000 		lds r20,currentTime
 339 011c 5091 0000 		lds r21,currentTime+1
 340 0120 6091 0000 		lds r22,currentTime+2
 341 0124 7091 0000 		lds r23,currentTime+3
 342 0128 8091 0000 		lds r24,currentTime+4
 343 012c 00D0      		rcall setLeds
 344               	.LVL26:
 345               	.L17:
 346 012e 00C0      		rjmp .L17
 347               		.cfi_endproc
 348               	.LFE8:
 350               		.text
 351               	.global	__vector_8
 353               	__vector_8:
 354               	.LFB9:
  70:main.c        ****     //setLedsNb(currentTime.temp,leds,currentColor);
  71:main.c        ****     while(1){
  72:main.c        ****         
  73:main.c        ****     }
  74:main.c        ****     return(0);
  75:main.c        ****     
  76:main.c        **** }
  77:main.c        **** ISR( TIM1_OVF_vect ){
 355               		.loc 1 77 0
 356               		.cfi_startproc
 357 0056 1F92      		push r1
 358               	.LCFI2:
 359               		.cfi_def_cfa_offset 3
 360               		.cfi_offset 1, -2
 361 0058 0F92      		push r0
 362               	.LCFI3:
 363               		.cfi_def_cfa_offset 4
 364               		.cfi_offset 0, -3
 365 005a 0FB6      		in r0,__SREG__
 366 005c 0F92      		push r0
 367 005e 1124      		clr __zero_reg__
 368 0060 EF92      		push r14
 369               	.LCFI4:
 370               		.cfi_def_cfa_offset 5
 371               		.cfi_offset 14, -4
 372 0062 FF92      		push r15
 373               	.LCFI5:
 374               		.cfi_def_cfa_offset 6
 375               		.cfi_offset 15, -5
 376 0064 0F93      		push r16
 377               	.LCFI6:
 378               		.cfi_def_cfa_offset 7
 379               		.cfi_offset 16, -6
 380 0066 2F93      		push r18
 381               	.LCFI7:
 382               		.cfi_def_cfa_offset 8
 383               		.cfi_offset 18, -7
 384 0068 3F93      		push r19
 385               	.LCFI8:
 386               		.cfi_def_cfa_offset 9
 387               		.cfi_offset 19, -8
 388 006a 4F93      		push r20
 389               	.LCFI9:
 390               		.cfi_def_cfa_offset 10
 391               		.cfi_offset 20, -9
 392 006c 5F93      		push r21
 393               	.LCFI10:
 394               		.cfi_def_cfa_offset 11
 395               		.cfi_offset 21, -10
 396 006e 6F93      		push r22
 397               	.LCFI11:
 398               		.cfi_def_cfa_offset 12
 399               		.cfi_offset 22, -11
 400 0070 7F93      		push r23
 401               	.LCFI12:
 402               		.cfi_def_cfa_offset 13
 403               		.cfi_offset 23, -12
 404 0072 8F93      		push r24
 405               	.LCFI13:
 406               		.cfi_def_cfa_offset 14
 407               		.cfi_offset 24, -13
 408 0074 9F93      		push r25
 409               	.LCFI14:
 410               		.cfi_def_cfa_offset 15
 411               		.cfi_offset 25, -14
 412 0076 AF93      		push r26
 413               	.LCFI15:
 414               		.cfi_def_cfa_offset 16
 415               		.cfi_offset 26, -15
 416 0078 BF93      		push r27
 417               	.LCFI16:
 418               		.cfi_def_cfa_offset 17
 419               		.cfi_offset 27, -16
 420 007a EF93      		push r30
 421               	.LCFI17:
 422               		.cfi_def_cfa_offset 18
 423               		.cfi_offset 30, -17
 424 007c FF93      		push r31
 425               	.LCFI18:
 426               		.cfi_def_cfa_offset 19
 427               		.cfi_offset 31, -18
 428               	/* prologue: Signal */
 429               	/* frame size = 0 */
 430               	/* stack size = 18 */
 431               	.L__stack_usage = 18
  78:main.c        ****     ledr=!ledr;
 432               		.loc 1 78 0
 433 007e 81E0      		ldi r24,lo8(1)
 434 0080 9091 0000 		lds r25,ledr
 435 0084 9111      		cpse r25,__zero_reg__
 436 0086 80E0      		ldi r24,0
 437               	.L19:
 438 0088 8093 0000 		sts ledr,r24
  79:main.c        ****    // if(ledr){
  80:main.c        ****         RTC_readTime(&currentTime);
 439               		.loc 1 80 0
 440 008c 80E0      		ldi r24,lo8(currentTime)
 441 008e 90E0      		ldi r25,hi8(currentTime)
 442 0090 00D0      		rcall RTC_readTime
 443               	.LVL27:
  81:main.c        ****         setLeds(currentTime,leds,tcolorV(YELLOW));
 444               		.loc 1 81 0
 445 0092 60E0      		ldi r22,0
 446 0094 7FEF      		ldi r23,lo8(-1)
 447 0096 8FEF      		ldi r24,lo8(-1)
 448 0098 90E0      		ldi r25,0
 449 009a 00D0      		rcall tcolorV
 450               	.LVL28:
 451 009c 7B01      		movw r14,r22
 452 009e 082F      		mov r16,r24
 453 00a0 20E0      		ldi r18,lo8(leds)
 454 00a2 30E0      		ldi r19,hi8(leds)
 455 00a4 4091 0000 		lds r20,currentTime
 456 00a8 5091 0000 		lds r21,currentTime+1
 457 00ac 6091 0000 		lds r22,currentTime+2
 458 00b0 7091 0000 		lds r23,currentTime+3
 459 00b4 8091 0000 		lds r24,currentTime+4
 460 00b8 00D0      		rcall setLeds
 461               	.LVL29:
  82:main.c        ****     //}else{
  83:main.c        ****     ledb++;
 462               		.loc 1 83 0
 463 00ba 8091 0000 		lds r24,ledb
 464 00be 8F5F      		subi r24,lo8(-(1))
  84:main.c        ****     if(ledb>39)ledb=0;
 465               		.loc 1 84 0
 466 00c0 8832      		cpi r24,lo8(40)
 467 00c2 00F4      		brsh .L20
  83:main.c        ****     if(ledb>39)ledb=0;
 468               		.loc 1 83 0
 469 00c4 8093 0000 		sts ledb,r24
 470 00c8 00C0      		rjmp .L21
 471               	.L20:
 472               		.loc 1 84 0 discriminator 1
 473 00ca 1092 0000 		sts ledb,__zero_reg__
 474               	.L21:
  85:main.c        ****         setLedsNb(ledb/*RTC_readTemp()*/,leds,tcolorV(CYAN));
 475               		.loc 1 85 0
 476 00ce 6FEF      		ldi r22,lo8(-1)
 477 00d0 7FEF      		ldi r23,lo8(-1)
 478 00d2 80E0      		ldi r24,0
 479 00d4 90E0      		ldi r25,0
 480 00d6 00D0      		rcall tcolorV
 481               	.LVL30:
 482 00d8 9B01      		movw r18,r22
 483 00da 482F      		mov r20,r24
 484 00dc 60E0      		ldi r22,lo8(leds)
 485 00de 70E0      		ldi r23,hi8(leds)
 486 00e0 8091 0000 		lds r24,ledb
 487 00e4 00D0      		rcall setLedsNb
 488               	.LVL31:
 489               	/* epilogue start */
  86:main.c        ****     //}
  87:main.c        ****     
  88:main.c        **** }
 490               		.loc 1 88 0
 491 00e6 FF91      		pop r31
 492 00e8 EF91      		pop r30
 493 00ea BF91      		pop r27
 494 00ec AF91      		pop r26
 495 00ee 9F91      		pop r25
 496 00f0 8F91      		pop r24
 497 00f2 7F91      		pop r23
 498 00f4 6F91      		pop r22
 499 00f6 5F91      		pop r21
 500 00f8 4F91      		pop r20
 501 00fa 3F91      		pop r19
 502 00fc 2F91      		pop r18
 503 00fe 0F91      		pop r16
 504 0100 FF90      		pop r15
 505 0102 EF90      		pop r14
 506 0104 0F90      		pop r0
 507 0106 0FBE      		out __SREG__,r0
 508 0108 0F90      		pop r0
 509 010a 1F90      		pop r1
 510 010c 1895      		reti
 511               		.cfi_endproc
 512               	.LFE9:
 514               	.global	__vector_11
 516               	__vector_11:
 517               	.LFB10:
  89:main.c        **** ISR( TIM0_OVF_vect ){
 518               		.loc 1 89 0
 519               		.cfi_startproc
 520 010e 1F92      		push r1
 521               	.LCFI19:
 522               		.cfi_def_cfa_offset 3
 523               		.cfi_offset 1, -2
 524 0110 0F92      		push r0
 525               	.LCFI20:
 526               		.cfi_def_cfa_offset 4
 527               		.cfi_offset 0, -3
 528 0112 0FB6      		in r0,__SREG__
 529 0114 0F92      		push r0
 530 0116 1124      		clr __zero_reg__
 531 0118 2F93      		push r18
 532               	.LCFI21:
 533               		.cfi_def_cfa_offset 5
 534               		.cfi_offset 18, -4
 535 011a 3F93      		push r19
 536               	.LCFI22:
 537               		.cfi_def_cfa_offset 6
 538               		.cfi_offset 19, -5
 539 011c 4F93      		push r20
 540               	.LCFI23:
 541               		.cfi_def_cfa_offset 7
 542               		.cfi_offset 20, -6
 543 011e 5F93      		push r21
 544               	.LCFI24:
 545               		.cfi_def_cfa_offset 8
 546               		.cfi_offset 21, -7
 547 0120 6F93      		push r22
 548               	.LCFI25:
 549               		.cfi_def_cfa_offset 9
 550               		.cfi_offset 22, -8
 551 0122 7F93      		push r23
 552               	.LCFI26:
 553               		.cfi_def_cfa_offset 10
 554               		.cfi_offset 23, -9
 555 0124 8F93      		push r24
 556               	.LCFI27:
 557               		.cfi_def_cfa_offset 11
 558               		.cfi_offset 24, -10
 559 0126 9F93      		push r25
 560               	.LCFI28:
 561               		.cfi_def_cfa_offset 12
 562               		.cfi_offset 25, -11
 563 0128 AF93      		push r26
 564               	.LCFI29:
 565               		.cfi_def_cfa_offset 13
 566               		.cfi_offset 26, -12
 567 012a BF93      		push r27
 568               	.LCFI30:
 569               		.cfi_def_cfa_offset 14
 570               		.cfi_offset 27, -13
 571 012c EF93      		push r30
 572               	.LCFI31:
 573               		.cfi_def_cfa_offset 15
 574               		.cfi_offset 30, -14
 575 012e FF93      		push r31
 576               	.LCFI32:
 577               		.cfi_def_cfa_offset 16
 578               		.cfi_offset 31, -15
 579               	/* prologue: Signal */
 580               	/* frame size = 0 */
 581               	/* stack size = 15 */
 582               	.L__stack_usage = 15
  90:main.c        ****     switch(state){
 583               		.loc 1 90 0
 584 0130 8091 0000 		lds r24,state
 585 0134 8230      		cpi r24,lo8(2)
 586 0136 01F0      		breq .L27
 587 0138 00F4      		brsh .L28
 588 013a 8823      		tst r24
 589 013c 01F0      		breq .L29
 590 013e 8130      		cpi r24,lo8(1)
 591 0140 01F0      		breq .+2
 592 0142 00C0      		rjmp .L26
  91:main.c        ****         case 0:
  92:main.c        ****             sendData(R2 | getDataByColor(tcolor(1,0,0),0,leds));
  93:main.c        ****             break;
  94:main.c        ****         case 1:
  95:main.c        ****             sendData(R1 | getDataByColor(tcolor(1,0,0),1,leds));
 593               		.loc 1 95 0
 594 0144 40E0      		ldi r20,0
 595 0146 60E0      		ldi r22,0
 596 0148 81E0      		ldi r24,lo8(1)
 597 014a 00D0      		rcall tcolor
 598               	.LVL32:
 599 014c 20E0      		ldi r18,lo8(leds)
 600 014e 30E0      		ldi r19,hi8(leds)
 601 0150 41E0      		ldi r20,lo8(1)
 602 0152 00D0      		rcall getDataByColor
 603               	.LVL33:
 604 0154 7068      		ori r23,128
 605 0156 00C0      		rjmp .L35
 606               	.L28:
  90:main.c        ****     switch(state){
 607               		.loc 1 90 0
 608 0158 8430      		cpi r24,lo8(4)
 609 015a 01F0      		breq .L31
 610 015c 00F0      		brlo .L32
 611 015e 8530      		cpi r24,lo8(5)
 612 0160 01F4      		brne .L26
  96:main.c        ****             break;
  97:main.c        ****         case 2:
  98:main.c        ****             sendData(G2 | getDataByColor(tcolor(0,1,0),0,leds));
  99:main.c        ****             break;
 100:main.c        ****         case 3:
 101:main.c        ****             sendData(G1 | getDataByColor(tcolor(0,1,0),1,leds));
 102:main.c        ****             break;
 103:main.c        ****         case 4:
 104:main.c        ****             sendData(B2 | getDataByColor(tcolor(0,0,1),0,leds));
 105:main.c        ****             break;
 106:main.c        ****         case 5:
 107:main.c        ****             sendData(B1 | getDataByColor(tcolor(0,0,1),1,leds));
 613               		.loc 1 107 0
 614 0162 41E0      		ldi r20,lo8(1)
 615 0164 60E0      		ldi r22,0
 616 0166 80E0      		ldi r24,0
 617 0168 00D0      		rcall tcolor
 618               	.LVL34:
 619 016a 20E0      		ldi r18,lo8(leds)
 620 016c 30E0      		ldi r19,hi8(leds)
 621 016e 41E0      		ldi r20,lo8(1)
 622 0170 00D0      		rcall getDataByColor
 623               	.LVL35:
 624 0172 8260      		ori r24,2
 625 0174 00C0      		rjmp .L35
 626               	.L29:
  92:main.c        ****             break;
 627               		.loc 1 92 0
 628 0176 40E0      		ldi r20,0
 629 0178 60E0      		ldi r22,0
 630 017a 81E0      		ldi r24,lo8(1)
 631 017c 00D0      		rcall tcolor
 632               	.LVL36:
 633 017e 20E0      		ldi r18,lo8(leds)
 634 0180 30E0      		ldi r19,hi8(leds)
 635 0182 40E0      		ldi r20,0
 636 0184 00D0      		rcall getDataByColor
 637               	.LVL37:
 638 0186 7064      		ori r23,64
 639 0188 00C0      		rjmp .L35
 640               	.L27:
  98:main.c        ****             break;
 641               		.loc 1 98 0
 642 018a 40E0      		ldi r20,0
 643 018c 61E0      		ldi r22,lo8(1)
 644 018e 80E0      		ldi r24,0
 645 0190 00D0      		rcall tcolor
 646               	.LVL38:
 647 0192 20E0      		ldi r18,lo8(leds)
 648 0194 30E0      		ldi r19,hi8(leds)
 649 0196 40E0      		ldi r20,0
 650 0198 00D0      		rcall getDataByColor
 651               	.LVL39:
 652 019a 8460      		ori r24,4
 653 019c 00C0      		rjmp .L35
 654               	.L32:
 101:main.c        ****             break;
 655               		.loc 1 101 0
 656 019e 40E0      		ldi r20,0
 657 01a0 61E0      		ldi r22,lo8(1)
 658 01a2 80E0      		ldi r24,0
 659 01a4 00D0      		rcall tcolor
 660               	.LVL40:
 661 01a6 20E0      		ldi r18,lo8(leds)
 662 01a8 30E0      		ldi r19,hi8(leds)
 663 01aa 41E0      		ldi r20,lo8(1)
 664 01ac 00D0      		rcall getDataByColor
 665               	.LVL41:
 666 01ae 8860      		ori r24,8
 667 01b0 00C0      		rjmp .L35
 668               	.L31:
 104:main.c        ****             break;
 669               		.loc 1 104 0
 670 01b2 41E0      		ldi r20,lo8(1)
 671 01b4 60E0      		ldi r22,0
 672 01b6 80E0      		ldi r24,0
 673 01b8 00D0      		rcall tcolor
 674               	.LVL42:
 675 01ba 20E0      		ldi r18,lo8(leds)
 676 01bc 30E0      		ldi r19,hi8(leds)
 677 01be 40E0      		ldi r20,0
 678 01c0 00D0      		rcall getDataByColor
 679               	.LVL43:
 680 01c2 8160      		ori r24,1
 681               	.L35:
 682               		.loc 1 107 0
 683 01c4 00D0      		rcall sendData
 684               	.LVL44:
 685               	.L26:
 108:main.c        ****             break;
 109:main.c        ****     }
 110:main.c        ****     state++;
 686               		.loc 1 110 0
 687 01c6 8091 0000 		lds r24,state
 688 01ca 8F5F      		subi r24,lo8(-(1))
 689 01cc 8093 0000 		sts state,r24
 111:main.c        ****     if(state>5)state=0;
 690               		.loc 1 111 0
 691 01d0 8091 0000 		lds r24,state
 692 01d4 8630      		cpi r24,lo8(6)
 693 01d6 00F0      		brlo .L25
 694               		.loc 1 111 0 is_stmt 0 discriminator 1
 695 01d8 1092 0000 		sts state,__zero_reg__
 696               	.L25:
 697               	/* epilogue start */
 112:main.c        **** }
 698               		.loc 1 112 0 is_stmt 1
 699 01dc FF91      		pop r31
 700 01de EF91      		pop r30
 701 01e0 BF91      		pop r27
 702 01e2 AF91      		pop r26
 703 01e4 9F91      		pop r25
 704 01e6 8F91      		pop r24
 705 01e8 7F91      		pop r23
 706 01ea 6F91      		pop r22
 707 01ec 5F91      		pop r21
 708 01ee 4F91      		pop r20
 709 01f0 3F91      		pop r19
 710 01f2 2F91      		pop r18
 711 01f4 0F90      		pop r0
 712 01f6 0FBE      		out __SREG__,r0
 713 01f8 0F90      		pop r0
 714 01fa 1F90      		pop r1
 715 01fc 1895      		reti
 716               		.cfi_endproc
 717               	.LFE10:
 719               		.comm	leds,95,1
 720               	.global	state
 721               		.section .bss
 724               	state:
 725 0000 00        		.zero	1
 726               	.global	ledb
 729               	ledb:
 730 0001 00        		.zero	1
 731               	.global	ledr
 734               	ledr:
 735 0002 00        		.zero	1
 736               		.comm	currentColor,3,1
 737               		.comm	USI_I2C_Master_State,1,1
 738               		.comm	currentTime,5,1
 739               		.text
 740               	.Letext0:
 741               		.file 3 "/usr/lib/avr/include/stdint.h"
 742               		.file 4 "RTC.h"
 743               		.file 5 "Led.h"
 744               		.file 6 "defines.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccqMGkUR.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccqMGkUR.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccqMGkUR.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccqMGkUR.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccqMGkUR.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccqMGkUR.s:12     .text:0000000000000000 sendRawData
     /tmp/ccqMGkUR.s:89     .text:0000000000000044 sendData
     /tmp/ccqMGkUR.s:734    .bss:0000000000000002 ledr
     /tmp/ccqMGkUR.s:729    .bss:0000000000000001 ledb
     /tmp/ccqMGkUR.s:121    .text.startup:0000000000000000 main
                            *COM*:000000000000005f leds
                            *COM*:0000000000000003 currentColor
                            *COM*:0000000000000005 currentTime
     /tmp/ccqMGkUR.s:353    .text:0000000000000056 __vector_8
     /tmp/ccqMGkUR.s:516    .text:000000000000010e __vector_11
     /tmp/ccqMGkUR.s:724    .bss:0000000000000000 state
                            *COM*:0000000000000001 USI_I2C_Master_State

UNDEFINED SYMBOLS
ledInit
tcolorV
RTC_readTime
setLeds
setLedsNb
tcolor
getDataByColor
__do_clear_bss
